{
  "openapi": "3.0.1",
  "info": {
    "title": "Evmos Chain - gRPC Gateway docs",
    "description": "A REST interface for state queries and transactions",
    "version": "1.0.0"
  },
  "servers": [
    {
      "url": "https://rest.bd.evmos.dev:1317/"
    }
  ],
  "paths": {
    "/evmos/claims/v1/claims_records": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ClaimsRecords returns all claims records",
        "operationId": "ClaimsRecords",
        "parameters": [
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "claims": {
                      "title": "claims defines all claims records",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "address": {
                            "title": "address of claiming user in either bech32 or hex format",
                            "type": "string"
                          },
                          "initial_claimable_amount": {
                            "title": "initial_claimable_amount for the user",
                            "type": "string"
                          },
                          "actions_completed": {
                            "title": "actions_completed is a slice that describes which actions were completed",
                            "type": "array",
                            "items": {
                              "type": "boolean"
                            }
                          }
                        },
                        "description": "ClaimsRecordAddress is the claims metadata per address that is used at\nGenesis."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryClaimsRecordsResponse is the response type for the Query/ClaimsRecords\nRPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/claims/v1/claims_records/{address}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ClaimsRecord returns the claims record for a given address",
        "operationId": "ClaimsRecord",
        "parameters": [
          {
            "name": "address",
            "in": "path",
            "description": "address defines the user to query claims record for",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "initial_claimable_amount": {
                      "title": "initial_claimable_amount of the user",
                      "type": "string"
                    },
                    "claims": {
                      "title": "claims of the user",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "action": {
                            "title": "action enum",
                            "type": "string",
                            "description": "Action defines the list of available actions to claim the airdrop tokens.\n\n - ACTION_UNSPECIFIED: ACTION_UNSPECIFIED defines an invalid action.\n - ACTION_VOTE: ACTION_VOTE defines a proposal vote.\n - ACTION_DELEGATE: ACTION_DELEGATE defines an staking delegation.\n - ACTION_EVM: ACTION_EVM defines an EVM transaction.\n - ACTION_IBC_TRANSFER: ACTION_IBC_TRANSFER defines a fungible token transfer transaction via IBC.",
                            "default": "ACTION_UNSPECIFIED",
                            "enum": [
                              "ACTION_UNSPECIFIED",
                              "ACTION_VOTE",
                              "ACTION_DELEGATE",
                              "ACTION_EVM",
                              "ACTION_IBC_TRANSFER"
                            ]
                          },
                          "completed": {
                            "title": "completed is true if the action has been completed",
                            "type": "boolean"
                          },
                          "claimable_amount": {
                            "title": "claimable_amount of tokens for the action. Zero if completed",
                            "type": "string"
                          }
                        },
                        "description": "Claim defines the action, completed flag and the remaining claimable amount\nfor a given user. This is only used during client queries."
                      }
                    }
                  },
                  "description": "QueryClaimsRecordResponse is the response type for the Query/ClaimsRecord RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/claims/v1/params": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Params returns the claims module parameters",
        "operationId": "ClaimsParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "params": {
                      "type": "object",
                      "properties": {
                        "enable_claims": {
                          "title": "enable_claims is the parameter to enable the claiming process",
                          "type": "boolean"
                        },
                        "airdrop_start_time": {
                          "title": "airdrop_start_time defines the timestamp of the airdrop start",
                          "type": "string",
                          "format": "date-time"
                        },
                        "duration_until_decay": {
                          "title": "duration_until_decay of claimable tokens begin",
                          "type": "string"
                        },
                        "duration_of_decay": {
                          "title": "duration_of_decay for token claim decay period",
                          "type": "string"
                        },
                        "claims_denom": {
                          "title": "claims_denom is the denomination of the claimable coin",
                          "type": "string"
                        },
                        "authorized_channels": {
                          "type": "array",
                          "description": "authorized_channels is the list of authorized channel identifiers that can perform address\nattestations via IBC.",
                          "items": {
                            "type": "string"
                          }
                        },
                        "evm_channels": {
                          "title": "evm_channels is the list of channel identifiers from EVM compatible chains",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      },
                      "description": "params defines the parameters of the module."
                    }
                  },
                  "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/claims/v1/total_unclaimed": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "TotalUnclaimed queries the total unclaimed tokens from the airdrop",
        "operationId": "TotalUnclaimed",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "coins": {
                      "title": "coins defines the unclaimed coins",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      }
                    }
                  },
                  "description": "QueryTotalUnclaimedResponse is the response type for the Query/TotalUnclaimed\nRPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/epochs/v1/current_epoch": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "CurrentEpoch provide current epoch of specified identifier",
        "operationId": "CurrentEpoch",
        "parameters": [
          {
            "name": "identifier",
            "in": "query",
            "description": "identifier of the current epoch.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "current_epoch": {
                      "title": "current_epoch is the number of the current epoch",
                      "type": "string",
                      "format": "int64"
                    }
                  },
                  "description": "QueryCurrentEpochResponse is the response type for the Query/EpochInfos RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/epochs/v1/epochs": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "EpochInfos provide running epochInfos",
        "operationId": "EpochInfos",
        "parameters": [
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "epochs": {
                      "title": "epochs is a slice of all EpochInfos",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "identifier": {
                            "title": "identifier of the epoch",
                            "type": "string"
                          },
                          "start_time": {
                            "title": "start_time of the epoch",
                            "type": "string",
                            "format": "date-time"
                          },
                          "duration": {
                            "title": "duration of the epoch",
                            "type": "string"
                          },
                          "current_epoch": {
                            "title": "current_epoch is the integer identifier of the epoch",
                            "type": "string",
                            "format": "int64"
                          },
                          "current_epoch_start_time": {
                            "title": "current_epoch_start_time defines the timestamp of the start of the epoch",
                            "type": "string",
                            "format": "date-time"
                          },
                          "epoch_counting_started": {
                            "title": "epoch_counting_started reflects if the counting for the epoch has started",
                            "type": "boolean"
                          },
                          "current_epoch_start_height": {
                            "title": "current_epoch_start_height of the epoch",
                            "type": "string",
                            "format": "int64"
                          }
                        },
                        "description": "EpochInfo defines the message interface containing the relevant informations about\nan epoch."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines an optional pagination for the request."
                    }
                  },
                  "description": "QueryEpochsInfoResponse is the response type for the Query/EpochInfos RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/erc20/v1/params": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Params retrieves the erc20 module params",
        "operationId": "ERC20Params",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "params": {
                      "title": "params are the erc20 module parameters",
                      "type": "object",
                      "properties": {
                        "enable_erc20": {
                          "type": "boolean",
                          "description": "enable_erc20 is the parameter to enable the conversion of Cosmos coins <--> ERC20 tokens."
                        },
                        "enable_evm_hook": {
                          "type": "boolean",
                          "description": "enable_evm_hook is the parameter to enable the EVM hook that converts an ERC20 token to a Cosmos\nCoin by transferring the Tokens through a MsgEthereumTx to the ModuleAddress Ethereum address."
                        }
                      }
                    }
                  },
                  "description": "QueryParamsResponse is the response type for the Query/Params RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/erc20/v1/token_pairs": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "TokenPairs retrieves registered token pairs",
        "operationId": "TokenPairs",
        "parameters": [
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "token_pairs": {
                      "title": "token_pairs is a slice of registered token pairs for the erc20 module",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "erc20_address": {
                            "title": "erc20_address is the hex address of ERC20 contract token",
                            "type": "string"
                          },
                          "denom": {
                            "title": "denom defines the cosmos base denomination to be mapped to",
                            "type": "string"
                          },
                          "enabled": {
                            "title": "enabled defines the token mapping enable status",
                            "type": "boolean"
                          },
                          "contract_owner": {
                            "title": "contract_owner is the an ENUM specifying the type of ERC20 owner (0 invalid, 1 ModuleAccount, 2 external address)",
                            "type": "string",
                            "description": "Owner enumerates the ownership of a ERC20 contract.\n\n - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.\n - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.\n - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account.",
                            "default": "OWNER_UNSPECIFIED",
                            "enum": [
                              "OWNER_UNSPECIFIED",
                              "OWNER_MODULE",
                              "OWNER_EXTERNAL"
                            ]
                          }
                        },
                        "description": "TokenPair defines an instance that records a pairing consisting of a native\n Cosmos Coin and an ERC20 token address."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryTokenPairsResponse is the response type for the Query/TokenPairs RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/erc20/v1/token_pairs/{token}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "TokenPair retrieves a registered token pair",
        "operationId": "TokenPair",
        "parameters": [
          {
            "name": "token",
            "in": "path",
            "description": "token identifier can be either the hex contract address of the ERC20 or the\nCosmos base denomination",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "token_pair": {
                      "title": "token_pairs returns the info about a registered token pair for the erc20 module",
                      "type": "object",
                      "properties": {
                        "erc20_address": {
                          "title": "erc20_address is the hex address of ERC20 contract token",
                          "type": "string"
                        },
                        "denom": {
                          "title": "denom defines the cosmos base denomination to be mapped to",
                          "type": "string"
                        },
                        "enabled": {
                          "title": "enabled defines the token mapping enable status",
                          "type": "boolean"
                        },
                        "contract_owner": {
                          "title": "contract_owner is the an ENUM specifying the type of ERC20 owner (0 invalid, 1 ModuleAccount, 2 external address)",
                          "type": "string",
                          "description": "Owner enumerates the ownership of a ERC20 contract.\n\n - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.\n - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.\n - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account.",
                          "default": "OWNER_UNSPECIFIED",
                          "enum": [
                            "OWNER_UNSPECIFIED",
                            "OWNER_MODULE",
                            "OWNER_EXTERNAL"
                          ]
                        }
                      },
                      "description": "TokenPair defines an instance that records a pairing consisting of a native\n Cosmos Coin and an ERC20 token address."
                    }
                  },
                  "description": "QueryTokenPairResponse is the response type for the Query/TokenPair RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/incentives/v1/allocation_meters": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "AllocationMeters retrieves active allocation meters for a given\ndenomination",
        "operationId": "AllocationMeters",
        "parameters": [
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "allocation_meters": {
                      "title": "allocation_meters is a slice of all allocations",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryAllocationMetersResponse is the response type for the\nQuery/AllocationMeters RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/incentives/v1/allocation_meters/{denom}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "AllocationMeter retrieves a active gas meter",
        "operationId": "AllocationMeter",
        "parameters": [
          {
            "name": "denom",
            "in": "path",
            "description": "denom is the coin denom to query an allocation meter for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "allocation_meter": {
                      "title": "allocation_meter defines the allocation of the queried denom",
                      "type": "object",
                      "properties": {
                        "denom": {
                          "type": "string"
                        },
                        "amount": {
                          "type": "string"
                        }
                      },
                      "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                    }
                  },
                  "description": "QueryAllocationMeterResponse is the response type for the\nQuery/AllocationMeter RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/incentives/v1/gas_meters/{contract}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "GasMeters retrieves active gas meters for a given contract",
        "operationId": "GasMeters",
        "parameters": [
          {
            "name": "contract",
            "in": "path",
            "description": "contract is the hex contract address of a incentivized smart contract",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "gas_meters": {
                      "title": "gas_meters is a slice of the gas meters for an incentivized smart contract",
                      "type": "array",
                      "items": {
                        "title": "GasMeter tracks the cumulative gas spent per participant in one epoch",
                        "type": "object",
                        "properties": {
                          "contract": {
                            "title": "contract is the hex address of the incentivized smart contract",
                            "type": "string"
                          },
                          "participant": {
                            "title": "participant address that interacts with the incentive",
                            "type": "string"
                          },
                          "cumulative_gas": {
                            "title": "cumulative_gas spent during the epoch",
                            "type": "string",
                            "format": "uint64"
                          }
                        }
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryGasMetersResponse is the response type for the Query/Incentives RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/incentives/v1/gas_meters/{contract}/{participant}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "GasMeter retrieves a active gas meter",
        "operationId": "GasMeter",
        "parameters": [
          {
            "name": "contract",
            "in": "path",
            "description": "contract is the hex contract address of a contract",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "participant",
            "in": "path",
            "description": "participant is the hex address of a user",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "gas_meter": {
                      "title": "gas_meter is a gas meter for one participant on an incentivized smart contract",
                      "type": "string",
                      "format": "uint64"
                    }
                  },
                  "description": "QueryGasMeterResponse is the response type for the Query/Incentive RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/incentives/v1/incentives": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Incentives retrieves registered incentives",
        "operationId": "Incentives",
        "parameters": [
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "incentives": {
                      "title": "incentives is a slice of all incentives",
                      "type": "array",
                      "items": {
                        "title": "Incentive defines an instance that organizes distribution conditions for a\ngiven smart contract",
                        "type": "object",
                        "properties": {
                          "contract": {
                            "title": "contract address of the smart contract to be incentivized",
                            "type": "string"
                          },
                          "allocations": {
                            "title": "allocations is a slice of denoms and percentages of rewards to be allocated",
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "denom": {
                                  "type": "string"
                                },
                                "amount": {
                                  "type": "string"
                                }
                              },
                              "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                            }
                          },
                          "epochs": {
                            "title": "epochs defines the number of remaining epochs for the incentive",
                            "type": "integer",
                            "format": "int64"
                          },
                          "start_time": {
                            "title": "start_time of the incentive distribution",
                            "type": "string",
                            "format": "date-time"
                          },
                          "total_gas": {
                            "title": "total_gas is the cumulative gas spent by all gas meters of the incentive during the epoch",
                            "type": "string",
                            "format": "uint64"
                          }
                        }
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryIncentivesResponse is the response type for the Query/Incentives RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/incentives/v1/incentives/{contract}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Incentive retrieves a registered incentive",
        "operationId": "Incentive",
        "parameters": [
          {
            "name": "contract",
            "in": "path",
            "description": "contract is the hex contract address of a incentivized smart contract",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "incentive": {
                      "title": "Incentive defines an instance that organizes distribution conditions for a\ngiven smart contract",
                      "type": "object",
                      "properties": {
                        "contract": {
                          "title": "contract address of the smart contract to be incentivized",
                          "type": "string"
                        },
                        "allocations": {
                          "title": "allocations is a slice of denoms and percentages of rewards to be allocated",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string"
                              },
                              "amount": {
                                "type": "string"
                              }
                            },
                            "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                          }
                        },
                        "epochs": {
                          "title": "epochs defines the number of remaining epochs for the incentive",
                          "type": "integer",
                          "format": "int64"
                        },
                        "start_time": {
                          "title": "start_time of the incentive distribution",
                          "type": "string",
                          "format": "date-time"
                        },
                        "total_gas": {
                          "title": "total_gas is the cumulative gas spent by all gas meters of the incentive during the epoch",
                          "type": "string",
                          "format": "uint64"
                        }
                      }
                    }
                  },
                  "description": "QueryIncentiveResponse is the response type for the Query/Incentive RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/incentives/v1/params": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Params retrieves the incentives module params",
        "operationId": "IncentivesParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "params": {
                      "title": "params are the incentives module parameters",
                      "type": "object",
                      "properties": {
                        "enable_incentives": {
                          "title": "enable_incentives is the parameter to enable incentives",
                          "type": "boolean"
                        },
                        "allocation_limit": {
                          "title": "allocation_limit is the maximum percentage an incentive can allocate per denomination",
                          "type": "string"
                        },
                        "incentives_epoch_identifier": {
                          "title": "incentives_epoch_identifier for the epochs module hooks",
                          "type": "string"
                        },
                        "reward_scaler": {
                          "title": "reward_scaler is the scaling factor for capping rewards",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "description": "QueryParamsResponse is the response type for the Query/Params RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/inflation/v1/circulating_supply": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "CirculatingSupply retrieves the total number of tokens that are in\ncirculation (i.e. excluding unvested tokens).",
        "operationId": "CirculatingSupply",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "circulating_supply": {
                      "title": "circulating_supply is the total amount of coins in circulation",
                      "type": "object",
                      "properties": {
                        "denom": {
                          "type": "string"
                        },
                        "amount": {
                          "type": "string"
                        }
                      },
                      "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                    }
                  },
                  "description": "QueryCirculatingSupplyResponse is the response type for the\nQuery/CirculatingSupply RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/inflation/v1/epoch_mint_provision": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "EpochMintProvision retrieves current minting epoch provision value.",
        "operationId": "EpochMintProvision",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "epoch_mint_provision": {
                      "type": "object",
                      "properties": {
                        "denom": {
                          "type": "string"
                        },
                        "amount": {
                          "type": "string"
                        }
                      },
                      "description": "epoch_mint_provision is the current minting per epoch provision value."
                    }
                  },
                  "description": "QueryEpochMintProvisionResponse is the response type for the\nQuery/EpochMintProvision RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/inflation/v1/inflation_rate": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "InflationRate retrieves the inflation rate of the current period.",
        "operationId": "InflationRate",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "inflation_rate": {
                      "title": "inflation_rate by which the total supply increases within one period",
                      "type": "string"
                    }
                  },
                  "description": "QueryInflationRateResponse is the response type for the Query/InflationRate\nRPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/inflation/v1/params": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Params retrieves the total set of minting parameters.",
        "operationId": "InflationParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "params": {
                      "type": "object",
                      "properties": {
                        "mint_denom": {
                          "title": "mint_denom specifies the type of coin to mint",
                          "type": "string"
                        },
                        "exponential_calculation": {
                          "title": "exponential_calculation takes in the variables to calculate exponential inflation",
                          "type": "object",
                          "properties": {
                            "a": {
                              "title": "a defines the initial value",
                              "type": "string"
                            },
                            "r": {
                              "title": "r defines the reduction factor",
                              "type": "string"
                            },
                            "c": {
                              "title": "c defines the parameter for long term inflation",
                              "type": "string"
                            },
                            "bonding_target": {
                              "title": "bonding_target",
                              "type": "string"
                            },
                            "max_variance": {
                              "title": "max_variance",
                              "type": "string"
                            }
                          }
                        },
                        "inflation_distribution": {
                          "title": "inflation_distribution of the minted denom",
                          "type": "object",
                          "properties": {
                            "staking_rewards": {
                              "title": "staking_rewards defines the proportion of the minted minted_denom that is\nto be allocated as staking rewards",
                              "type": "string"
                            },
                            "usage_incentives": {
                              "title": "usage_incentives defines the proportion of the minted minted_denom that is\nto be allocated to the incentives module address",
                              "type": "string"
                            },
                            "community_pool": {
                              "title": "community_pool defines the proportion of the minted minted_denom that is to\nbe allocated to the community pool",
                              "type": "string"
                            }
                          }
                        },
                        "enable_inflation": {
                          "title": "enable_inflation is the parameter that enables inflation and halts increasing the skipped_epochs",
                          "type": "boolean"
                        }
                      },
                      "description": "params defines the parameters of the module."
                    }
                  },
                  "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/inflation/v1/period": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Period retrieves current period.",
        "operationId": "Period",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "period": {
                      "type": "string",
                      "description": "period is the current minting per epoch provision value.",
                      "format": "uint64"
                    }
                  },
                  "description": "QueryPeriodResponse is the response type for the Query/Period RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/inflation/v1/skipped_epochs": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "SkippedEpochs retrieves the total number of skipped epochs.",
        "operationId": "SkippedEpochs",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "skipped_epochs": {
                      "type": "string",
                      "description": "skipped_epochs is the number of epochs that the inflation module has been disabled.",
                      "format": "uint64"
                    }
                  },
                  "description": "QuerySkippedEpochsResponse is the response type for the Query/SkippedEpochs\nRPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/vesting/v1/balances/{address}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Balances retrieves the unvested, vested and locked tokens for a vesting account",
        "operationId": "Balances",
        "parameters": [
          {
            "name": "address",
            "in": "path",
            "description": "address of the clawback vesting account",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "locked": {
                      "title": "locked defines the current amount of locked tokens",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      }
                    },
                    "unvested": {
                      "title": "unvested defines the current amount of unvested tokens",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      }
                    },
                    "vested": {
                      "title": "vested defines the current amount of vested tokens",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      }
                    }
                  },
                  "description": "QueryBalancesResponse is the response type for the Query/Balances RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/recovery/v1/params": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Params retrieves the total set of recovery parameters.",
        "operationId": "RecoveryParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "params": {
                      "title": "Params holds parameters for the recovery module",
                      "type": "object",
                      "properties": {
                        "enable_recovery": {
                          "title": "enable_recovery IBC middleware",
                          "type": "boolean"
                        },
                        "packet_timeout_duration": {
                          "title": "packet_timeout_duration is the duration added to timeout timestamp for balances recovered via IBC packets",
                          "type": "string"
                        }
                      },
                      "description": "params defines the parameters of the module."
                    }
                  },
                  "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/revenue/v1/params": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Params retrieves the revenue module params",
        "operationId": "RevenueParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "params": {
                      "title": "params is the returned revenue parameter",
                      "type": "object",
                      "properties": {
                        "enable_revenue": {
                          "title": "enable_revenue defines a parameter to enable the revenue module",
                          "type": "boolean"
                        },
                        "developer_shares": {
                          "title": "developer_shares defines the proportion of the transaction fees to be\ndistributed to the registered contract owner",
                          "type": "string"
                        },
                        "addr_derivation_cost_create": {
                          "title": "addr_derivation_cost_create defines the cost of address derivation for\nverifying the contract deployer at fee registration",
                          "type": "string",
                          "format": "uint64"
                        }
                      }
                    }
                  },
                  "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/revenue/v1/revenues": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Revenues retrieves all registered revenues",
        "operationId": "Revenues",
        "parameters": [
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "revenues": {
                      "title": "revenues is a slice of all stored Reveneue",
                      "type": "array",
                      "items": {
                        "title": "Revenue defines an instance that organizes fee distribution conditions for\nthe owner of a given smart contract",
                        "type": "object",
                        "properties": {
                          "contract_address": {
                            "title": "contract_address is the hex address of a registered contract",
                            "type": "string"
                          },
                          "deployer_address": {
                            "title": "deployer_address is the bech32 address of message sender. It must be the same as the origin EOA\nsending the transaction which deploys the contract",
                            "type": "string"
                          },
                          "withdrawer_address": {
                            "title": "withdrawer_address is the bech32 address of account receiving the transaction fees it defaults to\ndeployer_address",
                            "type": "string"
                          }
                        }
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryRevenuesResponse is the response type for the Query/Revenues RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/revenue/v1/revenues/{contract_address}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Revenue retrieves a registered revenue for a given contract address",
        "operationId": "Revenue",
        "parameters": [
          {
            "name": "contract_address",
            "in": "path",
            "description": "contract_address of a registered contract in hex format",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "revenue": {
                      "title": "Revenue defines an instance that organizes fee distribution conditions for\nthe owner of a given smart contract",
                      "type": "object",
                      "properties": {
                        "contract_address": {
                          "title": "contract_address is the hex address of a registered contract",
                          "type": "string"
                        },
                        "deployer_address": {
                          "title": "deployer_address is the bech32 address of message sender. It must be the same as the origin EOA\nsending the transaction which deploys the contract",
                          "type": "string"
                        },
                        "withdrawer_address": {
                          "title": "withdrawer_address is the bech32 address of account receiving the transaction fees it defaults to\ndeployer_address",
                          "type": "string"
                        }
                      }
                    }
                  },
                  "description": "QueryRevenueResponse is the response type for the Query/Revenue RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/revenue/v1/revenues/{deployer_address}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "DeployerRevenues retrieves all revenues that a given deployer has\nregistered",
        "operationId": "DeployerRevenues",
        "parameters": [
          {
            "name": "deployer_address",
            "in": "path",
            "description": "deployer_address in bech32 format",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "contract_addresses": {
                      "title": "contract_addresses is the slice of registered contract addresses for a deployer",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryDeployerRevenuesResponse is the response type for the\nQuery/DeployerRevenues RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/revenue/v1/revenues/{withdrawer_address}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "WithdrawerRevenues retrieves all revenues with a given withdrawer\naddress",
        "operationId": "WithdrawerRevenues",
        "parameters": [
          {
            "name": "withdrawer_address",
            "in": "path",
            "description": "withdrawer_address in bech32 format",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "contract_addresses": {
                      "title": "contract_addresses is the slice of registered contract addresses for a withdrawer",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryWithdrawerRevenuesResponse is the response type for the\nQuery/WithdrawerRevenues RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/evm/v1/account/{address}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Account queries an Ethereum account.",
        "operationId": "Account",
        "parameters": [
          {
            "name": "address",
            "in": "path",
            "description": "address is the ethereum hex address to query the account for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "balance": {
                      "type": "string",
                      "description": "balance is the balance of the EVM denomination."
                    },
                    "code_hash": {
                      "type": "string",
                      "description": "code_hash is the hex-formatted code bytes from the EOA."
                    },
                    "nonce": {
                      "type": "string",
                      "description": "nonce is the account's sequence number.",
                      "format": "uint64"
                    }
                  },
                  "description": "QueryAccountResponse is the response type for the Query/Account RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/evm/v1/balances/{address}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Balance queries the balance of a the EVM denomination for a single\nEthAccount.",
        "operationId": "Balance",
        "parameters": [
          {
            "name": "address",
            "in": "path",
            "description": "address is the ethereum hex address to query the balance for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "balance": {
                      "type": "string",
                      "description": "balance is the balance of the EVM denomination."
                    }
                  },
                  "description": "QueryBalanceResponse is the response type for the Query/Balance RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/evm/v1/base_fee": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "BaseFee queries the base fee of the parent block of the current block,\nit's similar to feemarket module's method, but also checks london hardfork status.",
        "operationId": "BaseFee",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "base_fee": {
                      "title": "base_fee is the EIP1559 base fee",
                      "type": "string"
                    }
                  },
                  "description": "QueryBaseFeeResponse returns the EIP1559 base fee."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/evm/v1/codes/{address}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Code queries the balance of all coins for a single account.",
        "operationId": "Code",
        "parameters": [
          {
            "name": "address",
            "in": "path",
            "description": "address is the ethereum hex address to query the code for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "code represents the code bytes from an ethereum address.",
                      "format": "byte"
                    }
                  },
                  "description": "QueryCodeResponse is the response type for the Query/Code RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/evm/v1/cosmos_account/{address}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "CosmosAccount queries an Ethereum account's Cosmos Address.",
        "operationId": "CosmosAccount",
        "parameters": [
          {
            "name": "address",
            "in": "path",
            "description": "address is the ethereum hex address to query the account for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "cosmos_address": {
                      "type": "string",
                      "description": "cosmos_address is the cosmos address of the account."
                    },
                    "sequence": {
                      "type": "string",
                      "description": "sequence is the account's sequence number.",
                      "format": "uint64"
                    },
                    "account_number": {
                      "title": "account_number is the account number",
                      "type": "string",
                      "format": "uint64"
                    }
                  },
                  "description": "QueryCosmosAccountResponse is the response type for the Query/CosmosAccount\nRPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/evm/v1/estimate_gas": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "EstimateGas implements the `eth_estimateGas` rpc api",
        "operationId": "EstimateGas",
        "parameters": [
          {
            "name": "args",
            "in": "query",
            "description": "args uses the same json format as the json rpc api.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "gas_cap",
            "in": "query",
            "description": "gas_cap defines the default gas cap to be used.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "proposer_address",
            "in": "query",
            "description": "proposer_address of the requested block in hex format.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "chain_id",
            "in": "query",
            "description": "chain_id is the eip155 chain id parsed from the requested block header.",
            "schema": {
              "type": "string",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "EstimateGasResponse defines EstimateGas response",
                  "type": "object",
                  "properties": {
                    "gas": {
                      "title": "gas returns the estimated gas",
                      "type": "string",
                      "format": "uint64"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/evm/v1/eth_call": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "EthCall implements the `eth_call` rpc api",
        "operationId": "EthCall",
        "parameters": [
          {
            "name": "args",
            "in": "query",
            "description": "args uses the same json format as the json rpc api.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "gas_cap",
            "in": "query",
            "description": "gas_cap defines the default gas cap to be used.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "proposer_address",
            "in": "query",
            "description": "proposer_address of the requested block in hex format.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "chain_id",
            "in": "query",
            "description": "chain_id is the eip155 chain id parsed from the requested block header.",
            "schema": {
              "type": "string",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "title": "hash of the ethereum transaction in hex format. This hash differs from the\nTendermint sha256 hash of the transaction bytes. See\nhttps://github.com/tendermint/tendermint/issues/6539 for reference",
                      "type": "string"
                    },
                    "logs": {
                      "type": "array",
                      "description": "logs contains the transaction hash and the proto-compatible ethereum\nlogs.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "address": {
                            "title": "address of the contract that generated the event",
                            "type": "string"
                          },
                          "topics": {
                            "type": "array",
                            "description": "topics is a list of topics provided by the contract.",
                            "items": {
                              "type": "string"
                            }
                          },
                          "data": {
                            "title": "data which is supplied by the contract, usually ABI-encoded",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          },
                          "block_number": {
                            "title": "block_number of the block in which the transaction was included",
                            "type": "string",
                            "format": "uint64"
                          },
                          "tx_hash": {
                            "title": "tx_hash is the transaction hash",
                            "type": "string"
                          },
                          "tx_index": {
                            "title": "tx_index of the transaction in the block",
                            "type": "string",
                            "format": "uint64"
                          },
                          "block_hash": {
                            "title": "block_hash of the block in which the transaction was included",
                            "type": "string"
                          },
                          "index": {
                            "title": "index of the log in the block",
                            "type": "string",
                            "format": "uint64"
                          },
                          "removed": {
                            "type": "boolean",
                            "description": "removed is true if this log was reverted due to a chain\nreorganisation. You must pay attention to this field if you receive logs\nthrough a filter query."
                          }
                        },
                        "description": "Log represents an protobuf compatible Ethereum Log that defines a contract\nlog event. These events are generated by the LOG opcode and stored/indexed by\nthe node.\n\nNOTE: address, topics and data are consensus fields. The rest of the fields\nare derived, i.e. filled in by the nodes, but not secured by consensus."
                      }
                    },
                    "ret": {
                      "title": "ret is the returned data from evm function (result or data supplied with revert\nopcode)",
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "vm_error": {
                      "title": "vm_error is the error returned by vm execution",
                      "type": "string"
                    },
                    "gas_used": {
                      "title": "gas_used specifies how much gas was consumed by the transaction",
                      "type": "string",
                      "format": "uint64"
                    }
                  },
                  "description": "MsgEthereumTxResponse defines the Msg/EthereumTx response type."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/evm/v1/params": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Params queries the parameters of x/evm module.",
        "operationId": "EvmParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "params": {
                      "title": "Params defines the EVM module parameters",
                      "type": "object",
                      "properties": {
                        "evm_denom": {
                          "type": "string",
                          "description": "evm_denom represents the token denomination used to run the EVM state\ntransitions."
                        },
                        "enable_create": {
                          "title": "enable_create toggles state transitions that use the vm.Create function",
                          "type": "boolean"
                        },
                        "enable_call": {
                          "title": "enable_call toggles state transitions that use the vm.Call function",
                          "type": "boolean"
                        },
                        "extra_eips": {
                          "title": "extra_eips defines the additional EIPs for the vm.Config",
                          "type": "array",
                          "items": {
                            "type": "string",
                            "format": "int64"
                          }
                        },
                        "chain_config": {
                          "title": "chain_config defines the EVM chain configuration parameters",
                          "type": "object",
                          "properties": {
                            "homestead_block": {
                              "title": "homestead_block switch (nil no fork, 0 = already homestead)",
                              "type": "string"
                            },
                            "dao_fork_block": {
                              "title": "dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork)",
                              "type": "string"
                            },
                            "dao_fork_support": {
                              "title": "dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork",
                              "type": "boolean"
                            },
                            "eip150_block": {
                              "title": "eip150_block: EIP150 implements the Gas price changes\n(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)",
                              "type": "string"
                            },
                            "eip150_hash": {
                              "title": "eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed)",
                              "type": "string"
                            },
                            "eip155_block": {
                              "title": "eip155_block: EIP155Block HF block",
                              "type": "string"
                            },
                            "eip158_block": {
                              "title": "eip158_block: EIP158 HF block",
                              "type": "string"
                            },
                            "byzantium_block": {
                              "title": "byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium)",
                              "type": "string"
                            },
                            "constantinople_block": {
                              "title": "constantinople_block: Constantinople switch block (nil no fork, 0 = already activated)",
                              "type": "string"
                            },
                            "petersburg_block": {
                              "title": "petersburg_block: Petersburg switch block (nil same as Constantinople)",
                              "type": "string"
                            },
                            "istanbul_block": {
                              "title": "istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul)",
                              "type": "string"
                            },
                            "muir_glacier_block": {
                              "title": "muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated)",
                              "type": "string"
                            },
                            "berlin_block": {
                              "title": "berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin)",
                              "type": "string"
                            },
                            "london_block": {
                              "title": "london_block: London switch block (nil = no fork, 0 = already on london)",
                              "type": "string"
                            },
                            "arrow_glacier_block": {
                              "title": "arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated)",
                              "type": "string"
                            },
                            "gray_glacier_block": {
                              "title": "gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated)",
                              "type": "string"
                            },
                            "merge_netsplit_block": {
                              "title": "merge_netsplit_block: Virtual fork after The Merge to use as a network splitter",
                              "type": "string"
                            },
                            "shanghai_block": {
                              "title": "shanghai_block switch block (nil = no fork, 0 = already on shanghai)",
                              "type": "string"
                            },
                            "cancun_block": {
                              "title": "cancun_block switch block (nil = no fork, 0 = already on cancun)",
                              "type": "string"
                            }
                          },
                          "description": "ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values\ninstead of *big.Int."
                        },
                        "allow_unprotected_txs": {
                          "type": "boolean",
                          "description": "allow_unprotected_txs defines if replay-protected (i.e non EIP155\nsigned) transactions can be executed on the state machine."
                        },
                        "active_precompiles": {
                          "title": "active_precompiles defines the slice of hex addresses of the precompiled\ncontracts that are active",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        }
                      },
                      "description": "params define the evm module parameters."
                    }
                  },
                  "description": "QueryParamsResponse defines the response type for querying x/evm parameters."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/evm/v1/storage/{address}/{key}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Storage queries the balance of all coins for a single account.",
        "operationId": "Storage",
        "parameters": [
          {
            "name": "address",
            "in": "path",
            "description": "address is the ethereum hex address to query the storage state for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "key",
            "in": "path",
            "description": "key defines the key of the storage state",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "value": {
                      "type": "string",
                      "description": "value defines the storage state value hash associated with the given key."
                    }
                  },
                  "description": "QueryStorageResponse is the response type for the Query/Storage RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/evm/v1/trace_block": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "TraceBlock implements the `debug_traceBlockByNumber` and `debug_traceBlockByHash` rpc api",
        "operationId": "TraceBlock",
        "parameters": [
          {
            "name": "trace_config.tracer",
            "in": "query",
            "description": "tracer is a custom javascript tracer.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.timeout",
            "in": "query",
            "description": "timeout overrides the default timeout of 5 seconds for JavaScript-based tracing\ncalls.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.reexec",
            "in": "query",
            "description": "reexec defines the number of blocks the tracer is willing to go back.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "trace_config.disable_stack",
            "in": "query",
            "description": "disable_stack switches stack capture.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "trace_config.disable_storage",
            "in": "query",
            "description": "disable_storage switches storage capture.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "trace_config.debug",
            "in": "query",
            "description": "debug can be used to print output during capture end.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "trace_config.limit",
            "in": "query",
            "description": "limit defines the maximum length of output, but zero means unlimited.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "trace_config.overrides.homestead_block",
            "in": "query",
            "description": "homestead_block switch (nil no fork, 0 = already homestead).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.dao_fork_block",
            "in": "query",
            "description": "dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.dao_fork_support",
            "in": "query",
            "description": "dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "trace_config.overrides.eip150_block",
            "in": "query",
            "description": "eip150_block: EIP150 implements the Gas price changes\n(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.eip150_hash",
            "in": "query",
            "description": "eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.eip155_block",
            "in": "query",
            "description": "eip155_block: EIP155Block HF block.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.eip158_block",
            "in": "query",
            "description": "eip158_block: EIP158 HF block.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.byzantium_block",
            "in": "query",
            "description": "byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.constantinople_block",
            "in": "query",
            "description": "constantinople_block: Constantinople switch block (nil no fork, 0 = already activated).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.petersburg_block",
            "in": "query",
            "description": "petersburg_block: Petersburg switch block (nil same as Constantinople).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.istanbul_block",
            "in": "query",
            "description": "istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.muir_glacier_block",
            "in": "query",
            "description": "muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.berlin_block",
            "in": "query",
            "description": "berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.london_block",
            "in": "query",
            "description": "london_block: London switch block (nil = no fork, 0 = already on london).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.arrow_glacier_block",
            "in": "query",
            "description": "arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.gray_glacier_block",
            "in": "query",
            "description": "gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.merge_netsplit_block",
            "in": "query",
            "description": "merge_netsplit_block: Virtual fork after The Merge to use as a network splitter.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.shanghai_block",
            "in": "query",
            "description": "shanghai_block switch block (nil = no fork, 0 = already on shanghai).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.cancun_block",
            "in": "query",
            "description": "cancun_block switch block (nil = no fork, 0 = already on cancun).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.enable_memory",
            "in": "query",
            "description": "enable_memory switches memory capture.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "trace_config.enable_return_data",
            "in": "query",
            "description": "enable_return_data switches the capture of return data.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "trace_config.tracer_json_config",
            "in": "query",
            "description": "tracer_json_config configures the tracer using a JSON string.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "block_number",
            "in": "query",
            "description": "block_number of the traced block.",
            "schema": {
              "type": "string",
              "format": "int64"
            }
          },
          {
            "name": "block_hash",
            "in": "query",
            "description": "block_hash (hex) of the traced block.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "block_time",
            "in": "query",
            "description": "block_time of the traced block.",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "proposer_address",
            "in": "query",
            "description": "proposer_address is the address of the requested block.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "chain_id",
            "in": "query",
            "description": "chain_id is the eip155 chain id parsed from the requested block header.",
            "schema": {
              "type": "string",
              "format": "int64"
            }
          },
          {
            "name": "block_max_gas",
            "in": "query",
            "description": "block_max_gas of the traced block.",
            "schema": {
              "type": "string",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryTraceBlockResponse defines TraceBlock response",
                  "type": "object",
                  "properties": {
                    "data": {
                      "title": "data is the response serialized in bytes",
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/evm/v1/trace_tx": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "TraceTx implements the `debug_traceTransaction` rpc api",
        "operationId": "TraceTx",
        "parameters": [
          {
            "name": "msg.data.type_url",
            "in": "query",
            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "msg.data.value",
            "in": "query",
            "description": "Must be a valid serialized protocol buffer of the above specified type.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "msg.size",
            "in": "query",
            "description": "size is the encoded storage size of the transaction (DEPRECATED).",
            "schema": {
              "type": "number",
              "format": "double"
            }
          },
          {
            "name": "msg.hash",
            "in": "query",
            "description": "hash of the transaction in hex format.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "msg.from",
            "in": "query",
            "description": "from is the ethereum signer address in hex format. This address value is checked\nagainst the address derived from the signature (V, R, S) using the\nsecp256k1 elliptic curve.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.tracer",
            "in": "query",
            "description": "tracer is a custom javascript tracer.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.timeout",
            "in": "query",
            "description": "timeout overrides the default timeout of 5 seconds for JavaScript-based tracing\ncalls.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.reexec",
            "in": "query",
            "description": "reexec defines the number of blocks the tracer is willing to go back.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "trace_config.disable_stack",
            "in": "query",
            "description": "disable_stack switches stack capture.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "trace_config.disable_storage",
            "in": "query",
            "description": "disable_storage switches storage capture.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "trace_config.debug",
            "in": "query",
            "description": "debug can be used to print output during capture end.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "trace_config.limit",
            "in": "query",
            "description": "limit defines the maximum length of output, but zero means unlimited.",
            "schema": {
              "type": "integer",
              "format": "int32"
            }
          },
          {
            "name": "trace_config.overrides.homestead_block",
            "in": "query",
            "description": "homestead_block switch (nil no fork, 0 = already homestead).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.dao_fork_block",
            "in": "query",
            "description": "dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.dao_fork_support",
            "in": "query",
            "description": "dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "trace_config.overrides.eip150_block",
            "in": "query",
            "description": "eip150_block: EIP150 implements the Gas price changes\n(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.eip150_hash",
            "in": "query",
            "description": "eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.eip155_block",
            "in": "query",
            "description": "eip155_block: EIP155Block HF block.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.eip158_block",
            "in": "query",
            "description": "eip158_block: EIP158 HF block.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.byzantium_block",
            "in": "query",
            "description": "byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.constantinople_block",
            "in": "query",
            "description": "constantinople_block: Constantinople switch block (nil no fork, 0 = already activated).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.petersburg_block",
            "in": "query",
            "description": "petersburg_block: Petersburg switch block (nil same as Constantinople).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.istanbul_block",
            "in": "query",
            "description": "istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.muir_glacier_block",
            "in": "query",
            "description": "muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.berlin_block",
            "in": "query",
            "description": "berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.london_block",
            "in": "query",
            "description": "london_block: London switch block (nil = no fork, 0 = already on london).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.arrow_glacier_block",
            "in": "query",
            "description": "arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.gray_glacier_block",
            "in": "query",
            "description": "gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.merge_netsplit_block",
            "in": "query",
            "description": "merge_netsplit_block: Virtual fork after The Merge to use as a network splitter.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.shanghai_block",
            "in": "query",
            "description": "shanghai_block switch block (nil = no fork, 0 = already on shanghai).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.overrides.cancun_block",
            "in": "query",
            "description": "cancun_block switch block (nil = no fork, 0 = already on cancun).",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "trace_config.enable_memory",
            "in": "query",
            "description": "enable_memory switches memory capture.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "trace_config.enable_return_data",
            "in": "query",
            "description": "enable_return_data switches the capture of return data.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "trace_config.tracer_json_config",
            "in": "query",
            "description": "tracer_json_config configures the tracer using a JSON string.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "block_number",
            "in": "query",
            "description": "block_number of requested transaction.",
            "schema": {
              "type": "string",
              "format": "int64"
            }
          },
          {
            "name": "block_hash",
            "in": "query",
            "description": "block_hash of requested transaction.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "block_time",
            "in": "query",
            "description": "block_time of requested transaction.",
            "schema": {
              "type": "string",
              "format": "date-time"
            }
          },
          {
            "name": "proposer_address",
            "in": "query",
            "description": "proposer_address is the proposer of the requested block.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "chain_id",
            "in": "query",
            "description": "chain_id is the the eip155 chain id parsed from the requested block header.",
            "schema": {
              "type": "string",
              "format": "int64"
            }
          },
          {
            "name": "block_max_gas",
            "in": "query",
            "description": "block_max_gas of the block of the requested transaction.",
            "schema": {
              "type": "string",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryTraceTxResponse defines TraceTx response",
                  "type": "object",
                  "properties": {
                    "data": {
                      "title": "data is the response serialized in bytes",
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/evm/v1/validator_account/{cons_address}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ValidatorAccount queries an Ethereum account's from a validator consensus\nAddress.",
        "operationId": "ValidatorAccount",
        "parameters": [
          {
            "name": "cons_address",
            "in": "path",
            "description": "cons_address is the validator cons address to query the account for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "account_address": {
                      "type": "string",
                      "description": "account_address is the cosmos address of the account in bech32 format."
                    },
                    "sequence": {
                      "type": "string",
                      "description": "sequence is the account's sequence number.",
                      "format": "uint64"
                    },
                    "account_number": {
                      "title": "account_number is the account number",
                      "type": "string",
                      "format": "uint64"
                    }
                  },
                  "description": "QueryValidatorAccountResponse is the response type for the\nQuery/ValidatorAccount RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/feemarket/v1/base_fee": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "BaseFee queries the base fee of the parent block of the current block.",
        "operationId": "FeeMarketBaseFee",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "base_fee": {
                      "title": "base_fee is the EIP1559 base fee",
                      "type": "string"
                    }
                  },
                  "description": "QueryBaseFeeResponse returns the EIP1559 base fee."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/feemarket/v1/block_gas": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "BlockGas queries the gas used at a given block height",
        "operationId": "BlockGas",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "gas": {
                      "title": "gas is the returned block gas",
                      "type": "string",
                      "format": "int64"
                    }
                  },
                  "description": "QueryBlockGasResponse returns block gas used for a given height."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/evmos/feemarket/v1/params": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Params queries the parameters of x/feemarket module.",
        "operationId": "FeeMarketParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "params": {
                      "title": "Params defines the EVM module parameters",
                      "type": "object",
                      "properties": {
                        "no_base_fee": {
                          "title": "no_base_fee forces the EIP-1559 base fee to 0 (needed for 0 price calls)",
                          "type": "boolean"
                        },
                        "base_fee_change_denominator": {
                          "type": "integer",
                          "description": "base_fee_change_denominator bounds the amount the base fee can change\nbetween blocks.",
                          "format": "int64"
                        },
                        "elasticity_multiplier": {
                          "type": "integer",
                          "description": "elasticity_multiplier bounds the maximum gas limit an EIP-1559 block may\nhave.",
                          "format": "int64"
                        },
                        "enable_height": {
                          "type": "string",
                          "description": "enable_height defines at which block height the base fee calculation is enabled.",
                          "format": "int64"
                        },
                        "base_fee": {
                          "type": "string",
                          "description": "base_fee for EIP-1559 blocks."
                        },
                        "min_gas_price": {
                          "title": "min_gas_price defines the minimum gas price value for cosmos and eth transactions",
                          "type": "string"
                        },
                        "min_gas_multiplier": {
                          "title": "min_gas_multiplier bounds the minimum gas used to be charged\nto senders based on gas limit",
                          "type": "string"
                        }
                      },
                      "description": "params define the evm module parameters."
                    }
                  },
                  "description": "QueryParamsResponse defines the response type for querying x/evm parameters."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/apps/transfer/v1/channels/{channel_id}/ports/{port_id}/escrow_address": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "EscrowAddress returns the escrow address for a particular port and channel id.",
        "operationId": "EscrowAddress",
        "parameters": [
          {
            "name": "channel_id",
            "in": "path",
            "description": "unique channel identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "port_id",
            "in": "path",
            "description": "unique port identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "escrow_address": {
                      "title": "the escrow account address",
                      "type": "string"
                    }
                  },
                  "description": "QueryEscrowAddressResponse is the response type of the EscrowAddress RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/apps/transfer/v1/denom_hashes/{trace}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "DenomHash queries a denomination hash information.",
        "operationId": "DenomHash",
        "parameters": [
          {
            "name": "trace",
            "in": "path",
            "description": "The denomination trace ([port_id]/[channel_id])+/[denom]",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "hash": {
                      "type": "string",
                      "description": "hash (in hex format) of the denomination trace information."
                    }
                  },
                  "description": "QueryDenomHashResponse is the response type for the Query/DenomHash RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/apps/transfer/v1/denom_traces": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "DenomTraces queries all denomination traces.",
        "operationId": "DenomTraces",
        "parameters": [
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "denom_traces": {
                      "type": "array",
                      "description": "denom_traces returns all denominations trace information.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "path": {
                            "type": "string",
                            "description": "path defines the chain of port/channel identifiers used for tracing the\nsource of the fungible token."
                          },
                          "base_denom": {
                            "type": "string",
                            "description": "base denomination of the relayed fungible token."
                          }
                        },
                        "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the\nsource tracing information path."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryConnectionsResponse is the response type for the Query/DenomTraces RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/apps/transfer/v1/denom_traces/{hash}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "DenomTrace queries a denomination trace information.",
        "operationId": "DenomTrace",
        "parameters": [
          {
            "name": "hash",
            "in": "path",
            "description": "hash (in hex format) or denom (full denom with ibc prefix) of the denomination trace information.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "denom_trace": {
                      "type": "object",
                      "properties": {
                        "path": {
                          "type": "string",
                          "description": "path defines the chain of port/channel identifiers used for tracing the\nsource of the fungible token."
                        },
                        "base_denom": {
                          "type": "string",
                          "description": "base denomination of the relayed fungible token."
                        }
                      },
                      "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the\nsource tracing information path."
                    }
                  },
                  "description": "QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/apps/transfer/v1/denoms/{denom}/total_escrow": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "TotalEscrowForDenom returns the total amount of tokens in escrow based on the denom.",
        "operationId": "TotalEscrowForDenom",
        "parameters": [
          {
            "name": "denom",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "amount": {
                      "type": "object",
                      "properties": {
                        "denom": {
                          "type": "string"
                        },
                        "amount": {
                          "type": "string"
                        }
                      },
                      "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                    }
                  },
                  "description": "QueryTotalEscrowForDenomResponse is the response type for TotalEscrowForDenom RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/apps/transfer/v1/params": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Params queries all parameters of the ibc-transfer module.",
        "operationId": "TransferParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "params": {
                      "type": "object",
                      "properties": {
                        "send_enabled": {
                          "type": "boolean",
                          "description": "send_enabled enables or disables all cross-chain token transfers from this\nchain."
                        },
                        "receive_enabled": {
                          "type": "boolean",
                          "description": "receive_enabled enables or disables all cross-chain token transfers to this\nchain."
                        }
                      },
                      "description": "params defines the parameters of the module."
                    }
                  },
                  "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/client/v1/client_states": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ClientStates queries all the IBC light clients of a chain.",
        "operationId": "ClientStates",
        "parameters": [
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "client_states": {
                      "type": "array",
                      "description": "list of stored ClientStates of the chain.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "client_id": {
                            "title": "client identifier",
                            "type": "string"
                          },
                          "client_state": {
                            "title": "client state",
                            "type": "object",
                            "properties": {
                              "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                              },
                              "value": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "byte"
                              }
                            },
                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                          }
                        },
                        "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
                      }
                    },
                    "pagination": {
                      "title": "pagination response",
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                    }
                  },
                  "description": "QueryClientStatesResponse is the response type for the Query/ClientStates RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/client/v1/client_states/{client_id}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ClientState queries an IBC light client.",
        "operationId": "ClientState",
        "parameters": [
          {
            "name": "client_id",
            "in": "path",
            "description": "client state unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "client_state": {
                      "title": "client state associated with the request identifier",
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Must be a valid serialized protocol buffer of the above specified type.",
                          "format": "byte"
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    },
                    "proof": {
                      "title": "merkle proof of existence",
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "proof_height": {
                      "title": "height at which the proof was retrieved",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  },
                  "description": "QueryClientStateResponse is the response type for the Query/ClientState RPC\nmethod. Besides the client state, it includes a proof and the height from\nwhich the proof was retrieved."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/client/v1/client_status/{client_id}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Status queries the status of an IBC client.",
        "operationId": "ClientStatus",
        "parameters": [
          {
            "name": "client_id",
            "in": "path",
            "description": "client unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "status": {
                      "type": "string"
                    }
                  },
                  "description": "QueryClientStatusResponse is the response type for the Query/ClientStatus RPC\nmethod. It returns the current status of the IBC client."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/client/v1/consensus_states/{client_id}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ConsensusStates queries all the consensus state associated with a given\nclient.",
        "operationId": "ConsensusStates",
        "parameters": [
          {
            "name": "client_id",
            "in": "path",
            "description": "client identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryConsensusStatesResponse is the response type for the\nQuery/ConsensusStates RPC method",
                  "type": "object",
                  "properties": {
                    "consensus_states": {
                      "title": "consensus states associated with the identifier",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "height": {
                            "title": "consensus state height",
                            "type": "object",
                            "properties": {
                              "revision_number": {
                                "title": "the revision that the client is currently on",
                                "type": "string",
                                "format": "uint64"
                              },
                              "revision_height": {
                                "title": "the height within the given revision",
                                "type": "string",
                                "format": "uint64"
                              }
                            },
                            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                          },
                          "consensus_state": {
                            "title": "consensus state",
                            "type": "object",
                            "properties": {
                              "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                              },
                              "value": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "byte"
                              }
                            },
                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                          }
                        },
                        "description": "ConsensusStateWithHeight defines a consensus state with an additional height\nfield."
                      }
                    },
                    "pagination": {
                      "title": "pagination response",
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/client/v1/consensus_states/{client_id}/heights": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ConsensusStateHeights queries the height of every consensus states associated with a given client.",
        "operationId": "ConsensusStateHeights",
        "parameters": [
          {
            "name": "client_id",
            "in": "path",
            "description": "client identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryConsensusStateHeightsResponse is the response type for the\nQuery/ConsensusStateHeights RPC method",
                  "type": "object",
                  "properties": {
                    "consensus_state_heights": {
                      "title": "consensus state heights",
                      "type": "array",
                      "items": {
                        "title": "Height is a monotonically increasing data type\nthat can be compared against another Height for the purposes of updating and\nfreezing clients",
                        "type": "object",
                        "properties": {
                          "revision_number": {
                            "title": "the revision that the client is currently on",
                            "type": "string",
                            "format": "uint64"
                          },
                          "revision_height": {
                            "title": "the height within the given revision",
                            "type": "string",
                            "format": "uint64"
                          }
                        },
                        "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                      }
                    },
                    "pagination": {
                      "title": "pagination response",
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/client/v1/consensus_states/{client_id}/revision/{revision_number}/height/{revision_height}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ConsensusState queries a consensus state associated with a client state at\na given height.",
        "operationId": "ConsensusState",
        "parameters": [
          {
            "name": "client_id",
            "in": "path",
            "description": "client identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "revision_number",
            "in": "path",
            "description": "consensus state revision number",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "revision_height",
            "in": "path",
            "description": "consensus state revision height",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "latest_height",
            "in": "query",
            "description": "latest_height overrrides the height field and queries the latest stored\nConsensusState.",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryConsensusStateResponse is the response type for the Query/ConsensusState\nRPC method",
                  "type": "object",
                  "properties": {
                    "consensus_state": {
                      "title": "consensus state associated with the client identifier at the given height",
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Must be a valid serialized protocol buffer of the above specified type.",
                          "format": "byte"
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    },
                    "proof": {
                      "title": "merkle proof of existence",
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "proof_height": {
                      "title": "Height is a monotonically increasing data type\nthat can be compared against another Height for the purposes of updating and\nfreezing clients",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/client/v1/params": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ClientParams queries all parameters of the ibc client submodule.",
        "operationId": "ClientParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "params": {
                      "type": "object",
                      "properties": {
                        "allowed_clients": {
                          "type": "array",
                          "description": "allowed_clients defines the list of allowed client state types which can be created\nand interacted with. If a client type is removed from the allowed clients list, usage\nof this client will be disabled until it is added again to the list.",
                          "items": {
                            "type": "string"
                          }
                        }
                      },
                      "description": "params defines the parameters of the module."
                    }
                  },
                  "description": "QueryClientParamsResponse is the response type for the Query/ClientParams RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/client/v1/upgraded_client_states": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "UpgradedClientState queries an Upgraded IBC light client.",
        "operationId": "UpgradedClientState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "upgraded_client_state": {
                      "title": "client state associated with the request identifier",
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Must be a valid serialized protocol buffer of the above specified type.",
                          "format": "byte"
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    }
                  },
                  "description": "QueryUpgradedClientStateResponse is the response type for the\nQuery/UpgradedClientState RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/client/v1/upgraded_consensus_states": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "UpgradedConsensusState queries an Upgraded IBC consensus state.",
        "operationId": "UpgradedConsensusState",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "upgraded_consensus_state": {
                      "title": "Consensus state associated with the request identifier",
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Must be a valid serialized protocol buffer of the above specified type.",
                          "format": "byte"
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    }
                  },
                  "description": "QueryUpgradedConsensusStateResponse is the response type for the\nQuery/UpgradedConsensusState RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/connection/v1/client_connections/{client_id}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ClientConnections queries the connection paths associated with a client\nstate.",
        "operationId": "ClientConnections",
        "parameters": [
          {
            "name": "client_id",
            "in": "path",
            "description": "client identifier associated with a connection",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryClientConnectionsResponse is the response type for the\nQuery/ClientConnections RPC method",
                  "type": "object",
                  "properties": {
                    "connection_paths": {
                      "type": "array",
                      "description": "slice of all the connection paths associated with a client.",
                      "items": {
                        "type": "string"
                      }
                    },
                    "proof": {
                      "title": "merkle proof of existence",
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "proof_height": {
                      "title": "height at which the proof was generated",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/connection/v1/connections": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Connections queries all the IBC connections of a chain.",
        "operationId": "Connections",
        "parameters": [
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "connections": {
                      "type": "array",
                      "description": "list of stored connections of the chain.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "id": {
                            "type": "string",
                            "description": "connection identifier."
                          },
                          "client_id": {
                            "type": "string",
                            "description": "client associated with this connection."
                          },
                          "versions": {
                            "title": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection",
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "identifier": {
                                  "title": "unique version identifier",
                                  "type": "string"
                                },
                                "features": {
                                  "title": "list of features compatible with the specified identifier",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              },
                              "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
                            }
                          },
                          "state": {
                            "type": "string",
                            "description": "current state of the connection end.",
                            "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                            "enum": [
                              "STATE_UNINITIALIZED_UNSPECIFIED",
                              "STATE_INIT",
                              "STATE_TRYOPEN",
                              "STATE_OPEN"
                            ]
                          },
                          "counterparty": {
                            "type": "object",
                            "properties": {
                              "client_id": {
                                "type": "string",
                                "description": "identifies the client on the counterparty chain associated with a given\nconnection."
                              },
                              "connection_id": {
                                "type": "string",
                                "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
                              },
                              "prefix": {
                                "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))",
                                "type": "object",
                                "properties": {
                                  "key_prefix": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  }
                                },
                                "description": "commitment merkle prefix of the counterparty chain."
                              }
                            },
                            "description": "counterparty chain associated with this connection."
                          },
                          "delay_period": {
                            "type": "string",
                            "description": "delay period associated with this connection.",
                            "format": "uint64"
                          }
                        },
                        "description": "IdentifiedConnection defines a connection with additional connection\nidentifier field."
                      }
                    },
                    "pagination": {
                      "title": "pagination response",
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                    },
                    "height": {
                      "title": "query block height",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  },
                  "description": "QueryConnectionsResponse is the response type for the Query/Connections RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/connection/v1/connections/{connection_id}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Connection queries an IBC connection end.",
        "operationId": "Connection",
        "parameters": [
          {
            "name": "connection_id",
            "in": "path",
            "description": "connection unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "connection": {
                      "title": "connection associated with the request identifier",
                      "type": "object",
                      "properties": {
                        "client_id": {
                          "type": "string",
                          "description": "client associated with this connection."
                        },
                        "versions": {
                          "type": "array",
                          "description": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection.",
                          "items": {
                            "type": "object",
                            "properties": {
                              "identifier": {
                                "title": "unique version identifier",
                                "type": "string"
                              },
                              "features": {
                                "title": "list of features compatible with the specified identifier",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            },
                            "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
                          }
                        },
                        "state": {
                          "type": "string",
                          "description": "current state of the connection end.",
                          "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                          "enum": [
                            "STATE_UNINITIALIZED_UNSPECIFIED",
                            "STATE_INIT",
                            "STATE_TRYOPEN",
                            "STATE_OPEN"
                          ]
                        },
                        "counterparty": {
                          "type": "object",
                          "properties": {
                            "client_id": {
                              "type": "string",
                              "description": "identifies the client on the counterparty chain associated with a given\nconnection."
                            },
                            "connection_id": {
                              "type": "string",
                              "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
                            },
                            "prefix": {
                              "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))",
                              "type": "object",
                              "properties": {
                                "key_prefix": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "description": "commitment merkle prefix of the counterparty chain."
                            }
                          },
                          "description": "counterparty chain associated with this connection."
                        },
                        "delay_period": {
                          "type": "string",
                          "description": "delay period that must pass before a consensus state can be used for\npacket-verification NOTE: delay period logic is only implemented by some\nclients.",
                          "format": "uint64"
                        }
                      },
                      "description": "ConnectionEnd defines a stateful object on a chain connected to another\nseparate one.\nNOTE: there must only be 2 defined ConnectionEnds to establish\na connection between two chains."
                    },
                    "proof": {
                      "title": "merkle proof of existence",
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "proof_height": {
                      "title": "height at which the proof was retrieved",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  },
                  "description": "QueryConnectionResponse is the response type for the Query/Connection RPC\nmethod. Besides the connection end, it includes a proof and the height from\nwhich the proof was retrieved."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/connection/v1/connections/{connection_id}/client_state": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ConnectionClientState queries the client state associated with the\nconnection.",
        "operationId": "ConnectionClientState",
        "parameters": [
          {
            "name": "connection_id",
            "in": "path",
            "description": "connection identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryConnectionClientStateResponse is the response type for the\nQuery/ConnectionClientState RPC method",
                  "type": "object",
                  "properties": {
                    "identified_client_state": {
                      "title": "client state associated with the channel",
                      "type": "object",
                      "properties": {
                        "client_id": {
                          "title": "client identifier",
                          "type": "string"
                        },
                        "client_state": {
                          "title": "client state",
                          "type": "object",
                          "properties": {
                            "type_url": {
                              "type": "string",
                              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                            },
                            "value": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Must be a valid serialized protocol buffer of the above specified type.",
                              "format": "byte"
                            }
                          },
                          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                        }
                      },
                      "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
                    },
                    "proof": {
                      "title": "merkle proof of existence",
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "proof_height": {
                      "title": "height at which the proof was retrieved",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/connection/v1/connections/{connection_id}/consensus_state/revision/{revision_number}/height/{revision_height}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ConnectionConsensusState queries the consensus state associated with the\nconnection.",
        "operationId": "ConnectionConsensusState",
        "parameters": [
          {
            "name": "connection_id",
            "in": "path",
            "description": "connection identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "revision_number",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "revision_height",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryConnectionConsensusStateResponse is the response type for the\nQuery/ConnectionConsensusState RPC method",
                  "type": "object",
                  "properties": {
                    "consensus_state": {
                      "title": "consensus state associated with the channel",
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Must be a valid serialized protocol buffer of the above specified type.",
                          "format": "byte"
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    },
                    "client_id": {
                      "title": "client ID associated with the consensus state",
                      "type": "string"
                    },
                    "proof": {
                      "title": "merkle proof of existence",
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "proof_height": {
                      "title": "height at which the proof was retrieved",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/connection/v1/params": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ConnectionParams queries all parameters of the ibc connection submodule.",
        "operationId": "ConnectionParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "params": {
                      "type": "object",
                      "properties": {
                        "max_expected_time_per_block": {
                          "type": "string",
                          "description": "maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the\nlargest amount of time that the chain might reasonably take to produce the next block under normal operating\nconditions. A safe choice is 3-5x the expected time per block.",
                          "format": "uint64"
                        }
                      },
                      "description": "params defines the parameters of the module."
                    }
                  },
                  "description": "QueryConnectionParamsResponse is the response type for the Query/ConnectionParams RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/channel/v1/channels": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Channels queries all the IBC channels of a chain.",
        "operationId": "Channels",
        "parameters": [
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "channels": {
                      "type": "array",
                      "description": "list of stored channels of the chain.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "state": {
                            "title": "current state of the channel end",
                            "type": "string",
                            "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets.",
                            "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                            "enum": [
                              "STATE_UNINITIALIZED_UNSPECIFIED",
                              "STATE_INIT",
                              "STATE_TRYOPEN",
                              "STATE_OPEN",
                              "STATE_CLOSED"
                            ]
                          },
                          "ordering": {
                            "title": "whether the channel is ordered or unordered",
                            "type": "string",
                            "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent",
                            "default": "ORDER_NONE_UNSPECIFIED",
                            "enum": [
                              "ORDER_NONE_UNSPECIFIED",
                              "ORDER_UNORDERED",
                              "ORDER_ORDERED"
                            ]
                          },
                          "counterparty": {
                            "title": "counterparty channel end",
                            "type": "object",
                            "properties": {
                              "port_id": {
                                "type": "string",
                                "description": "port on the counterparty chain which owns the other end of the channel."
                              },
                              "channel_id": {
                                "title": "channel end on the counterparty chain",
                                "type": "string"
                              }
                            }
                          },
                          "connection_hops": {
                            "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "version": {
                            "title": "opaque channel version, which is agreed upon during the handshake",
                            "type": "string"
                          },
                          "port_id": {
                            "title": "port identifier",
                            "type": "string"
                          },
                          "channel_id": {
                            "title": "channel identifier",
                            "type": "string"
                          }
                        },
                        "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
                      }
                    },
                    "pagination": {
                      "title": "pagination response",
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                    },
                    "height": {
                      "title": "query block height",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  },
                  "description": "QueryChannelsResponse is the response type for the Query/Channels RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Channel queries an IBC Channel.",
        "operationId": "Channel",
        "parameters": [
          {
            "name": "channel_id",
            "in": "path",
            "description": "channel unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "port_id",
            "in": "path",
            "description": "port unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "channel": {
                      "title": "channel associated with the request identifiers",
                      "type": "object",
                      "properties": {
                        "state": {
                          "title": "current state of the channel end",
                          "type": "string",
                          "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets.",
                          "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                          "enum": [
                            "STATE_UNINITIALIZED_UNSPECIFIED",
                            "STATE_INIT",
                            "STATE_TRYOPEN",
                            "STATE_OPEN",
                            "STATE_CLOSED"
                          ]
                        },
                        "ordering": {
                          "title": "whether the channel is ordered or unordered",
                          "type": "string",
                          "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent",
                          "default": "ORDER_NONE_UNSPECIFIED",
                          "enum": [
                            "ORDER_NONE_UNSPECIFIED",
                            "ORDER_UNORDERED",
                            "ORDER_ORDERED"
                          ]
                        },
                        "counterparty": {
                          "title": "counterparty channel end",
                          "type": "object",
                          "properties": {
                            "port_id": {
                              "type": "string",
                              "description": "port on the counterparty chain which owns the other end of the channel."
                            },
                            "channel_id": {
                              "title": "channel end on the counterparty chain",
                              "type": "string"
                            }
                          }
                        },
                        "connection_hops": {
                          "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel",
                          "type": "array",
                          "items": {
                            "type": "string"
                          }
                        },
                        "version": {
                          "title": "opaque channel version, which is agreed upon during the handshake",
                          "type": "string"
                        }
                      },
                      "description": "Channel defines pipeline for exactly-once packet delivery between specific\nmodules on separate blockchains, which has at least one end capable of\nsending packets and one end capable of receiving packets."
                    },
                    "proof": {
                      "title": "merkle proof of existence",
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "proof_height": {
                      "title": "height at which the proof was retrieved",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  },
                  "description": "QueryChannelResponse is the response type for the Query/Channel RPC method.\nBesides the Channel end, it includes a proof and the height from which the\nproof was retrieved."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/client_state": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ChannelClientState queries for the client state for the channel associated\nwith the provided channel identifiers.",
        "operationId": "ChannelClientState",
        "parameters": [
          {
            "name": "channel_id",
            "in": "path",
            "description": "channel unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "port_id",
            "in": "path",
            "description": "port unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method",
                  "type": "object",
                  "properties": {
                    "identified_client_state": {
                      "title": "client state associated with the channel",
                      "type": "object",
                      "properties": {
                        "client_id": {
                          "title": "client identifier",
                          "type": "string"
                        },
                        "client_state": {
                          "title": "client state",
                          "type": "object",
                          "properties": {
                            "type_url": {
                              "type": "string",
                              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                            },
                            "value": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Must be a valid serialized protocol buffer of the above specified type.",
                              "format": "byte"
                            }
                          },
                          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                        }
                      },
                      "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
                    },
                    "proof": {
                      "title": "merkle proof of existence",
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "proof_height": {
                      "title": "height at which the proof was retrieved",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/consensus_state/revision/{revision_number}/height/{revision_height}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ChannelConsensusState queries for the consensus state for the channel\nassociated with the provided channel identifiers.",
        "operationId": "ChannelConsensusState",
        "parameters": [
          {
            "name": "channel_id",
            "in": "path",
            "description": "channel unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "port_id",
            "in": "path",
            "description": "port unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "revision_number",
            "in": "path",
            "description": "revision number of the consensus state",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "revision_height",
            "in": "path",
            "description": "revision height of the consensus state",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method",
                  "type": "object",
                  "properties": {
                    "consensus_state": {
                      "title": "consensus state associated with the channel",
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Must be a valid serialized protocol buffer of the above specified type.",
                          "format": "byte"
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    },
                    "client_id": {
                      "title": "client ID associated with the consensus state",
                      "type": "string"
                    },
                    "proof": {
                      "title": "merkle proof of existence",
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "proof_height": {
                      "title": "height at which the proof was retrieved",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "NextSequenceReceive returns the next receive sequence for a given channel.",
        "operationId": "NextSequenceReceive",
        "parameters": [
          {
            "name": "channel_id",
            "in": "path",
            "description": "channel unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "port_id",
            "in": "path",
            "description": "port unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QuerySequenceResponse is the request type for the\nQuery/QueryNextSequenceReceiveResponse RPC method",
                  "type": "object",
                  "properties": {
                    "next_sequence_receive": {
                      "title": "next sequence receive number",
                      "type": "string",
                      "format": "uint64"
                    },
                    "proof": {
                      "title": "merkle proof of existence",
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "proof_height": {
                      "title": "height at which the proof was retrieved",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/next_sequence_send": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "NextSequenceSend returns the next send sequence for a given channel.",
        "operationId": "NextSequenceSend",
        "parameters": [
          {
            "name": "channel_id",
            "in": "path",
            "description": "channel unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "port_id",
            "in": "path",
            "description": "port unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryNextSequenceSendResponse is the request type for the\nQuery/QueryNextSequenceSend RPC method",
                  "type": "object",
                  "properties": {
                    "next_sequence_send": {
                      "title": "next sequence send number",
                      "type": "string",
                      "format": "uint64"
                    },
                    "proof": {
                      "title": "merkle proof of existence",
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "proof_height": {
                      "title": "height at which the proof was retrieved",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acknowledgements": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "PacketAcknowledgements returns all the packet acknowledgements associated\nwith a channel.",
        "operationId": "PacketAcknowledgements",
        "parameters": [
          {
            "name": "channel_id",
            "in": "path",
            "description": "channel unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "port_id",
            "in": "path",
            "description": "port unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "packet_commitment_sequences",
            "in": "query",
            "description": "list of packet sequences.",
            "style": "form",
            "explode": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string",
                "format": "uint64"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryPacketAcknowledgemetsResponse is the request type for the\nQuery/QueryPacketAcknowledgements RPC method",
                  "type": "object",
                  "properties": {
                    "acknowledgements": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "port_id": {
                            "type": "string",
                            "description": "channel port identifier."
                          },
                          "channel_id": {
                            "type": "string",
                            "description": "channel unique identifier."
                          },
                          "sequence": {
                            "type": "string",
                            "description": "packet sequence.",
                            "format": "uint64"
                          },
                          "data": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "embedded data that represents packet state.",
                            "format": "byte"
                          }
                        },
                        "description": "PacketState defines the generic type necessary to retrieve and store\npacket commitments, acknowledgements, and receipts.\nCaller is responsible for knowing the context necessary to interpret this\nstate as a commitment, acknowledgement, or a receipt."
                      }
                    },
                    "pagination": {
                      "title": "pagination response",
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                    },
                    "height": {
                      "title": "query block height",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_acks/{sequence}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "PacketAcknowledgement queries a stored packet acknowledgement hash.",
        "operationId": "PacketAcknowledgement",
        "parameters": [
          {
            "name": "channel_id",
            "in": "path",
            "description": "channel unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "port_id",
            "in": "path",
            "description": "port unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sequence",
            "in": "path",
            "description": "packet sequence",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryPacketAcknowledgementResponse defines the client query response for a\npacket which also includes a proof and the height from which the\nproof was retrieved",
                  "type": "object",
                  "properties": {
                    "acknowledgement": {
                      "title": "packet associated with the request fields",
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "proof": {
                      "title": "merkle proof of existence",
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "proof_height": {
                      "title": "height at which the proof was retrieved",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "PacketCommitments returns all the packet commitments hashes associated\nwith a channel.",
        "operationId": "PacketCommitments",
        "parameters": [
          {
            "name": "channel_id",
            "in": "path",
            "description": "channel unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "port_id",
            "in": "path",
            "description": "port unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryPacketCommitmentsResponse is the request type for the\nQuery/QueryPacketCommitments RPC method",
                  "type": "object",
                  "properties": {
                    "commitments": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "port_id": {
                            "type": "string",
                            "description": "channel port identifier."
                          },
                          "channel_id": {
                            "type": "string",
                            "description": "channel unique identifier."
                          },
                          "sequence": {
                            "type": "string",
                            "description": "packet sequence.",
                            "format": "uint64"
                          },
                          "data": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "embedded data that represents packet state.",
                            "format": "byte"
                          }
                        },
                        "description": "PacketState defines the generic type necessary to retrieve and store\npacket commitments, acknowledgements, and receipts.\nCaller is responsible for knowing the context necessary to interpret this\nstate as a commitment, acknowledgement, or a receipt."
                      }
                    },
                    "pagination": {
                      "title": "pagination response",
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                    },
                    "height": {
                      "title": "query block height",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_ack_sequences}/unreceived_acks": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "UnreceivedAcks returns all the unreceived IBC acknowledgements associated\nwith a channel and sequences.",
        "operationId": "UnreceivedAcks",
        "parameters": [
          {
            "name": "channel_id",
            "in": "path",
            "description": "channel unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "port_id",
            "in": "path",
            "description": "port unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "packet_ack_sequences",
            "in": "path",
            "description": "list of acknowledgement sequences",
            "required": true,
            "style": "simple",
            "explode": false,
            "schema": {
              "minItems": 1,
              "type": "array",
              "items": {
                "type": "string",
                "format": "uint64"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryUnreceivedAcksResponse is the response type for the\nQuery/UnreceivedAcks RPC method",
                  "type": "object",
                  "properties": {
                    "sequences": {
                      "title": "list of unreceived acknowledgement sequences",
                      "type": "array",
                      "items": {
                        "type": "string",
                        "format": "uint64"
                      }
                    },
                    "height": {
                      "title": "query block height",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{packet_commitment_sequences}/unreceived_packets": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "UnreceivedPackets returns all the unreceived IBC packets associated with a\nchannel and sequences.",
        "operationId": "UnreceivedPackets",
        "parameters": [
          {
            "name": "channel_id",
            "in": "path",
            "description": "channel unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "port_id",
            "in": "path",
            "description": "port unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "packet_commitment_sequences",
            "in": "path",
            "description": "list of packet sequences",
            "required": true,
            "style": "simple",
            "explode": false,
            "schema": {
              "minItems": 1,
              "type": "array",
              "items": {
                "type": "string",
                "format": "uint64"
              }
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryUnreceivedPacketsResponse is the response type for the\nQuery/UnreceivedPacketCommitments RPC method",
                  "type": "object",
                  "properties": {
                    "sequences": {
                      "title": "list of unreceived packet sequences",
                      "type": "array",
                      "items": {
                        "type": "string",
                        "format": "uint64"
                      }
                    },
                    "height": {
                      "title": "query block height",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_commitments/{sequence}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "PacketCommitment queries a stored packet commitment hash.",
        "operationId": "PacketCommitment",
        "parameters": [
          {
            "name": "channel_id",
            "in": "path",
            "description": "channel unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "port_id",
            "in": "path",
            "description": "port unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sequence",
            "in": "path",
            "description": "packet sequence",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryPacketCommitmentResponse defines the client query response for a packet\nwhich also includes a proof and the height from which the proof was\nretrieved",
                  "type": "object",
                  "properties": {
                    "commitment": {
                      "title": "packet associated with the request fields",
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "proof": {
                      "title": "merkle proof of existence",
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "proof_height": {
                      "title": "height at which the proof was retrieved",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/channel/v1/channels/{channel_id}/ports/{port_id}/packet_receipts/{sequence}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "PacketReceipt queries if a given packet sequence has been received on the\nqueried chain",
        "operationId": "PacketReceipt",
        "parameters": [
          {
            "name": "channel_id",
            "in": "path",
            "description": "channel unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "port_id",
            "in": "path",
            "description": "port unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "sequence",
            "in": "path",
            "description": "packet sequence",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryPacketReceiptResponse defines the client query response for a packet\nreceipt which also includes a proof, and the height from which the proof was\nretrieved",
                  "type": "object",
                  "properties": {
                    "received": {
                      "title": "success flag for if receipt exists",
                      "type": "boolean"
                    },
                    "proof": {
                      "title": "merkle proof of existence",
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "proof_height": {
                      "title": "height at which the proof was retrieved",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/ibc/core/channel/v1/connections/{connection}/channels": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ConnectionChannels queries all the channels associated with a connection\nend.",
        "operationId": "ConnectionChannels",
        "parameters": [
          {
            "name": "connection",
            "in": "path",
            "description": "connection unique identifier",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryConnectionChannelsResponse is the Response type for the\nQuery/QueryConnectionChannels RPC method",
                  "type": "object",
                  "properties": {
                    "channels": {
                      "type": "array",
                      "description": "list of channels associated with a connection.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "state": {
                            "title": "current state of the channel end",
                            "type": "string",
                            "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets.",
                            "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                            "enum": [
                              "STATE_UNINITIALIZED_UNSPECIFIED",
                              "STATE_INIT",
                              "STATE_TRYOPEN",
                              "STATE_OPEN",
                              "STATE_CLOSED"
                            ]
                          },
                          "ordering": {
                            "title": "whether the channel is ordered or unordered",
                            "type": "string",
                            "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent",
                            "default": "ORDER_NONE_UNSPECIFIED",
                            "enum": [
                              "ORDER_NONE_UNSPECIFIED",
                              "ORDER_UNORDERED",
                              "ORDER_ORDERED"
                            ]
                          },
                          "counterparty": {
                            "title": "counterparty channel end",
                            "type": "object",
                            "properties": {
                              "port_id": {
                                "type": "string",
                                "description": "port on the counterparty chain which owns the other end of the channel."
                              },
                              "channel_id": {
                                "title": "channel end on the counterparty chain",
                                "type": "string"
                              }
                            }
                          },
                          "connection_hops": {
                            "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel",
                            "type": "array",
                            "items": {
                              "type": "string"
                            }
                          },
                          "version": {
                            "title": "opaque channel version, which is agreed upon during the handshake",
                            "type": "string"
                          },
                          "port_id": {
                            "title": "port identifier",
                            "type": "string"
                          },
                          "channel_id": {
                            "title": "channel identifier",
                            "type": "string"
                          }
                        },
                        "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
                      }
                    },
                    "pagination": {
                      "title": "pagination response",
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                    },
                    "height": {
                      "title": "query block height",
                      "type": "object",
                      "properties": {
                        "revision_number": {
                          "title": "the revision that the client is currently on",
                          "type": "string",
                          "format": "uint64"
                        },
                        "revision_height": {
                          "title": "the height within the given revision",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/auth/v1beta1/account_info/{address}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "AccountInfo queries account info which is common to all account types.",
        "description": "Since: cosmos-sdk 0.47",
        "operationId": "AccountInfo",
        "parameters": [
          {
            "name": "address",
            "in": "path",
            "description": "address is the account address string.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "info": {
                      "type": "object",
                      "properties": {
                        "address": {
                          "type": "string"
                        },
                        "pub_key": {
                          "type": "object",
                          "properties": {
                            "type_url": {
                              "type": "string",
                              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                            },
                            "value": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Must be a valid serialized protocol buffer of the above specified type.",
                              "format": "byte"
                            }
                          },
                          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                        },
                        "account_number": {
                          "type": "string",
                          "format": "uint64"
                        },
                        "sequence": {
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "info is the account info which is represented by BaseAccount."
                    }
                  },
                  "description": "QueryAccountInfoResponse is the Query/AccountInfo response type.\n\nSince: cosmos-sdk 0.47"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/auth/v1beta1/accounts": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Accounts returns all the existing accounts.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.\n\nSince: cosmos-sdk 0.43",
        "operationId": "Accounts",
        "parameters": [
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "accounts": {
                      "title": "accounts are the existing accounts",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryAccountsResponse is the response type for the Query/Accounts RPC method.\n\nSince: cosmos-sdk 0.43"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/auth/v1beta1/accounts/{address}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Account returns account details based on address.",
        "operationId": "AuthAccount",
        "parameters": [
          {
            "name": "address",
            "in": "path",
            "description": "address defines the address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "account": {
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Must be a valid serialized protocol buffer of the above specified type.",
                          "format": "byte"
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    }
                  },
                  "description": "QueryAccountResponse is the response type for the Query/Account RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/auth/v1beta1/address_by_id/{id}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "AccountAddressByID returns account address based on account number.",
        "description": "Since: cosmos-sdk 0.46.2",
        "operationId": "AccountAddressByID",
        "parameters": [
          {
            "name": "id",
            "in": "path",
            "description": "Deprecated, use account_id instead\n\nid is the account number of the address to be queried. This field\nshould have been an uint64 (like all account numbers), and will be\nupdated to uint64 in a future version of the auth query.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "int64"
            }
          },
          {
            "name": "account_id",
            "in": "query",
            "description": "account_id is the account number of the address to be queried.\n\nSince: cosmos-sdk 0.47",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryAccountAddressByIDResponse is the response type for AccountAddressByID rpc method",
                  "type": "object",
                  "properties": {
                    "account_address": {
                      "type": "string"
                    }
                  },
                  "description": "Since: cosmos-sdk 0.46.2"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/auth/v1beta1/bech32": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Bech32Prefix queries bech32Prefix",
        "description": "Since: cosmos-sdk 0.46",
        "operationId": "Bech32Prefix",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "bech32_prefix": {
                      "type": "string"
                    }
                  },
                  "description": "Bech32PrefixResponse is the response type for Bech32Prefix rpc method.\n\nSince: cosmos-sdk 0.46"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/auth/v1beta1/bech32/{address_bytes}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "AddressBytesToString converts Account Address bytes to string",
        "description": "Since: cosmos-sdk 0.46",
        "operationId": "AddressBytesToString",
        "parameters": [
          {
            "name": "address_bytes",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "byte"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address_string": {
                      "type": "string"
                    }
                  },
                  "description": "AddressBytesToStringResponse is the response type for AddressString rpc method.\n\nSince: cosmos-sdk 0.46"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/auth/v1beta1/bech32/{address_string}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "AddressStringToBytes converts Address string to bytes",
        "description": "Since: cosmos-sdk 0.46",
        "operationId": "AddressStringToBytes",
        "parameters": [
          {
            "name": "address_string",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "address_bytes": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "description": "AddressStringToBytesResponse is the response type for AddressBytes rpc method.\n\nSince: cosmos-sdk 0.46"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/auth/v1beta1/module_accounts": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ModuleAccounts returns all the existing module accounts.",
        "description": "Since: cosmos-sdk 0.46",
        "operationId": "ModuleAccounts",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "accounts": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  },
                  "description": "QueryModuleAccountsResponse is the response type for the Query/ModuleAccounts RPC method.\n\nSince: cosmos-sdk 0.46"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/auth/v1beta1/module_accounts/{name}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ModuleAccountByName returns the module account info by module name",
        "operationId": "ModuleAccountByName",
        "parameters": [
          {
            "name": "name",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "account": {
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Must be a valid serialized protocol buffer of the above specified type.",
                          "format": "byte"
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    }
                  },
                  "description": "QueryModuleAccountByNameResponse is the response type for the Query/ModuleAccountByName RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/auth/v1beta1/params": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Params queries all parameters.",
        "operationId": "AuthParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "params": {
                      "type": "object",
                      "properties": {
                        "max_memo_characters": {
                          "type": "string",
                          "format": "uint64"
                        },
                        "tx_sig_limit": {
                          "type": "string",
                          "format": "uint64"
                        },
                        "tx_size_cost_per_byte": {
                          "type": "string",
                          "format": "uint64"
                        },
                        "sig_verify_cost_ed25519": {
                          "type": "string",
                          "format": "uint64"
                        },
                        "sig_verify_cost_secp256k1": {
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "params defines the parameters of the module."
                    }
                  },
                  "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/authz/v1beta1/grants": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Returns list of `Authorization`, granted to the grantee by the granter.",
        "operationId": "Grants",
        "parameters": [
          {
            "name": "granter",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "grantee",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "msg_type_url",
            "in": "query",
            "description": "Optional, msg_type_url, when set, will query only grants matching given msg type.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "grants": {
                      "type": "array",
                      "description": "authorizations is a list of grants granted for grantee by granter.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "authorization": {
                            "type": "object",
                            "properties": {
                              "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                              },
                              "value": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "byte"
                              }
                            },
                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                          },
                          "expiration": {
                            "title": "time when the grant will expire and will be pruned. If null, then the grant\ndoesn't have a time expiration (other conditions  in `authorization`\nmay apply to invalidate the grant)",
                            "type": "string",
                            "format": "date-time"
                          }
                        },
                        "description": "Grant gives permissions to execute\nthe provide method with expiration time."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines an pagination for the response."
                    }
                  },
                  "description": "QueryGrantsResponse is the response type for the Query/Authorizations RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/authz/v1beta1/grants/grantee/{grantee}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "GranteeGrants returns a list of `GrantAuthorization` by grantee.",
        "description": "Since: cosmos-sdk 0.46",
        "operationId": "GranteeGrants",
        "parameters": [
          {
            "name": "grantee",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "grants": {
                      "type": "array",
                      "description": "grants is a list of grants granted to the grantee.",
                      "items": {
                        "title": "GrantAuthorization extends a grant with both the addresses of the grantee and granter.\nIt is used in genesis.proto and query.proto",
                        "type": "object",
                        "properties": {
                          "granter": {
                            "type": "string"
                          },
                          "grantee": {
                            "type": "string"
                          },
                          "authorization": {
                            "type": "object",
                            "properties": {
                              "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                              },
                              "value": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "byte"
                              }
                            },
                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                          },
                          "expiration": {
                            "type": "string",
                            "format": "date-time"
                          }
                        }
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines an pagination for the response."
                    }
                  },
                  "description": "QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/authz/v1beta1/grants/granter/{granter}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "GranterGrants returns list of `GrantAuthorization`, granted by granter.",
        "description": "Since: cosmos-sdk 0.46",
        "operationId": "GranterGrants",
        "parameters": [
          {
            "name": "granter",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "grants": {
                      "type": "array",
                      "description": "grants is a list of grants granted by the granter.",
                      "items": {
                        "title": "GrantAuthorization extends a grant with both the addresses of the grantee and granter.\nIt is used in genesis.proto and query.proto",
                        "type": "object",
                        "properties": {
                          "granter": {
                            "type": "string"
                          },
                          "grantee": {
                            "type": "string"
                          },
                          "authorization": {
                            "type": "object",
                            "properties": {
                              "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                              },
                              "value": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "byte"
                              }
                            },
                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                          },
                          "expiration": {
                            "type": "string",
                            "format": "date-time"
                          }
                        }
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines an pagination for the response."
                    }
                  },
                  "description": "QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/bank/v1beta1/balances/{address}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "AllBalances queries the balance of all coins for a single account.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "AllBalances",
        "parameters": [
          {
            "name": "address",
            "in": "path",
            "description": "address is the address to query balances for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "resolve_denom",
            "in": "query",
            "description": "resolve_denom is the flag to resolve the denom into a human-readable form from the metadata.\n\nSince: cosmos-sdk 0.50",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "balances": {
                      "type": "array",
                      "description": "balances is the balances of all the coins.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryAllBalancesResponse is the response type for the Query/AllBalances RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/bank/v1beta1/balances/{address}/by_denom": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Balance queries the balance of a single coin for a single account.",
        "operationId": "BankBalance",
        "parameters": [
          {
            "name": "address",
            "in": "path",
            "description": "address is the address to query balances for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "denom",
            "in": "query",
            "description": "denom is the coin denom to query balances for.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "balance": {
                      "type": "object",
                      "properties": {
                        "denom": {
                          "type": "string"
                        },
                        "amount": {
                          "type": "string"
                        }
                      },
                      "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                    }
                  },
                  "description": "QueryBalanceResponse is the response type for the Query/Balance RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/bank/v1beta1/denom_owners/{denom}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "DenomOwners queries for all account addresses that own a particular token\ndenomination.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.\n\nSince: cosmos-sdk 0.46",
        "operationId": "DenomOwners",
        "parameters": [
          {
            "name": "denom",
            "in": "path",
            "description": "denom defines the coin denomination to query all account holders for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "denom_owners": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "address": {
                            "type": "string",
                            "description": "address defines the address that owns a particular denomination."
                          },
                          "balance": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string"
                              },
                              "amount": {
                                "type": "string"
                              }
                            },
                            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                          }
                        },
                        "description": "DenomOwner defines structure representing an account that owns or holds a\nparticular denominated token. It contains the account address and account\nbalance of the denominated token.\n\nSince: cosmos-sdk 0.46"
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryDenomOwnersResponse defines the RPC response of a DenomOwners RPC query.\n\nSince: cosmos-sdk 0.46"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/bank/v1beta1/denoms_metadata": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "DenomsMetadata queries the client metadata for all registered coin\ndenominations.",
        "operationId": "DenomsMetadata",
        "parameters": [
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "metadatas": {
                      "type": "array",
                      "description": "metadata provides the client information for all the registered tokens.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "description": {
                            "type": "string"
                          },
                          "denom_units": {
                            "title": "denom_units represents the list of DenomUnit's for a given coin",
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "denom": {
                                  "type": "string",
                                  "description": "denom represents the string name of the given denom unit (e.g uatom)."
                                },
                                "exponent": {
                                  "type": "integer",
                                  "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 10^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom).",
                                  "format": "int64"
                                },
                                "aliases": {
                                  "title": "aliases is a list of string aliases for the given denom",
                                  "type": "array",
                                  "items": {
                                    "type": "string"
                                  }
                                }
                              },
                              "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
                            }
                          },
                          "base": {
                            "type": "string",
                            "description": "base represents the base denom (should be the DenomUnit with exponent = 0)."
                          },
                          "display": {
                            "type": "string",
                            "description": "display indicates the suggested denom that should be\ndisplayed in clients."
                          },
                          "name": {
                            "title": "name defines the name of the token (eg: Cosmos Atom)",
                            "type": "string",
                            "description": "Since: cosmos-sdk 0.43"
                          },
                          "symbol": {
                            "type": "string",
                            "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.\n\nSince: cosmos-sdk 0.43"
                          },
                          "uri": {
                            "type": "string",
                            "description": "URI to a document (on or off-chain) that contains additional information. Optional.\n\nSince: cosmos-sdk 0.46"
                          },
                          "uri_hash": {
                            "type": "string",
                            "description": "URIHash is a sha256 hash of a document pointed by URI. It's used to verify that\nthe document didn't change. Optional.\n\nSince: cosmos-sdk 0.46"
                          }
                        },
                        "description": "Metadata represents a struct that describes\na basic token."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/bank/v1beta1/denoms_metadata/{denom}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "DenomsMetadata queries the client metadata of a given coin denomination.",
        "operationId": "DenomMetadata",
        "parameters": [
          {
            "name": "denom",
            "in": "path",
            "description": "denom is the coin denom to query the metadata for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "metadata": {
                      "type": "object",
                      "properties": {
                        "description": {
                          "type": "string"
                        },
                        "denom_units": {
                          "title": "denom_units represents the list of DenomUnit's for a given coin",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string",
                                "description": "denom represents the string name of the given denom unit (e.g uatom)."
                              },
                              "exponent": {
                                "type": "integer",
                                "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 10^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom).",
                                "format": "int64"
                              },
                              "aliases": {
                                "title": "aliases is a list of string aliases for the given denom",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            },
                            "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
                          }
                        },
                        "base": {
                          "type": "string",
                          "description": "base represents the base denom (should be the DenomUnit with exponent = 0)."
                        },
                        "display": {
                          "type": "string",
                          "description": "display indicates the suggested denom that should be\ndisplayed in clients."
                        },
                        "name": {
                          "title": "name defines the name of the token (eg: Cosmos Atom)",
                          "type": "string",
                          "description": "Since: cosmos-sdk 0.43"
                        },
                        "symbol": {
                          "type": "string",
                          "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.\n\nSince: cosmos-sdk 0.43"
                        },
                        "uri": {
                          "type": "string",
                          "description": "URI to a document (on or off-chain) that contains additional information. Optional.\n\nSince: cosmos-sdk 0.46"
                        },
                        "uri_hash": {
                          "type": "string",
                          "description": "URIHash is a sha256 hash of a document pointed by URI. It's used to verify that\nthe document didn't change. Optional.\n\nSince: cosmos-sdk 0.46"
                        }
                      },
                      "description": "Metadata represents a struct that describes\na basic token."
                    }
                  },
                  "description": "QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/bank/v1beta1/denoms_metadata_by_query_string": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "DenomsMetadata queries the client metadata of a given coin denomination.",
        "operationId": "DenomMetadataByQueryString",
        "parameters": [
          {
            "name": "denom",
            "in": "query",
            "description": "denom is the coin denom to query the metadata for.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "metadata": {
                      "type": "object",
                      "properties": {
                        "description": {
                          "type": "string"
                        },
                        "denom_units": {
                          "title": "denom_units represents the list of DenomUnit's for a given coin",
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string",
                                "description": "denom represents the string name of the given denom unit (e.g uatom)."
                              },
                              "exponent": {
                                "type": "integer",
                                "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 10^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom).",
                                "format": "int64"
                              },
                              "aliases": {
                                "title": "aliases is a list of string aliases for the given denom",
                                "type": "array",
                                "items": {
                                  "type": "string"
                                }
                              }
                            },
                            "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
                          }
                        },
                        "base": {
                          "type": "string",
                          "description": "base represents the base denom (should be the DenomUnit with exponent = 0)."
                        },
                        "display": {
                          "type": "string",
                          "description": "display indicates the suggested denom that should be\ndisplayed in clients."
                        },
                        "name": {
                          "title": "name defines the name of the token (eg: Cosmos Atom)",
                          "type": "string",
                          "description": "Since: cosmos-sdk 0.43"
                        },
                        "symbol": {
                          "type": "string",
                          "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.\n\nSince: cosmos-sdk 0.43"
                        },
                        "uri": {
                          "type": "string",
                          "description": "URI to a document (on or off-chain) that contains additional information. Optional.\n\nSince: cosmos-sdk 0.46"
                        },
                        "uri_hash": {
                          "type": "string",
                          "description": "URIHash is a sha256 hash of a document pointed by URI. It's used to verify that\nthe document didn't change. Optional.\n\nSince: cosmos-sdk 0.46"
                        }
                      },
                      "description": "Metadata represents a struct that describes\na basic token."
                    }
                  },
                  "description": "QueryDenomMetadataByQueryStringResponse is the response type for the Query/DenomMetadata RPC\nmethod. Identical with QueryDenomMetadataResponse but receives denom as query string in request."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/bank/v1beta1/params": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Params queries the parameters of x/bank module.",
        "operationId": "BankParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "params": {
                      "type": "object",
                      "properties": {
                        "send_enabled": {
                          "type": "array",
                          "description": "Deprecated: Use of SendEnabled in params is deprecated.\nFor genesis, use the newly added send_enabled field in the genesis object.\nStorage, lookup, and manipulation of this information is now in the keeper.\n\nAs of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files.",
                          "items": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string"
                              },
                              "enabled": {
                                "type": "boolean"
                              }
                            },
                            "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable)."
                          }
                        },
                        "default_send_enabled": {
                          "type": "boolean"
                        }
                      },
                      "description": "params provides the parameters of the bank module."
                    }
                  },
                  "description": "QueryParamsResponse defines the response type for querying x/bank parameters."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/bank/v1beta1/send_enabled": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "SendEnabled queries for SendEnabled entries.",
        "description": "This query only returns denominations that have specific SendEnabled settings.\nAny denomination that does not have a specific setting will use the default\nparams.default_send_enabled, and will not be returned by this query.\n\nSince: cosmos-sdk 0.47",
        "operationId": "SendEnabled",
        "parameters": [
          {
            "name": "denoms",
            "in": "query",
            "description": "denoms is the specific denoms you want look up. Leave empty to get all entries.",
            "style": "form",
            "explode": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "send_enabled": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "enabled": {
                            "type": "boolean"
                          }
                        },
                        "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable)."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response. This field is only\npopulated if the denoms field in the request is empty."
                    }
                  },
                  "description": "QuerySendEnabledResponse defines the RPC response of a SendEnable query.\n\nSince: cosmos-sdk 0.47"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/bank/v1beta1/spendable_balances/{address}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "SpendableBalances queries the spendable balance of all coins for a single\naccount.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.\n\nSince: cosmos-sdk 0.46",
        "operationId": "SpendableBalances",
        "parameters": [
          {
            "name": "address",
            "in": "path",
            "description": "address is the address to query spendable balances for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "balances": {
                      "type": "array",
                      "description": "balances is the spendable balances of all the coins.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QuerySpendableBalancesResponse defines the gRPC response structure for querying\nan account's spendable balances.\n\nSince: cosmos-sdk 0.46"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/bank/v1beta1/spendable_balances/{address}/by_denom": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "SpendableBalanceByDenom queries the spendable balance of a single denom for\na single account.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.\n\nSince: cosmos-sdk 0.47",
        "operationId": "SpendableBalanceByDenom",
        "parameters": [
          {
            "name": "address",
            "in": "path",
            "description": "address is the address to query balances for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "denom",
            "in": "query",
            "description": "denom is the coin denom to query balances for.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "balance": {
                      "type": "object",
                      "properties": {
                        "denom": {
                          "type": "string"
                        },
                        "amount": {
                          "type": "string"
                        }
                      },
                      "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                    }
                  },
                  "description": "QuerySpendableBalanceByDenomResponse defines the gRPC response structure for\nquerying an account's spendable balance for a specific denom.\n\nSince: cosmos-sdk 0.47"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/bank/v1beta1/supply": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "TotalSupply queries the total supply of all coins.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "TotalSupply",
        "parameters": [
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC\nmethod",
                  "type": "object",
                  "properties": {
                    "supply": {
                      "title": "supply is the supply of the coins",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response.\n\nSince: cosmos-sdk 0.43"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/bank/v1beta1/supply/by_denom": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "SupplyOf queries the supply of a single coin.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "SupplyOf",
        "parameters": [
          {
            "name": "denom",
            "in": "query",
            "description": "denom is the coin denom to query balances for.",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "amount": {
                      "type": "object",
                      "properties": {
                        "denom": {
                          "type": "string"
                        },
                        "amount": {
                          "type": "string"
                        }
                      },
                      "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                    }
                  },
                  "description": "QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/distribution/v1beta1/community_pool": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "CommunityPool queries the community pool coins.",
        "operationId": "CommunityPool",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "pool": {
                      "type": "array",
                      "description": "pool defines community pool's coins.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                      }
                    }
                  },
                  "description": "QueryCommunityPoolResponse is the response type for the Query/CommunityPool\nRPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "DelegationTotalRewards queries the total rewards accrued by each\nvalidator.",
        "operationId": "DelegationTotalRewards",
        "parameters": [
          {
            "name": "delegator_address",
            "in": "path",
            "description": "delegator_address defines the delegator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "rewards": {
                      "type": "array",
                      "description": "rewards defines all the rewards accrued by a delegator.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "validator_address": {
                            "type": "string"
                          },
                          "reward": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "denom": {
                                  "type": "string"
                                },
                                "amount": {
                                  "type": "string"
                                }
                              },
                              "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                            }
                          }
                        },
                        "description": "DelegationDelegatorReward represents the properties\nof a delegator's delegation reward."
                      }
                    },
                    "total": {
                      "type": "array",
                      "description": "total defines the sum of all the rewards.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                      }
                    }
                  },
                  "description": "QueryDelegationTotalRewardsResponse is the response type for the\nQuery/DelegationTotalRewards RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegator_address}/rewards/{validator_address}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "DelegationRewards queries the total rewards accrued by a delegation.",
        "operationId": "DelegationRewards",
        "parameters": [
          {
            "name": "delegator_address",
            "in": "path",
            "description": "delegator_address defines the delegator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "validator_address",
            "in": "path",
            "description": "validator_address defines the validator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "rewards": {
                      "type": "array",
                      "description": "rewards defines the rewards accrued by a delegation.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                      }
                    }
                  },
                  "description": "QueryDelegationRewardsResponse is the response type for the\nQuery/DelegationRewards RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegator_address}/validators": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "DelegatorValidators queries the validators of a delegator.",
        "operationId": "DistDelegatorValidators",
        "parameters": [
          {
            "name": "delegator_address",
            "in": "path",
            "description": "delegator_address defines the delegator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "validators": {
                      "type": "array",
                      "description": "validators defines the validators a delegator is delegating for.",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "description": "QueryDelegatorValidatorsResponse is the response type for the\nQuery/DelegatorValidators RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/distribution/v1beta1/delegators/{delegator_address}/withdraw_address": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "DelegatorWithdrawAddress queries withdraw address of a delegator.",
        "operationId": "DelegatorWithdrawAddress",
        "parameters": [
          {
            "name": "delegator_address",
            "in": "path",
            "description": "delegator_address defines the delegator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "withdraw_address": {
                      "type": "string",
                      "description": "withdraw_address defines the delegator address to query for."
                    }
                  },
                  "description": "QueryDelegatorWithdrawAddressResponse is the response type for the\nQuery/DelegatorWithdrawAddress RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/distribution/v1beta1/params": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Params queries params of the distribution module.",
        "operationId": "DistributionParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "params": {
                      "type": "object",
                      "properties": {
                        "community_tax": {
                          "type": "string"
                        },
                        "base_proposer_reward": {
                          "type": "string",
                          "description": "Deprecated: The base_proposer_reward field is deprecated and is no longer used\nin the x/distribution module's reward mechanism."
                        },
                        "bonus_proposer_reward": {
                          "type": "string",
                          "description": "Deprecated: The bonus_proposer_reward field is deprecated and is no longer used\nin the x/distribution module's reward mechanism."
                        },
                        "withdraw_addr_enabled": {
                          "type": "boolean"
                        }
                      },
                      "description": "params defines the parameters of the module."
                    }
                  },
                  "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/distribution/v1beta1/validators/{validator_address}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ValidatorDistributionInfo queries validator commission and self-delegation rewards for validator",
        "operationId": "ValidatorDistributionInfo",
        "parameters": [
          {
            "name": "validator_address",
            "in": "path",
            "description": "validator_address defines the validator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "operator_address": {
                      "type": "string",
                      "description": "operator_address defines the validator operator address."
                    },
                    "self_bond_rewards": {
                      "type": "array",
                      "description": "self_bond_rewards defines the self delegations rewards.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                      }
                    },
                    "commission": {
                      "type": "array",
                      "description": "commission defines the commission the validator received.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "denom": {
                            "type": "string"
                          },
                          "amount": {
                            "type": "string"
                          }
                        },
                        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                      }
                    }
                  },
                  "description": "QueryValidatorDistributionInfoResponse is the response type for the Query/ValidatorDistributionInfo RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/distribution/v1beta1/validators/{validator_address}/commission": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ValidatorCommission queries accumulated commission for a validator.",
        "operationId": "ValidatorCommission",
        "parameters": [
          {
            "name": "validator_address",
            "in": "path",
            "description": "validator_address defines the validator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryValidatorCommissionResponse is the response type for the\nQuery/ValidatorCommission RPC method",
                  "type": "object",
                  "properties": {
                    "commission": {
                      "type": "object",
                      "properties": {
                        "commission": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string"
                              },
                              "amount": {
                                "type": "string"
                              }
                            },
                            "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                          }
                        }
                      },
                      "description": "commission defines the commission the validator received."
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/distribution/v1beta1/validators/{validator_address}/outstanding_rewards": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ValidatorOutstandingRewards queries rewards of a validator address.",
        "operationId": "ValidatorOutstandingRewards",
        "parameters": [
          {
            "name": "validator_address",
            "in": "path",
            "description": "validator_address defines the validator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "rewards": {
                      "type": "object",
                      "properties": {
                        "rewards": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string"
                              },
                              "amount": {
                                "type": "string"
                              }
                            },
                            "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                          }
                        }
                      },
                      "description": "ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards\nfor a validator inexpensive to track, allows simple sanity checks."
                    }
                  },
                  "description": "QueryValidatorOutstandingRewardsResponse is the response type for the\nQuery/ValidatorOutstandingRewards RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/distribution/v1beta1/validators/{validator_address}/slashes": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ValidatorSlashes queries slash events of a validator.",
        "operationId": "ValidatorSlashes",
        "parameters": [
          {
            "name": "validator_address",
            "in": "path",
            "description": "validator_address defines the validator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "starting_height",
            "in": "query",
            "description": "starting_height defines the optional starting height to query the slashes.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "ending_height",
            "in": "query",
            "description": "starting_height defines the optional ending height to query the slashes.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "slashes": {
                      "type": "array",
                      "description": "slashes defines the slashes the validator received.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "validator_period": {
                            "type": "string",
                            "format": "uint64"
                          },
                          "fraction": {
                            "type": "string"
                          }
                        },
                        "description": "ValidatorSlashEvent represents a validator slash event.\nHeight is implicit within the store key.\nThis is needed to calculate appropriate amount of staking tokens\nfor delegations which are withdrawn after a slash has occurred."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryValidatorSlashesResponse is the response type for the\nQuery/ValidatorSlashes RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/feegrant/v1beta1/allowance/{granter}/{grantee}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Allowance returns granted allwance to the grantee by the granter.",
        "operationId": "Allowance",
        "parameters": [
          {
            "name": "granter",
            "in": "path",
            "description": "granter is the address of the user granting an allowance of their funds.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "grantee",
            "in": "path",
            "description": "grantee is the address of the user being granted an allowance of another user's funds.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "allowance": {
                      "title": "Grant is stored in the KVStore to record a grant with full context",
                      "type": "object",
                      "properties": {
                        "granter": {
                          "type": "string",
                          "description": "granter is the address of the user granting an allowance of their funds."
                        },
                        "grantee": {
                          "type": "string",
                          "description": "grantee is the address of the user being granted an allowance of another user's funds."
                        },
                        "allowance": {
                          "type": "object",
                          "properties": {
                            "type_url": {
                              "type": "string",
                              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                            },
                            "value": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Must be a valid serialized protocol buffer of the above specified type.",
                              "format": "byte"
                            }
                          },
                          "description": "allowance can be any of basic, periodic, allowed fee allowance."
                        }
                      },
                      "description": "allowance is a allowance granted for grantee by granter."
                    }
                  },
                  "description": "QueryAllowanceResponse is the response type for the Query/Allowance RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/feegrant/v1beta1/allowances/{grantee}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Allowances returns all the grants for the given grantee address.",
        "operationId": "Allowances",
        "parameters": [
          {
            "name": "grantee",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "allowances": {
                      "type": "array",
                      "description": "allowances are allowance's granted for grantee by granter.",
                      "items": {
                        "title": "Grant is stored in the KVStore to record a grant with full context",
                        "type": "object",
                        "properties": {
                          "granter": {
                            "type": "string",
                            "description": "granter is the address of the user granting an allowance of their funds."
                          },
                          "grantee": {
                            "type": "string",
                            "description": "grantee is the address of the user being granted an allowance of another user's funds."
                          },
                          "allowance": {
                            "type": "object",
                            "properties": {
                              "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                              },
                              "value": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "byte"
                              }
                            },
                            "description": "allowance can be any of basic, periodic, allowed fee allowance."
                          }
                        }
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines an pagination for the response."
                    }
                  },
                  "description": "QueryAllowancesResponse is the response type for the Query/Allowances RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/feegrant/v1beta1/issued/{granter}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "AllowancesByGranter returns all the grants given by an address",
        "description": "Since: cosmos-sdk 0.46",
        "operationId": "AllowancesByGranter",
        "parameters": [
          {
            "name": "granter",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "allowances": {
                      "type": "array",
                      "description": "allowances that have been issued by the granter.",
                      "items": {
                        "title": "Grant is stored in the KVStore to record a grant with full context",
                        "type": "object",
                        "properties": {
                          "granter": {
                            "type": "string",
                            "description": "granter is the address of the user granting an allowance of their funds."
                          },
                          "grantee": {
                            "type": "string",
                            "description": "grantee is the address of the user being granted an allowance of another user's funds."
                          },
                          "allowance": {
                            "type": "object",
                            "properties": {
                              "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                              },
                              "value": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "byte"
                              }
                            },
                            "description": "allowance can be any of basic, periodic, allowed fee allowance."
                          }
                        }
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines an pagination for the response."
                    }
                  },
                  "description": "QueryAllowancesByGranterResponse is the response type for the Query/AllowancesByGranter RPC method.\n\nSince: cosmos-sdk 0.46"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/evidence/v1beta1/evidence": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "AllEvidence queries all evidence.",
        "operationId": "AllEvidence",
        "parameters": [
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "evidence": {
                      "type": "array",
                      "description": "evidence returns all evidences.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/evidence/v1beta1/evidence/{hash}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Evidence queries evidence based on evidence hash.",
        "operationId": "Evidence",
        "parameters": [
          {
            "name": "hash",
            "in": "path",
            "description": "hash defines the evidence hash of the requested evidence.\n\nSince: cosmos-sdk 0.47",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "evidence_hash",
            "in": "query",
            "description": "evidence_hash defines the hash of the requested evidence.\nDeprecated: Use hash, a HEX encoded string, instead.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "evidence": {
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Must be a valid serialized protocol buffer of the above specified type.",
                          "format": "byte"
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    }
                  },
                  "description": "QueryEvidenceResponse is the response type for the Query/Evidence RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/gov/v1beta1/params/{params_type}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Params queries all parameters of the gov module.",
        "operationId": "GovParams",
        "parameters": [
          {
            "name": "params_type",
            "in": "path",
            "description": "params_type defines which parameters to query for, can be one of \"voting\",\n\"tallying\" or \"deposit\".",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "voting_params": {
                      "type": "object",
                      "properties": {
                        "voting_period": {
                          "type": "string",
                          "description": "Duration of the voting period."
                        }
                      },
                      "description": "voting_params defines the parameters related to voting."
                    },
                    "deposit_params": {
                      "type": "object",
                      "properties": {
                        "min_deposit": {
                          "type": "array",
                          "description": "Minimum deposit for a proposal to enter voting period.",
                          "items": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string"
                              },
                              "amount": {
                                "type": "string"
                              }
                            },
                            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                          }
                        },
                        "max_deposit_period": {
                          "type": "string",
                          "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
                        }
                      },
                      "description": "deposit_params defines the parameters related to deposit."
                    },
                    "tally_params": {
                      "type": "object",
                      "properties": {
                        "quorum": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Minimum percentage of total stake needed to vote for a result to be\nconsidered valid.",
                          "format": "byte"
                        },
                        "threshold": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.",
                          "format": "byte"
                        },
                        "veto_threshold": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\nvetoed. Default value: 1/3.",
                          "format": "byte"
                        }
                      },
                      "description": "tally_params defines the parameters related to tally."
                    }
                  },
                  "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/gov/v1beta1/proposals": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Proposals queries all proposals based on given status.",
        "operationId": "Proposals",
        "parameters": [
          {
            "name": "proposal_status",
            "in": "query",
            "description": "proposal_status defines the status of the proposals.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed.",
            "schema": {
              "type": "string",
              "default": "PROPOSAL_STATUS_UNSPECIFIED",
              "enum": [
                "PROPOSAL_STATUS_UNSPECIFIED",
                "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                "PROPOSAL_STATUS_VOTING_PERIOD",
                "PROPOSAL_STATUS_PASSED",
                "PROPOSAL_STATUS_REJECTED",
                "PROPOSAL_STATUS_FAILED"
              ]
            }
          },
          {
            "name": "voter",
            "in": "query",
            "description": "voter defines the voter address for the proposals.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "depositor",
            "in": "query",
            "description": "depositor defines the deposit addresses from the proposals.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "proposals": {
                      "type": "array",
                      "description": "proposals defines all the requested governance proposals.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "proposal_id": {
                            "type": "string",
                            "description": "proposal_id defines the unique id of the proposal.",
                            "format": "uint64"
                          },
                          "content": {
                            "type": "object",
                            "properties": {
                              "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                              },
                              "value": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "byte"
                              }
                            },
                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                          },
                          "status": {
                            "type": "string",
                            "description": "status defines the proposal status.",
                            "default": "PROPOSAL_STATUS_UNSPECIFIED",
                            "enum": [
                              "PROPOSAL_STATUS_UNSPECIFIED",
                              "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                              "PROPOSAL_STATUS_VOTING_PERIOD",
                              "PROPOSAL_STATUS_PASSED",
                              "PROPOSAL_STATUS_REJECTED",
                              "PROPOSAL_STATUS_FAILED"
                            ]
                          },
                          "final_tally_result": {
                            "type": "object",
                            "properties": {
                              "yes": {
                                "type": "string",
                                "description": "yes is the number of yes votes on a proposal."
                              },
                              "abstain": {
                                "type": "string",
                                "description": "abstain is the number of abstain votes on a proposal."
                              },
                              "no": {
                                "type": "string",
                                "description": "no is the number of no votes on a proposal."
                              },
                              "no_with_veto": {
                                "type": "string",
                                "description": "no_with_veto is the number of no with veto votes on a proposal."
                              }
                            },
                            "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended."
                          },
                          "submit_time": {
                            "type": "string",
                            "description": "submit_time is the time of proposal submission.",
                            "format": "date-time"
                          },
                          "deposit_end_time": {
                            "type": "string",
                            "description": "deposit_end_time is the end time for deposition.",
                            "format": "date-time"
                          },
                          "total_deposit": {
                            "type": "array",
                            "description": "total_deposit is the total deposit on the proposal.",
                            "items": {
                              "type": "object",
                              "properties": {
                                "denom": {
                                  "type": "string"
                                },
                                "amount": {
                                  "type": "string"
                                }
                              },
                              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                            }
                          },
                          "voting_start_time": {
                            "type": "string",
                            "description": "voting_start_time is the starting time to vote on a proposal.",
                            "format": "date-time"
                          },
                          "voting_end_time": {
                            "type": "string",
                            "description": "voting_end_time is the end time of voting on a proposal.",
                            "format": "date-time"
                          }
                        },
                        "description": "Proposal defines the core field members of a governance proposal."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryProposalsResponse is the response type for the Query/Proposals RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Proposal queries proposal details based on ProposalID.",
        "operationId": "Proposal",
        "parameters": [
          {
            "name": "proposal_id",
            "in": "path",
            "description": "proposal_id defines the unique id of the proposal.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "proposal": {
                      "type": "object",
                      "properties": {
                        "proposal_id": {
                          "type": "string",
                          "description": "proposal_id defines the unique id of the proposal.",
                          "format": "uint64"
                        },
                        "content": {
                          "type": "object",
                          "properties": {
                            "type_url": {
                              "type": "string",
                              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                            },
                            "value": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Must be a valid serialized protocol buffer of the above specified type.",
                              "format": "byte"
                            }
                          },
                          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                        },
                        "status": {
                          "type": "string",
                          "description": "status defines the proposal status.",
                          "default": "PROPOSAL_STATUS_UNSPECIFIED",
                          "enum": [
                            "PROPOSAL_STATUS_UNSPECIFIED",
                            "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                            "PROPOSAL_STATUS_VOTING_PERIOD",
                            "PROPOSAL_STATUS_PASSED",
                            "PROPOSAL_STATUS_REJECTED",
                            "PROPOSAL_STATUS_FAILED"
                          ]
                        },
                        "final_tally_result": {
                          "type": "object",
                          "properties": {
                            "yes": {
                              "type": "string",
                              "description": "yes is the number of yes votes on a proposal."
                            },
                            "abstain": {
                              "type": "string",
                              "description": "abstain is the number of abstain votes on a proposal."
                            },
                            "no": {
                              "type": "string",
                              "description": "no is the number of no votes on a proposal."
                            },
                            "no_with_veto": {
                              "type": "string",
                              "description": "no_with_veto is the number of no with veto votes on a proposal."
                            }
                          },
                          "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended."
                        },
                        "submit_time": {
                          "type": "string",
                          "description": "submit_time is the time of proposal submission.",
                          "format": "date-time"
                        },
                        "deposit_end_time": {
                          "type": "string",
                          "description": "deposit_end_time is the end time for deposition.",
                          "format": "date-time"
                        },
                        "total_deposit": {
                          "type": "array",
                          "description": "total_deposit is the total deposit on the proposal.",
                          "items": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string"
                              },
                              "amount": {
                                "type": "string"
                              }
                            },
                            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                          }
                        },
                        "voting_start_time": {
                          "type": "string",
                          "description": "voting_start_time is the starting time to vote on a proposal.",
                          "format": "date-time"
                        },
                        "voting_end_time": {
                          "type": "string",
                          "description": "voting_end_time is the end time of voting on a proposal.",
                          "format": "date-time"
                        }
                      },
                      "description": "Proposal defines the core field members of a governance proposal."
                    }
                  },
                  "description": "QueryProposalResponse is the response type for the Query/Proposal RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Deposits queries all deposits of a single proposal.",
        "operationId": "Deposits",
        "parameters": [
          {
            "name": "proposal_id",
            "in": "path",
            "description": "proposal_id defines the unique id of the proposal.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "deposits": {
                      "type": "array",
                      "description": "deposits defines the requested deposits.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "proposal_id": {
                            "type": "string",
                            "description": "proposal_id defines the unique id of the proposal.",
                            "format": "uint64"
                          },
                          "depositor": {
                            "type": "string",
                            "description": "depositor defines the deposit addresses from the proposals."
                          },
                          "amount": {
                            "type": "array",
                            "description": "amount to be deposited by depositor.",
                            "items": {
                              "type": "object",
                              "properties": {
                                "denom": {
                                  "type": "string"
                                },
                                "amount": {
                                  "type": "string"
                                }
                              },
                              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                            }
                          }
                        },
                        "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryDepositsResponse is the response type for the Query/Deposits RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/deposits/{depositor}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Deposit queries single deposit information based on proposalID, depositor address.",
        "operationId": "Deposit",
        "parameters": [
          {
            "name": "proposal_id",
            "in": "path",
            "description": "proposal_id defines the unique id of the proposal.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "depositor",
            "in": "path",
            "description": "depositor defines the deposit addresses from the proposals.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "deposit": {
                      "type": "object",
                      "properties": {
                        "proposal_id": {
                          "type": "string",
                          "description": "proposal_id defines the unique id of the proposal.",
                          "format": "uint64"
                        },
                        "depositor": {
                          "type": "string",
                          "description": "depositor defines the deposit addresses from the proposals."
                        },
                        "amount": {
                          "type": "array",
                          "description": "amount to be deposited by depositor.",
                          "items": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string"
                              },
                              "amount": {
                                "type": "string"
                              }
                            },
                            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                          }
                        }
                      },
                      "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
                    }
                  },
                  "description": "QueryDepositResponse is the response type for the Query/Deposit RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/tally": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "TallyResult queries the tally of a proposal vote.",
        "operationId": "TallyResult",
        "parameters": [
          {
            "name": "proposal_id",
            "in": "path",
            "description": "proposal_id defines the unique id of the proposal.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "tally": {
                      "type": "object",
                      "properties": {
                        "yes": {
                          "type": "string",
                          "description": "yes is the number of yes votes on a proposal."
                        },
                        "abstain": {
                          "type": "string",
                          "description": "abstain is the number of abstain votes on a proposal."
                        },
                        "no": {
                          "type": "string",
                          "description": "no is the number of no votes on a proposal."
                        },
                        "no_with_veto": {
                          "type": "string",
                          "description": "no_with_veto is the number of no with veto votes on a proposal."
                        }
                      },
                      "description": "tally defines the requested tally."
                    }
                  },
                  "description": "QueryTallyResultResponse is the response type for the Query/Tally RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/votes": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Votes queries votes of a given proposal.",
        "operationId": "Votes",
        "parameters": [
          {
            "name": "proposal_id",
            "in": "path",
            "description": "proposal_id defines the unique id of the proposal.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "votes": {
                      "type": "array",
                      "description": "votes defines the queried votes.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "proposal_id": {
                            "type": "string",
                            "description": "proposal_id defines the unique id of the proposal.",
                            "format": "uint64"
                          },
                          "voter": {
                            "type": "string",
                            "description": "voter is the voter address of the proposal."
                          },
                          "option": {
                            "type": "string",
                            "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
                            "default": "VOTE_OPTION_UNSPECIFIED",
                            "enum": [
                              "VOTE_OPTION_UNSPECIFIED",
                              "VOTE_OPTION_YES",
                              "VOTE_OPTION_ABSTAIN",
                              "VOTE_OPTION_NO",
                              "VOTE_OPTION_NO_WITH_VETO"
                            ]
                          },
                          "options": {
                            "type": "array",
                            "description": "options is the weighted vote options.\n\nSince: cosmos-sdk 0.43",
                            "items": {
                              "type": "object",
                              "properties": {
                                "option": {
                                  "type": "string",
                                  "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                                  "default": "VOTE_OPTION_UNSPECIFIED",
                                  "enum": [
                                    "VOTE_OPTION_UNSPECIFIED",
                                    "VOTE_OPTION_YES",
                                    "VOTE_OPTION_ABSTAIN",
                                    "VOTE_OPTION_NO",
                                    "VOTE_OPTION_NO_WITH_VETO"
                                  ]
                                },
                                "weight": {
                                  "type": "string",
                                  "description": "weight is the vote weight associated with the vote option."
                                }
                              },
                              "description": "WeightedVoteOption defines a unit of vote for vote split.\n\nSince: cosmos-sdk 0.43"
                            }
                          }
                        },
                        "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryVotesResponse is the response type for the Query/Votes RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/gov/v1beta1/proposals/{proposal_id}/votes/{voter}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Vote queries voted information based on proposalID, voterAddr.\nDue to how we handle state, this query would error for proposals that has already been finished.",
        "operationId": "Vote",
        "parameters": [
          {
            "name": "proposal_id",
            "in": "path",
            "description": "proposal_id defines the unique id of the proposal.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "voter",
            "in": "path",
            "description": "voter defines the voter address for the proposals.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "vote": {
                      "type": "object",
                      "properties": {
                        "proposal_id": {
                          "type": "string",
                          "description": "proposal_id defines the unique id of the proposal.",
                          "format": "uint64"
                        },
                        "voter": {
                          "type": "string",
                          "description": "voter is the voter address of the proposal."
                        },
                        "option": {
                          "type": "string",
                          "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
                          "default": "VOTE_OPTION_UNSPECIFIED",
                          "enum": [
                            "VOTE_OPTION_UNSPECIFIED",
                            "VOTE_OPTION_YES",
                            "VOTE_OPTION_ABSTAIN",
                            "VOTE_OPTION_NO",
                            "VOTE_OPTION_NO_WITH_VETO"
                          ]
                        },
                        "options": {
                          "type": "array",
                          "description": "options is the weighted vote options.\n\nSince: cosmos-sdk 0.43",
                          "items": {
                            "type": "object",
                            "properties": {
                              "option": {
                                "type": "string",
                                "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                                "default": "VOTE_OPTION_UNSPECIFIED",
                                "enum": [
                                  "VOTE_OPTION_UNSPECIFIED",
                                  "VOTE_OPTION_YES",
                                  "VOTE_OPTION_ABSTAIN",
                                  "VOTE_OPTION_NO",
                                  "VOTE_OPTION_NO_WITH_VETO"
                                ]
                              },
                              "weight": {
                                "type": "string",
                                "description": "weight is the vote weight associated with the vote option."
                              }
                            },
                            "description": "WeightedVoteOption defines a unit of vote for vote split.\n\nSince: cosmos-sdk 0.43"
                          }
                        }
                      },
                      "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
                    }
                  },
                  "description": "QueryVoteResponse is the response type for the Query/Vote RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/gov/v1/constitution": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Constitution queries the chain's constitution.",
        "operationId": "Constitution",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryConstitutionResponse is the response type for the Query/Constitution RPC method",
                  "type": "object",
                  "properties": {
                    "constitution": {
                      "type": "string"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/gov/v1/params/{params_type}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Params queries all parameters of the gov module.",
        "operationId": "GovV1Params",
        "parameters": [
          {
            "name": "params_type",
            "in": "path",
            "description": "params_type defines which parameters to query for, can be one of \"voting\",\n\"tallying\" or \"deposit\".",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "voting_params": {
                      "type": "object",
                      "properties": {
                        "voting_period": {
                          "type": "string",
                          "description": "Duration of the voting period."
                        }
                      },
                      "description": "Deprecated: Prefer to use `params` instead.\nvoting_params defines the parameters related to voting."
                    },
                    "deposit_params": {
                      "type": "object",
                      "properties": {
                        "min_deposit": {
                          "type": "array",
                          "description": "Minimum deposit for a proposal to enter voting period.",
                          "items": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string"
                              },
                              "amount": {
                                "type": "string"
                              }
                            },
                            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                          }
                        },
                        "max_deposit_period": {
                          "type": "string",
                          "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
                        }
                      },
                      "description": "Deprecated: Prefer to use `params` instead.\ndeposit_params defines the parameters related to deposit."
                    },
                    "tally_params": {
                      "type": "object",
                      "properties": {
                        "quorum": {
                          "type": "string",
                          "description": "Minimum percentage of total stake needed to vote for a result to be\nconsidered valid."
                        },
                        "threshold": {
                          "type": "string",
                          "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
                        },
                        "veto_threshold": {
                          "type": "string",
                          "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\nvetoed. Default value: 1/3."
                        }
                      },
                      "description": "Deprecated: Prefer to use `params` instead.\ntally_params defines the parameters related to tally."
                    },
                    "params": {
                      "type": "object",
                      "properties": {
                        "min_deposit": {
                          "type": "array",
                          "description": "Minimum deposit for a proposal to enter voting period.",
                          "items": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string"
                              },
                              "amount": {
                                "type": "string"
                              }
                            },
                            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                          }
                        },
                        "max_deposit_period": {
                          "type": "string",
                          "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
                        },
                        "voting_period": {
                          "type": "string",
                          "description": "Duration of the voting period."
                        },
                        "quorum": {
                          "type": "string",
                          "description": "Minimum percentage of total stake needed to vote for a result to be\n considered valid."
                        },
                        "threshold": {
                          "type": "string",
                          "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
                        },
                        "veto_threshold": {
                          "type": "string",
                          "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\n vetoed. Default value: 1/3."
                        },
                        "min_initial_deposit_ratio": {
                          "type": "string",
                          "description": "The ratio representing the proportion of the deposit value that must be paid at proposal submission."
                        },
                        "proposal_cancel_ratio": {
                          "type": "string",
                          "description": "The cancel ratio which will not be returned back to the depositors when a proposal is cancelled.\n\nSince: cosmos-sdk 0.50"
                        },
                        "proposal_cancel_dest": {
                          "type": "string",
                          "description": "The address which will receive (proposal_cancel_ratio * deposit) proposal deposits.\nIf empty, the (proposal_cancel_ratio * deposit) proposal deposits will be burned.\n\nSince: cosmos-sdk 0.50"
                        },
                        "expedited_voting_period": {
                          "type": "string",
                          "description": "Duration of the voting period of an expedited proposal.\n\nSince: cosmos-sdk 0.50"
                        },
                        "expedited_threshold": {
                          "type": "string",
                          "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.67.\n\nSince: cosmos-sdk 0.50"
                        },
                        "expedited_min_deposit": {
                          "type": "array",
                          "description": "Minimum expedited deposit for a proposal to enter voting period.",
                          "items": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string"
                              },
                              "amount": {
                                "type": "string"
                              }
                            },
                            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                          }
                        },
                        "burn_vote_quorum": {
                          "title": "burn deposits if a proposal does not meet quorum",
                          "type": "boolean"
                        },
                        "burn_proposal_deposit_prevote": {
                          "title": "burn deposits if the proposal does not enter voting period",
                          "type": "boolean"
                        },
                        "burn_vote_veto": {
                          "title": "burn deposits if quorum with vote type no_veto is met",
                          "type": "boolean"
                        }
                      },
                      "description": "params defines all the paramaters of x/gov module.\n\nSince: cosmos-sdk 0.47"
                    }
                  },
                  "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/gov/v1/proposals": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Proposals queries all proposals based on given status.",
        "operationId": "GovV1Proposal",
        "parameters": [
          {
            "name": "proposal_status",
            "in": "query",
            "description": "proposal_status defines the status of the proposals.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed.",
            "schema": {
              "type": "string",
              "default": "PROPOSAL_STATUS_UNSPECIFIED",
              "enum": [
                "PROPOSAL_STATUS_UNSPECIFIED",
                "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                "PROPOSAL_STATUS_VOTING_PERIOD",
                "PROPOSAL_STATUS_PASSED",
                "PROPOSAL_STATUS_REJECTED",
                "PROPOSAL_STATUS_FAILED"
              ]
            }
          },
          {
            "name": "voter",
            "in": "query",
            "description": "voter defines the voter address for the proposals.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "depositor",
            "in": "query",
            "description": "depositor defines the deposit addresses from the proposals.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "proposals": {
                      "type": "array",
                      "description": "proposals defines all the requested governance proposals.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "id": {
                            "type": "string",
                            "description": "id defines the unique id of the proposal.",
                            "format": "uint64"
                          },
                          "messages": {
                            "type": "array",
                            "description": "messages are the arbitrary messages to be executed if the proposal passes.",
                            "items": {
                              "type": "object",
                              "properties": {
                                "type_url": {
                                  "type": "string",
                                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                                },
                                "value": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                  "format": "byte"
                                }
                              },
                              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                            }
                          },
                          "status": {
                            "type": "string",
                            "description": "status defines the proposal status.",
                            "default": "PROPOSAL_STATUS_UNSPECIFIED",
                            "enum": [
                              "PROPOSAL_STATUS_UNSPECIFIED",
                              "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                              "PROPOSAL_STATUS_VOTING_PERIOD",
                              "PROPOSAL_STATUS_PASSED",
                              "PROPOSAL_STATUS_REJECTED",
                              "PROPOSAL_STATUS_FAILED"
                            ]
                          },
                          "final_tally_result": {
                            "type": "object",
                            "properties": {
                              "yes_count": {
                                "type": "string",
                                "description": "yes_count is the number of yes votes on a proposal."
                              },
                              "abstain_count": {
                                "type": "string",
                                "description": "abstain_count is the number of abstain votes on a proposal."
                              },
                              "no_count": {
                                "type": "string",
                                "description": "no_count is the number of no votes on a proposal."
                              },
                              "no_with_veto_count": {
                                "type": "string",
                                "description": "no_with_veto_count is the number of no with veto votes on a proposal."
                              }
                            },
                            "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended."
                          },
                          "submit_time": {
                            "type": "string",
                            "description": "submit_time is the time of proposal submission.",
                            "format": "date-time"
                          },
                          "deposit_end_time": {
                            "type": "string",
                            "description": "deposit_end_time is the end time for deposition.",
                            "format": "date-time"
                          },
                          "total_deposit": {
                            "type": "array",
                            "description": "total_deposit is the total deposit on the proposal.",
                            "items": {
                              "type": "object",
                              "properties": {
                                "denom": {
                                  "type": "string"
                                },
                                "amount": {
                                  "type": "string"
                                }
                              },
                              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                            }
                          },
                          "voting_start_time": {
                            "type": "string",
                            "description": "voting_start_time is the starting time to vote on a proposal.",
                            "format": "date-time"
                          },
                          "voting_end_time": {
                            "type": "string",
                            "description": "voting_end_time is the end time of voting on a proposal.",
                            "format": "date-time"
                          },
                          "metadata": {
                            "title": "metadata is any arbitrary metadata attached to the proposal.\nthe recommended format of the metadata is to be found here:\nhttps://docs.cosmos.network/v0.47/modules/gov#proposal-3",
                            "type": "string"
                          },
                          "title": {
                            "title": "title is the title of the proposal",
                            "type": "string",
                            "description": "Since: cosmos-sdk 0.47"
                          },
                          "summary": {
                            "title": "summary is a short summary of the proposal",
                            "type": "string",
                            "description": "Since: cosmos-sdk 0.47"
                          },
                          "proposer": {
                            "title": "proposer is the address of the proposal sumbitter",
                            "type": "string",
                            "description": "Since: cosmos-sdk 0.47"
                          },
                          "expedited": {
                            "title": "expedited defines if the proposal is expedited",
                            "type": "boolean",
                            "description": "Since: cosmos-sdk 0.50"
                          },
                          "failed_reason": {
                            "title": "failed_reason defines the reason why the proposal failed",
                            "type": "string",
                            "description": "Since: cosmos-sdk 0.50"
                          }
                        },
                        "description": "Proposal defines the core field members of a governance proposal."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryProposalsResponse is the response type for the Query/Proposals RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/gov/v1/proposals/{proposal_id}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Proposal queries proposal details based on ProposalID.",
        "operationId": "GovV1Proposal",
        "parameters": [
          {
            "name": "proposal_id",
            "in": "path",
            "description": "proposal_id defines the unique id of the proposal.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "proposal": {
                      "type": "object",
                      "properties": {
                        "id": {
                          "type": "string",
                          "description": "id defines the unique id of the proposal.",
                          "format": "uint64"
                        },
                        "messages": {
                          "type": "array",
                          "description": "messages are the arbitrary messages to be executed if the proposal passes.",
                          "items": {
                            "type": "object",
                            "properties": {
                              "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                              },
                              "value": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "byte"
                              }
                            },
                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                          }
                        },
                        "status": {
                          "type": "string",
                          "description": "status defines the proposal status.",
                          "default": "PROPOSAL_STATUS_UNSPECIFIED",
                          "enum": [
                            "PROPOSAL_STATUS_UNSPECIFIED",
                            "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                            "PROPOSAL_STATUS_VOTING_PERIOD",
                            "PROPOSAL_STATUS_PASSED",
                            "PROPOSAL_STATUS_REJECTED",
                            "PROPOSAL_STATUS_FAILED"
                          ]
                        },
                        "final_tally_result": {
                          "type": "object",
                          "properties": {
                            "yes_count": {
                              "type": "string",
                              "description": "yes_count is the number of yes votes on a proposal."
                            },
                            "abstain_count": {
                              "type": "string",
                              "description": "abstain_count is the number of abstain votes on a proposal."
                            },
                            "no_count": {
                              "type": "string",
                              "description": "no_count is the number of no votes on a proposal."
                            },
                            "no_with_veto_count": {
                              "type": "string",
                              "description": "no_with_veto_count is the number of no with veto votes on a proposal."
                            }
                          },
                          "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended."
                        },
                        "submit_time": {
                          "type": "string",
                          "description": "submit_time is the time of proposal submission.",
                          "format": "date-time"
                        },
                        "deposit_end_time": {
                          "type": "string",
                          "description": "deposit_end_time is the end time for deposition.",
                          "format": "date-time"
                        },
                        "total_deposit": {
                          "type": "array",
                          "description": "total_deposit is the total deposit on the proposal.",
                          "items": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string"
                              },
                              "amount": {
                                "type": "string"
                              }
                            },
                            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                          }
                        },
                        "voting_start_time": {
                          "type": "string",
                          "description": "voting_start_time is the starting time to vote on a proposal.",
                          "format": "date-time"
                        },
                        "voting_end_time": {
                          "type": "string",
                          "description": "voting_end_time is the end time of voting on a proposal.",
                          "format": "date-time"
                        },
                        "metadata": {
                          "title": "metadata is any arbitrary metadata attached to the proposal.\nthe recommended format of the metadata is to be found here:\nhttps://docs.cosmos.network/v0.47/modules/gov#proposal-3",
                          "type": "string"
                        },
                        "title": {
                          "title": "title is the title of the proposal",
                          "type": "string",
                          "description": "Since: cosmos-sdk 0.47"
                        },
                        "summary": {
                          "title": "summary is a short summary of the proposal",
                          "type": "string",
                          "description": "Since: cosmos-sdk 0.47"
                        },
                        "proposer": {
                          "title": "proposer is the address of the proposal sumbitter",
                          "type": "string",
                          "description": "Since: cosmos-sdk 0.47"
                        },
                        "expedited": {
                          "title": "expedited defines if the proposal is expedited",
                          "type": "boolean",
                          "description": "Since: cosmos-sdk 0.50"
                        },
                        "failed_reason": {
                          "title": "failed_reason defines the reason why the proposal failed",
                          "type": "string",
                          "description": "Since: cosmos-sdk 0.50"
                        }
                      },
                      "description": "Proposal defines the core field members of a governance proposal."
                    }
                  },
                  "description": "QueryProposalResponse is the response type for the Query/Proposal RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/gov/v1/proposals/{proposal_id}/deposits": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Deposits queries all deposits of a single proposal.",
        "operationId": "GovV1Deposit",
        "parameters": [
          {
            "name": "proposal_id",
            "in": "path",
            "description": "proposal_id defines the unique id of the proposal.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "deposits": {
                      "type": "array",
                      "description": "deposits defines the requested deposits.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "proposal_id": {
                            "type": "string",
                            "description": "proposal_id defines the unique id of the proposal.",
                            "format": "uint64"
                          },
                          "depositor": {
                            "type": "string",
                            "description": "depositor defines the deposit addresses from the proposals."
                          },
                          "amount": {
                            "type": "array",
                            "description": "amount to be deposited by depositor.",
                            "items": {
                              "type": "object",
                              "properties": {
                                "denom": {
                                  "type": "string"
                                },
                                "amount": {
                                  "type": "string"
                                }
                              },
                              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                            }
                          }
                        },
                        "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryDepositsResponse is the response type for the Query/Deposits RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/gov/v1/proposals/{proposal_id}/deposits/{depositor}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Deposit queries single deposit information based on proposalID, depositAddr.",
        "operationId": "GovV1Deposit",
        "parameters": [
          {
            "name": "proposal_id",
            "in": "path",
            "description": "proposal_id defines the unique id of the proposal.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "depositor",
            "in": "path",
            "description": "depositor defines the deposit addresses from the proposals.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "deposit": {
                      "type": "object",
                      "properties": {
                        "proposal_id": {
                          "type": "string",
                          "description": "proposal_id defines the unique id of the proposal.",
                          "format": "uint64"
                        },
                        "depositor": {
                          "type": "string",
                          "description": "depositor defines the deposit addresses from the proposals."
                        },
                        "amount": {
                          "type": "array",
                          "description": "amount to be deposited by depositor.",
                          "items": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string"
                              },
                              "amount": {
                                "type": "string"
                              }
                            },
                            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                          }
                        }
                      },
                      "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
                    }
                  },
                  "description": "QueryDepositResponse is the response type for the Query/Deposit RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/gov/v1/proposals/{proposal_id}/tally": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "TallyResult queries the tally of a proposal vote.",
        "operationId": "GovV1TallyResult",
        "parameters": [
          {
            "name": "proposal_id",
            "in": "path",
            "description": "proposal_id defines the unique id of the proposal.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "tally": {
                      "type": "object",
                      "properties": {
                        "yes_count": {
                          "type": "string",
                          "description": "yes_count is the number of yes votes on a proposal."
                        },
                        "abstain_count": {
                          "type": "string",
                          "description": "abstain_count is the number of abstain votes on a proposal."
                        },
                        "no_count": {
                          "type": "string",
                          "description": "no_count is the number of no votes on a proposal."
                        },
                        "no_with_veto_count": {
                          "type": "string",
                          "description": "no_with_veto_count is the number of no with veto votes on a proposal."
                        }
                      },
                      "description": "tally defines the requested tally."
                    }
                  },
                  "description": "QueryTallyResultResponse is the response type for the Query/Tally RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/gov/v1/proposals/{proposal_id}/votes": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Votes queries votes of a given proposal.",
        "operationId": "GovV1Votes",
        "parameters": [
          {
            "name": "proposal_id",
            "in": "path",
            "description": "proposal_id defines the unique id of the proposal.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "votes": {
                      "type": "array",
                      "description": "votes defines the queried votes.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "proposal_id": {
                            "type": "string",
                            "description": "proposal_id defines the unique id of the proposal.",
                            "format": "uint64"
                          },
                          "voter": {
                            "type": "string",
                            "description": "voter is the voter address of the proposal."
                          },
                          "options": {
                            "type": "array",
                            "description": "options is the weighted vote options.",
                            "items": {
                              "type": "object",
                              "properties": {
                                "option": {
                                  "type": "string",
                                  "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                                  "default": "VOTE_OPTION_UNSPECIFIED",
                                  "enum": [
                                    "VOTE_OPTION_UNSPECIFIED",
                                    "VOTE_OPTION_YES",
                                    "VOTE_OPTION_ABSTAIN",
                                    "VOTE_OPTION_NO",
                                    "VOTE_OPTION_NO_WITH_VETO"
                                  ]
                                },
                                "weight": {
                                  "type": "string",
                                  "description": "weight is the vote weight associated with the vote option."
                                }
                              },
                              "description": "WeightedVoteOption defines a unit of vote for vote split."
                            }
                          },
                          "metadata": {
                            "title": "metadata is any arbitrary metadata attached to the vote.\nthe recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/gov#vote-5",
                            "type": "string"
                          }
                        },
                        "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryVotesResponse is the response type for the Query/Votes RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/gov/v1/proposals/{proposal_id}/votes/{voter}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Vote queries voted information based on proposalID, voterAddr.",
        "operationId": "GovV1Vote",
        "parameters": [
          {
            "name": "proposal_id",
            "in": "path",
            "description": "proposal_id defines the unique id of the proposal.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "voter",
            "in": "path",
            "description": "voter defines the voter address for the proposals.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "vote": {
                      "type": "object",
                      "properties": {
                        "proposal_id": {
                          "type": "string",
                          "description": "proposal_id defines the unique id of the proposal.",
                          "format": "uint64"
                        },
                        "voter": {
                          "type": "string",
                          "description": "voter is the voter address of the proposal."
                        },
                        "options": {
                          "type": "array",
                          "description": "options is the weighted vote options.",
                          "items": {
                            "type": "object",
                            "properties": {
                              "option": {
                                "type": "string",
                                "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                                "default": "VOTE_OPTION_UNSPECIFIED",
                                "enum": [
                                  "VOTE_OPTION_UNSPECIFIED",
                                  "VOTE_OPTION_YES",
                                  "VOTE_OPTION_ABSTAIN",
                                  "VOTE_OPTION_NO",
                                  "VOTE_OPTION_NO_WITH_VETO"
                                ]
                              },
                              "weight": {
                                "type": "string",
                                "description": "weight is the vote weight associated with the vote option."
                              }
                            },
                            "description": "WeightedVoteOption defines a unit of vote for vote split."
                          }
                        },
                        "metadata": {
                          "title": "metadata is any arbitrary metadata attached to the vote.\nthe recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/gov#vote-5",
                          "type": "string"
                        }
                      },
                      "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
                    }
                  },
                  "description": "QueryVoteResponse is the response type for the Query/Vote RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/slashing/v1beta1/params": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Params queries the parameters of slashing module",
        "operationId": "SlashingParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryParamsResponse is the response type for the Query/Params RPC method",
                  "type": "object",
                  "properties": {
                    "params": {
                      "type": "object",
                      "properties": {
                        "signed_blocks_window": {
                          "type": "string",
                          "format": "int64"
                        },
                        "min_signed_per_window": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        },
                        "downtime_jail_duration": {
                          "type": "string"
                        },
                        "slash_fraction_double_sign": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        },
                        "slash_fraction_downtime": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "description": "Params represents the parameters used for by the slashing module."
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/slashing/v1beta1/signing_infos": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "SigningInfos queries signing info of all validators",
        "operationId": "SigningInfos",
        "parameters": [
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC\nmethod",
                  "type": "object",
                  "properties": {
                    "info": {
                      "title": "info is the signing info of all validators",
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "address": {
                            "type": "string"
                          },
                          "start_height": {
                            "title": "Height at which validator was first a candidate OR was un-jailed",
                            "type": "string",
                            "format": "int64"
                          },
                          "index_offset": {
                            "type": "string",
                            "description": "Index which is incremented every time a validator is bonded in a block and\n_may_ have signed a pre-commit or not. This in conjunction with the\nsigned_blocks_window param determines the index in the missed block bitmap.",
                            "format": "int64"
                          },
                          "jailed_until": {
                            "type": "string",
                            "description": "Timestamp until which the validator is jailed due to liveness downtime.",
                            "format": "date-time"
                          },
                          "tombstoned": {
                            "type": "boolean",
                            "description": "Whether or not a validator has been tombstoned (killed out of validator\nset). It is set once the validator commits an equivocation or for any other\nconfigured misbehavior."
                          },
                          "missed_blocks_counter": {
                            "type": "string",
                            "description": "A counter of missed (unsigned) blocks. It is used to avoid unnecessary\nreads in the missed block bitmap.",
                            "format": "int64"
                          }
                        },
                        "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/slashing/v1beta1/signing_infos/{cons_address}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "SigningInfo queries the signing info of given cons address",
        "operationId": "SigningInfo",
        "parameters": [
          {
            "name": "cons_address",
            "in": "path",
            "description": "cons_address is the address to query signing info of",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC\nmethod",
                  "type": "object",
                  "properties": {
                    "val_signing_info": {
                      "title": "val_signing_info is the signing info of requested val cons address",
                      "type": "object",
                      "properties": {
                        "address": {
                          "type": "string"
                        },
                        "start_height": {
                          "title": "Height at which validator was first a candidate OR was un-jailed",
                          "type": "string",
                          "format": "int64"
                        },
                        "index_offset": {
                          "type": "string",
                          "description": "Index which is incremented every time a validator is bonded in a block and\n_may_ have signed a pre-commit or not. This in conjunction with the\nsigned_blocks_window param determines the index in the missed block bitmap.",
                          "format": "int64"
                        },
                        "jailed_until": {
                          "type": "string",
                          "description": "Timestamp until which the validator is jailed due to liveness downtime.",
                          "format": "date-time"
                        },
                        "tombstoned": {
                          "type": "boolean",
                          "description": "Whether or not a validator has been tombstoned (killed out of validator\nset). It is set once the validator commits an equivocation or for any other\nconfigured misbehavior."
                        },
                        "missed_blocks_counter": {
                          "type": "string",
                          "description": "A counter of missed (unsigned) blocks. It is used to avoid unnecessary\nreads in the missed block bitmap.",
                          "format": "int64"
                        }
                      },
                      "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity."
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string"
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/staking/v1beta1/delegations/{delegator_addr}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "DelegatorDelegations queries all delegations of a given delegator address.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "DelegatorDelegations",
        "parameters": [
          {
            "name": "delegator_addr",
            "in": "path",
            "description": "delegator_addr defines the delegator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "delegation_responses": {
                      "type": "array",
                      "description": "delegation_responses defines all the delegations' info of a delegator.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "delegation": {
                            "type": "object",
                            "properties": {
                              "delegator_address": {
                                "type": "string",
                                "description": "delegator_address is the encoded address of the delegator."
                              },
                              "validator_address": {
                                "type": "string",
                                "description": "validator_address is the encoded address of the validator."
                              },
                              "shares": {
                                "type": "string",
                                "description": "shares define the delegation shares received."
                              }
                            },
                            "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
                          },
                          "balance": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string"
                              },
                              "amount": {
                                "type": "string"
                              }
                            },
                            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                          }
                        },
                        "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryDelegatorDelegationsResponse is response type for the\nQuery/DelegatorDelegations RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegator_addr}/redelegations": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Redelegations queries redelegations of given address.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "Redelegations",
        "parameters": [
          {
            "name": "delegator_addr",
            "in": "path",
            "description": "delegator_addr defines the delegator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "src_validator_addr",
            "in": "query",
            "description": "src_validator_addr defines the validator address to redelegate from.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "dst_validator_addr",
            "in": "query",
            "description": "dst_validator_addr defines the validator address to redelegate to.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "redelegation_responses": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "redelegation": {
                            "type": "object",
                            "properties": {
                              "delegator_address": {
                                "type": "string",
                                "description": "delegator_address is the bech32-encoded address of the delegator."
                              },
                              "validator_src_address": {
                                "type": "string",
                                "description": "validator_src_address is the validator redelegation source operator address."
                              },
                              "validator_dst_address": {
                                "type": "string",
                                "description": "validator_dst_address is the validator redelegation destination operator address."
                              },
                              "entries": {
                                "type": "array",
                                "description": "entries are the redelegation entries.",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "creation_height": {
                                      "type": "string",
                                      "description": "creation_height  defines the height which the redelegation took place.",
                                      "format": "int64"
                                    },
                                    "completion_time": {
                                      "type": "string",
                                      "description": "completion_time defines the unix time for redelegation completion.",
                                      "format": "date-time"
                                    },
                                    "initial_balance": {
                                      "type": "string",
                                      "description": "initial_balance defines the initial balance when redelegation started."
                                    },
                                    "shares_dst": {
                                      "type": "string",
                                      "description": "shares_dst is the amount of destination-validator shares created by redelegation."
                                    },
                                    "unbonding_id": {
                                      "title": "Incrementing id that uniquely identifies this entry",
                                      "type": "string",
                                      "format": "uint64"
                                    },
                                    "unbonding_on_hold_ref_count": {
                                      "title": "Strictly positive if this entry's unbonding has been stopped by external modules",
                                      "type": "string",
                                      "format": "int64"
                                    }
                                  },
                                  "description": "RedelegationEntry defines a redelegation object with relevant metadata."
                                }
                              }
                            },
                            "description": "Redelegation contains the list of a particular delegator's redelegating bonds\nfrom a particular source validator to a particular destination validator."
                          },
                          "entries": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "redelegation_entry": {
                                  "type": "object",
                                  "properties": {
                                    "creation_height": {
                                      "type": "string",
                                      "description": "creation_height  defines the height which the redelegation took place.",
                                      "format": "int64"
                                    },
                                    "completion_time": {
                                      "type": "string",
                                      "description": "completion_time defines the unix time for redelegation completion.",
                                      "format": "date-time"
                                    },
                                    "initial_balance": {
                                      "type": "string",
                                      "description": "initial_balance defines the initial balance when redelegation started."
                                    },
                                    "shares_dst": {
                                      "type": "string",
                                      "description": "shares_dst is the amount of destination-validator shares created by redelegation."
                                    },
                                    "unbonding_id": {
                                      "title": "Incrementing id that uniquely identifies this entry",
                                      "type": "string",
                                      "format": "uint64"
                                    },
                                    "unbonding_on_hold_ref_count": {
                                      "title": "Strictly positive if this entry's unbonding has been stopped by external modules",
                                      "type": "string",
                                      "format": "int64"
                                    }
                                  },
                                  "description": "RedelegationEntry defines a redelegation object with relevant metadata."
                                },
                                "balance": {
                                  "type": "string"
                                }
                              },
                              "description": "RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\ncontains a balance in addition to shares which is more suitable for client\nresponses."
                            }
                          }
                        },
                        "description": "RedelegationResponse is equivalent to a Redelegation except that its entries\ncontain a balance in addition to shares which is more suitable for client\nresponses."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryRedelegationsResponse is response type for the Query/Redelegations RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegator_addr}/unbonding_delegations": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "DelegatorUnbondingDelegations queries all unbonding delegations of a given\ndelegator address.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "DelegatorUnbondingDelegations",
        "parameters": [
          {
            "name": "delegator_addr",
            "in": "path",
            "description": "delegator_addr defines the delegator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "unbonding_responses": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "delegator_address": {
                            "type": "string",
                            "description": "delegator_address is the encoded address of the delegator."
                          },
                          "validator_address": {
                            "type": "string",
                            "description": "validator_address is the encoded address of the validator."
                          },
                          "entries": {
                            "type": "array",
                            "description": "entries are the unbonding delegation entries.",
                            "items": {
                              "type": "object",
                              "properties": {
                                "creation_height": {
                                  "type": "string",
                                  "description": "creation_height is the height which the unbonding took place.",
                                  "format": "int64"
                                },
                                "completion_time": {
                                  "type": "string",
                                  "description": "completion_time is the unix time for unbonding completion.",
                                  "format": "date-time"
                                },
                                "initial_balance": {
                                  "type": "string",
                                  "description": "initial_balance defines the tokens initially scheduled to receive at completion."
                                },
                                "balance": {
                                  "type": "string",
                                  "description": "balance defines the tokens to receive at completion."
                                },
                                "unbonding_id": {
                                  "title": "Incrementing id that uniquely identifies this entry",
                                  "type": "string",
                                  "format": "uint64"
                                },
                                "unbonding_on_hold_ref_count": {
                                  "title": "Strictly positive if this entry's unbonding has been stopped by external modules",
                                  "type": "string",
                                  "format": "int64"
                                }
                              },
                              "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
                            }
                          }
                        },
                        "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryUnbondingDelegatorDelegationsResponse is response type for the\nQuery/UnbondingDelegatorDelegations RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "DelegatorValidators queries all validators info for given delegator\naddress.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "DelegatorValidators",
        "parameters": [
          {
            "name": "delegator_addr",
            "in": "path",
            "description": "delegator_addr defines the delegator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "validators": {
                      "type": "array",
                      "description": "validators defines the validators' info of a delegator.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "operator_address": {
                            "type": "string",
                            "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
                          },
                          "consensus_pubkey": {
                            "type": "object",
                            "properties": {
                              "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                              },
                              "value": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "byte"
                              }
                            },
                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                          },
                          "jailed": {
                            "type": "boolean",
                            "description": "jailed defined whether the validator has been jailed from bonded status or not."
                          },
                          "status": {
                            "type": "string",
                            "description": "status is the validator status (bonded/unbonding/unbonded).",
                            "default": "BOND_STATUS_UNSPECIFIED",
                            "enum": [
                              "BOND_STATUS_UNSPECIFIED",
                              "BOND_STATUS_UNBONDED",
                              "BOND_STATUS_UNBONDING",
                              "BOND_STATUS_BONDED"
                            ]
                          },
                          "tokens": {
                            "type": "string",
                            "description": "tokens define the delegated tokens (incl. self-delegation)."
                          },
                          "delegator_shares": {
                            "type": "string",
                            "description": "delegator_shares defines total shares issued to a validator's delegators."
                          },
                          "description": {
                            "type": "object",
                            "properties": {
                              "moniker": {
                                "type": "string",
                                "description": "moniker defines a human-readable name for the validator."
                              },
                              "identity": {
                                "type": "string",
                                "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                              },
                              "website": {
                                "type": "string",
                                "description": "website defines an optional website link."
                              },
                              "security_contact": {
                                "type": "string",
                                "description": "security_contact defines an optional email for security contact."
                              },
                              "details": {
                                "type": "string",
                                "description": "details define other optional details."
                              }
                            },
                            "description": "description defines the description terms for the validator."
                          },
                          "unbonding_height": {
                            "type": "string",
                            "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                            "format": "int64"
                          },
                          "unbonding_time": {
                            "type": "string",
                            "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                            "format": "date-time"
                          },
                          "commission": {
                            "type": "object",
                            "properties": {
                              "commission_rates": {
                                "type": "object",
                                "properties": {
                                  "rate": {
                                    "type": "string",
                                    "description": "rate is the commission rate charged to delegators, as a fraction."
                                  },
                                  "max_rate": {
                                    "type": "string",
                                    "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                                  },
                                  "max_change_rate": {
                                    "type": "string",
                                    "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                                  }
                                },
                                "description": "commission_rates defines the initial commission rates to be used for creating a validator."
                              },
                              "update_time": {
                                "type": "string",
                                "description": "update_time is the last time the commission rate was changed.",
                                "format": "date-time"
                              }
                            },
                            "description": "commission defines the commission parameters."
                          },
                          "min_self_delegation": {
                            "type": "string",
                            "description": "min_self_delegation is the validator's self declared minimum self delegation.\n\nSince: cosmos-sdk 0.46"
                          },
                          "unbonding_on_hold_ref_count": {
                            "title": "strictly positive if this validator's unbonding has been stopped by external modules",
                            "type": "string",
                            "format": "int64"
                          },
                          "unbonding_ids": {
                            "title": "list of unbonding ids, each uniquely identifing an unbonding of this validator",
                            "type": "array",
                            "items": {
                              "type": "string",
                              "format": "uint64"
                            }
                          }
                        },
                        "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryDelegatorValidatorsResponse is response type for the\nQuery/DelegatorValidators RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/staking/v1beta1/delegators/{delegator_addr}/validators/{validator_addr}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "DelegatorValidator queries validator info for given delegator validator\npair.",
        "operationId": "DelegatorValidator",
        "parameters": [
          {
            "name": "delegator_addr",
            "in": "path",
            "description": "delegator_addr defines the delegator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "validator_addr",
            "in": "path",
            "description": "validator_addr defines the validator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "validator": {
                      "type": "object",
                      "properties": {
                        "operator_address": {
                          "type": "string",
                          "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
                        },
                        "consensus_pubkey": {
                          "type": "object",
                          "properties": {
                            "type_url": {
                              "type": "string",
                              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                            },
                            "value": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Must be a valid serialized protocol buffer of the above specified type.",
                              "format": "byte"
                            }
                          },
                          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                        },
                        "jailed": {
                          "type": "boolean",
                          "description": "jailed defined whether the validator has been jailed from bonded status or not."
                        },
                        "status": {
                          "type": "string",
                          "description": "status is the validator status (bonded/unbonding/unbonded).",
                          "default": "BOND_STATUS_UNSPECIFIED",
                          "enum": [
                            "BOND_STATUS_UNSPECIFIED",
                            "BOND_STATUS_UNBONDED",
                            "BOND_STATUS_UNBONDING",
                            "BOND_STATUS_BONDED"
                          ]
                        },
                        "tokens": {
                          "type": "string",
                          "description": "tokens define the delegated tokens (incl. self-delegation)."
                        },
                        "delegator_shares": {
                          "type": "string",
                          "description": "delegator_shares defines total shares issued to a validator's delegators."
                        },
                        "description": {
                          "type": "object",
                          "properties": {
                            "moniker": {
                              "type": "string",
                              "description": "moniker defines a human-readable name for the validator."
                            },
                            "identity": {
                              "type": "string",
                              "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                            },
                            "website": {
                              "type": "string",
                              "description": "website defines an optional website link."
                            },
                            "security_contact": {
                              "type": "string",
                              "description": "security_contact defines an optional email for security contact."
                            },
                            "details": {
                              "type": "string",
                              "description": "details define other optional details."
                            }
                          },
                          "description": "description defines the description terms for the validator."
                        },
                        "unbonding_height": {
                          "type": "string",
                          "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                          "format": "int64"
                        },
                        "unbonding_time": {
                          "type": "string",
                          "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                          "format": "date-time"
                        },
                        "commission": {
                          "type": "object",
                          "properties": {
                            "commission_rates": {
                              "type": "object",
                              "properties": {
                                "rate": {
                                  "type": "string",
                                  "description": "rate is the commission rate charged to delegators, as a fraction."
                                },
                                "max_rate": {
                                  "type": "string",
                                  "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                                },
                                "max_change_rate": {
                                  "type": "string",
                                  "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                                }
                              },
                              "description": "commission_rates defines the initial commission rates to be used for creating a validator."
                            },
                            "update_time": {
                              "type": "string",
                              "description": "update_time is the last time the commission rate was changed.",
                              "format": "date-time"
                            }
                          },
                          "description": "commission defines the commission parameters."
                        },
                        "min_self_delegation": {
                          "type": "string",
                          "description": "min_self_delegation is the validator's self declared minimum self delegation.\n\nSince: cosmos-sdk 0.46"
                        },
                        "unbonding_on_hold_ref_count": {
                          "title": "strictly positive if this validator's unbonding has been stopped by external modules",
                          "type": "string",
                          "format": "int64"
                        },
                        "unbonding_ids": {
                          "title": "list of unbonding ids, each uniquely identifing an unbonding of this validator",
                          "type": "array",
                          "items": {
                            "type": "string",
                            "format": "uint64"
                          }
                        }
                      },
                      "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
                    }
                  },
                  "description": "QueryDelegatorValidatorResponse response type for the\nQuery/DelegatorValidator RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/staking/v1beta1/historical_info/{height}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "HistoricalInfo queries the historical info for given height.",
        "operationId": "HistoricalInfo",
        "parameters": [
          {
            "name": "height",
            "in": "path",
            "description": "height defines at which height to query the historical info.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "hist": {
                      "type": "object",
                      "properties": {
                        "header": {
                          "type": "object",
                          "properties": {
                            "version": {
                              "title": "basic block info",
                              "type": "object",
                              "properties": {
                                "block": {
                                  "type": "string",
                                  "format": "uint64"
                                },
                                "app": {
                                  "type": "string",
                                  "format": "uint64"
                                }
                              },
                              "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                            },
                            "chain_id": {
                              "type": "string"
                            },
                            "height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "time": {
                              "type": "string",
                              "format": "date-time"
                            },
                            "last_block_id": {
                              "title": "prev block info",
                              "type": "object",
                              "properties": {
                                "hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "part_set_header": {
                                  "title": "PartsetHeader",
                                  "type": "object",
                                  "properties": {
                                    "total": {
                                      "type": "integer",
                                      "format": "int64"
                                    },
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  }
                                }
                              }
                            },
                            "last_commit_hash": {
                              "title": "hashes of block data",
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "data_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "validators_hash": {
                              "title": "hashes from the app output from the prev block",
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "next_validators_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "consensus_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "app_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "last_results_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "evidence_hash": {
                              "title": "consensus info",
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "proposer_address": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            }
                          },
                          "description": "Header defines the structure of a block header."
                        },
                        "valset": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "operator_address": {
                                "type": "string",
                                "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
                              },
                              "consensus_pubkey": {
                                "type": "object",
                                "properties": {
                                  "type_url": {
                                    "type": "string",
                                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                                  },
                                  "value": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                    "format": "byte"
                                  }
                                },
                                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                              },
                              "jailed": {
                                "type": "boolean",
                                "description": "jailed defined whether the validator has been jailed from bonded status or not."
                              },
                              "status": {
                                "type": "string",
                                "description": "status is the validator status (bonded/unbonding/unbonded).",
                                "default": "BOND_STATUS_UNSPECIFIED",
                                "enum": [
                                  "BOND_STATUS_UNSPECIFIED",
                                  "BOND_STATUS_UNBONDED",
                                  "BOND_STATUS_UNBONDING",
                                  "BOND_STATUS_BONDED"
                                ]
                              },
                              "tokens": {
                                "type": "string",
                                "description": "tokens define the delegated tokens (incl. self-delegation)."
                              },
                              "delegator_shares": {
                                "type": "string",
                                "description": "delegator_shares defines total shares issued to a validator's delegators."
                              },
                              "description": {
                                "type": "object",
                                "properties": {
                                  "moniker": {
                                    "type": "string",
                                    "description": "moniker defines a human-readable name for the validator."
                                  },
                                  "identity": {
                                    "type": "string",
                                    "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                                  },
                                  "website": {
                                    "type": "string",
                                    "description": "website defines an optional website link."
                                  },
                                  "security_contact": {
                                    "type": "string",
                                    "description": "security_contact defines an optional email for security contact."
                                  },
                                  "details": {
                                    "type": "string",
                                    "description": "details define other optional details."
                                  }
                                },
                                "description": "description defines the description terms for the validator."
                              },
                              "unbonding_height": {
                                "type": "string",
                                "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                                "format": "int64"
                              },
                              "unbonding_time": {
                                "type": "string",
                                "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                                "format": "date-time"
                              },
                              "commission": {
                                "type": "object",
                                "properties": {
                                  "commission_rates": {
                                    "type": "object",
                                    "properties": {
                                      "rate": {
                                        "type": "string",
                                        "description": "rate is the commission rate charged to delegators, as a fraction."
                                      },
                                      "max_rate": {
                                        "type": "string",
                                        "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                                      },
                                      "max_change_rate": {
                                        "type": "string",
                                        "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                                      }
                                    },
                                    "description": "commission_rates defines the initial commission rates to be used for creating a validator."
                                  },
                                  "update_time": {
                                    "type": "string",
                                    "description": "update_time is the last time the commission rate was changed.",
                                    "format": "date-time"
                                  }
                                },
                                "description": "commission defines the commission parameters."
                              },
                              "min_self_delegation": {
                                "type": "string",
                                "description": "min_self_delegation is the validator's self declared minimum self delegation.\n\nSince: cosmos-sdk 0.46"
                              },
                              "unbonding_on_hold_ref_count": {
                                "title": "strictly positive if this validator's unbonding has been stopped by external modules",
                                "type": "string",
                                "format": "int64"
                              },
                              "unbonding_ids": {
                                "title": "list of unbonding ids, each uniquely identifing an unbonding of this validator",
                                "type": "array",
                                "items": {
                                  "type": "string",
                                  "format": "uint64"
                                }
                              }
                            },
                            "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
                          }
                        }
                      },
                      "description": "hist defines the historical info at the given height."
                    }
                  },
                  "description": "QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC\nmethod."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/staking/v1beta1/params": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Parameters queries the staking parameters.",
        "operationId": "StakingParams",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "params": {
                      "type": "object",
                      "properties": {
                        "unbonding_time": {
                          "type": "string",
                          "description": "unbonding_time is the time duration of unbonding."
                        },
                        "max_validators": {
                          "type": "integer",
                          "description": "max_validators is the maximum number of validators.",
                          "format": "int64"
                        },
                        "max_entries": {
                          "type": "integer",
                          "description": "max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).",
                          "format": "int64"
                        },
                        "historical_entries": {
                          "type": "integer",
                          "description": "historical_entries is the number of historical entries to persist.",
                          "format": "int64"
                        },
                        "bond_denom": {
                          "type": "string",
                          "description": "bond_denom defines the bondable coin denomination."
                        },
                        "min_commission_rate": {
                          "title": "min_commission_rate is the chain-wide minimum commission rate that a validator can charge their delegators",
                          "type": "string"
                        }
                      },
                      "description": "params holds all the parameters of this module."
                    }
                  },
                  "description": "QueryParamsResponse is response type for the Query/Params RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/staking/v1beta1/pool": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Pool queries the pool info.",
        "operationId": "Pool",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "pool": {
                      "type": "object",
                      "properties": {
                        "not_bonded_tokens": {
                          "type": "string"
                        },
                        "bonded_tokens": {
                          "type": "string"
                        }
                      },
                      "description": "pool defines the pool info."
                    }
                  },
                  "description": "QueryPoolResponse is response type for the Query/Pool RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/staking/v1beta1/validators": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Validators queries all validators that match the given status.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "Validators",
        "parameters": [
          {
            "name": "status",
            "in": "query",
            "description": "status enables to query for validators matching a given status.",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryValidatorsResponse is response type for the Query/Validators RPC method",
                  "type": "object",
                  "properties": {
                    "validators": {
                      "type": "array",
                      "description": "validators contains all the queried validators.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "operator_address": {
                            "type": "string",
                            "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
                          },
                          "consensus_pubkey": {
                            "type": "object",
                            "properties": {
                              "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                              },
                              "value": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "byte"
                              }
                            },
                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                          },
                          "jailed": {
                            "type": "boolean",
                            "description": "jailed defined whether the validator has been jailed from bonded status or not."
                          },
                          "status": {
                            "type": "string",
                            "description": "status is the validator status (bonded/unbonding/unbonded).",
                            "default": "BOND_STATUS_UNSPECIFIED",
                            "enum": [
                              "BOND_STATUS_UNSPECIFIED",
                              "BOND_STATUS_UNBONDED",
                              "BOND_STATUS_UNBONDING",
                              "BOND_STATUS_BONDED"
                            ]
                          },
                          "tokens": {
                            "type": "string",
                            "description": "tokens define the delegated tokens (incl. self-delegation)."
                          },
                          "delegator_shares": {
                            "type": "string",
                            "description": "delegator_shares defines total shares issued to a validator's delegators."
                          },
                          "description": {
                            "type": "object",
                            "properties": {
                              "moniker": {
                                "type": "string",
                                "description": "moniker defines a human-readable name for the validator."
                              },
                              "identity": {
                                "type": "string",
                                "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                              },
                              "website": {
                                "type": "string",
                                "description": "website defines an optional website link."
                              },
                              "security_contact": {
                                "type": "string",
                                "description": "security_contact defines an optional email for security contact."
                              },
                              "details": {
                                "type": "string",
                                "description": "details define other optional details."
                              }
                            },
                            "description": "description defines the description terms for the validator."
                          },
                          "unbonding_height": {
                            "type": "string",
                            "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                            "format": "int64"
                          },
                          "unbonding_time": {
                            "type": "string",
                            "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                            "format": "date-time"
                          },
                          "commission": {
                            "type": "object",
                            "properties": {
                              "commission_rates": {
                                "type": "object",
                                "properties": {
                                  "rate": {
                                    "type": "string",
                                    "description": "rate is the commission rate charged to delegators, as a fraction."
                                  },
                                  "max_rate": {
                                    "type": "string",
                                    "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                                  },
                                  "max_change_rate": {
                                    "type": "string",
                                    "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                                  }
                                },
                                "description": "commission_rates defines the initial commission rates to be used for creating a validator."
                              },
                              "update_time": {
                                "type": "string",
                                "description": "update_time is the last time the commission rate was changed.",
                                "format": "date-time"
                              }
                            },
                            "description": "commission defines the commission parameters."
                          },
                          "min_self_delegation": {
                            "type": "string",
                            "description": "min_self_delegation is the validator's self declared minimum self delegation.\n\nSince: cosmos-sdk 0.46"
                          },
                          "unbonding_on_hold_ref_count": {
                            "title": "strictly positive if this validator's unbonding has been stopped by external modules",
                            "type": "string",
                            "format": "int64"
                          },
                          "unbonding_ids": {
                            "title": "list of unbonding ids, each uniquely identifing an unbonding of this validator",
                            "type": "array",
                            "items": {
                              "type": "string",
                              "format": "uint64"
                            }
                          }
                        },
                        "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/staking/v1beta1/validators/{validator_addr}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Validator queries validator info for given validator address.",
        "operationId": "Validator",
        "parameters": [
          {
            "name": "validator_addr",
            "in": "path",
            "description": "validator_addr defines the validator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryValidatorResponse is response type for the Query/Validator RPC method",
                  "type": "object",
                  "properties": {
                    "validator": {
                      "type": "object",
                      "properties": {
                        "operator_address": {
                          "type": "string",
                          "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
                        },
                        "consensus_pubkey": {
                          "type": "object",
                          "properties": {
                            "type_url": {
                              "type": "string",
                              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                            },
                            "value": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Must be a valid serialized protocol buffer of the above specified type.",
                              "format": "byte"
                            }
                          },
                          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                        },
                        "jailed": {
                          "type": "boolean",
                          "description": "jailed defined whether the validator has been jailed from bonded status or not."
                        },
                        "status": {
                          "type": "string",
                          "description": "status is the validator status (bonded/unbonding/unbonded).",
                          "default": "BOND_STATUS_UNSPECIFIED",
                          "enum": [
                            "BOND_STATUS_UNSPECIFIED",
                            "BOND_STATUS_UNBONDED",
                            "BOND_STATUS_UNBONDING",
                            "BOND_STATUS_BONDED"
                          ]
                        },
                        "tokens": {
                          "type": "string",
                          "description": "tokens define the delegated tokens (incl. self-delegation)."
                        },
                        "delegator_shares": {
                          "type": "string",
                          "description": "delegator_shares defines total shares issued to a validator's delegators."
                        },
                        "description": {
                          "type": "object",
                          "properties": {
                            "moniker": {
                              "type": "string",
                              "description": "moniker defines a human-readable name for the validator."
                            },
                            "identity": {
                              "type": "string",
                              "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                            },
                            "website": {
                              "type": "string",
                              "description": "website defines an optional website link."
                            },
                            "security_contact": {
                              "type": "string",
                              "description": "security_contact defines an optional email for security contact."
                            },
                            "details": {
                              "type": "string",
                              "description": "details define other optional details."
                            }
                          },
                          "description": "description defines the description terms for the validator."
                        },
                        "unbonding_height": {
                          "type": "string",
                          "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                          "format": "int64"
                        },
                        "unbonding_time": {
                          "type": "string",
                          "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                          "format": "date-time"
                        },
                        "commission": {
                          "type": "object",
                          "properties": {
                            "commission_rates": {
                              "type": "object",
                              "properties": {
                                "rate": {
                                  "type": "string",
                                  "description": "rate is the commission rate charged to delegators, as a fraction."
                                },
                                "max_rate": {
                                  "type": "string",
                                  "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                                },
                                "max_change_rate": {
                                  "type": "string",
                                  "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                                }
                              },
                              "description": "commission_rates defines the initial commission rates to be used for creating a validator."
                            },
                            "update_time": {
                              "type": "string",
                              "description": "update_time is the last time the commission rate was changed.",
                              "format": "date-time"
                            }
                          },
                          "description": "commission defines the commission parameters."
                        },
                        "min_self_delegation": {
                          "type": "string",
                          "description": "min_self_delegation is the validator's self declared minimum self delegation.\n\nSince: cosmos-sdk 0.46"
                        },
                        "unbonding_on_hold_ref_count": {
                          "title": "strictly positive if this validator's unbonding has been stopped by external modules",
                          "type": "string",
                          "format": "int64"
                        },
                        "unbonding_ids": {
                          "title": "list of unbonding ids, each uniquely identifing an unbonding of this validator",
                          "type": "array",
                          "items": {
                            "type": "string",
                            "format": "uint64"
                          }
                        }
                      },
                      "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ValidatorDelegations queries delegate info for given validator.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "ValidatorDelegations",
        "parameters": [
          {
            "name": "validator_addr",
            "in": "path",
            "description": "validator_addr defines the validator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "title": "QueryValidatorDelegationsResponse is response type for the\nQuery/ValidatorDelegations RPC method",
                  "type": "object",
                  "properties": {
                    "delegation_responses": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "delegation": {
                            "type": "object",
                            "properties": {
                              "delegator_address": {
                                "type": "string",
                                "description": "delegator_address is the encoded address of the delegator."
                              },
                              "validator_address": {
                                "type": "string",
                                "description": "validator_address is the encoded address of the validator."
                              },
                              "shares": {
                                "type": "string",
                                "description": "shares define the delegation shares received."
                              }
                            },
                            "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
                          },
                          "balance": {
                            "type": "object",
                            "properties": {
                              "denom": {
                                "type": "string"
                              },
                              "amount": {
                                "type": "string"
                              }
                            },
                            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                          }
                        },
                        "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  }
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "Delegation queries delegate info for given validator delegator pair.",
        "operationId": "Delegation",
        "parameters": [
          {
            "name": "validator_addr",
            "in": "path",
            "description": "validator_addr defines the validator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "delegator_addr",
            "in": "path",
            "description": "delegator_addr defines the delegator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "delegation_response": {
                      "type": "object",
                      "properties": {
                        "delegation": {
                          "type": "object",
                          "properties": {
                            "delegator_address": {
                              "type": "string",
                              "description": "delegator_address is the encoded address of the delegator."
                            },
                            "validator_address": {
                              "type": "string",
                              "description": "validator_address is the encoded address of the validator."
                            },
                            "shares": {
                              "type": "string",
                              "description": "shares define the delegation shares received."
                            }
                          },
                          "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
                        },
                        "balance": {
                          "type": "object",
                          "properties": {
                            "denom": {
                              "type": "string"
                            },
                            "amount": {
                              "type": "string"
                            }
                          },
                          "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                        }
                      },
                      "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses."
                    }
                  },
                  "description": "QueryDelegationResponse is response type for the Query/Delegation RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/staking/v1beta1/validators/{validator_addr}/delegations/{delegator_addr}/unbonding_delegation": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "UnbondingDelegation queries unbonding info for given validator delegator\npair.",
        "operationId": "UnbondingDelegation",
        "parameters": [
          {
            "name": "validator_addr",
            "in": "path",
            "description": "validator_addr defines the validator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "delegator_addr",
            "in": "path",
            "description": "delegator_addr defines the delegator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "unbond": {
                      "type": "object",
                      "properties": {
                        "delegator_address": {
                          "type": "string",
                          "description": "delegator_address is the encoded address of the delegator."
                        },
                        "validator_address": {
                          "type": "string",
                          "description": "validator_address is the encoded address of the validator."
                        },
                        "entries": {
                          "type": "array",
                          "description": "entries are the unbonding delegation entries.",
                          "items": {
                            "type": "object",
                            "properties": {
                              "creation_height": {
                                "type": "string",
                                "description": "creation_height is the height which the unbonding took place.",
                                "format": "int64"
                              },
                              "completion_time": {
                                "type": "string",
                                "description": "completion_time is the unix time for unbonding completion.",
                                "format": "date-time"
                              },
                              "initial_balance": {
                                "type": "string",
                                "description": "initial_balance defines the tokens initially scheduled to receive at completion."
                              },
                              "balance": {
                                "type": "string",
                                "description": "balance defines the tokens to receive at completion."
                              },
                              "unbonding_id": {
                                "title": "Incrementing id that uniquely identifies this entry",
                                "type": "string",
                                "format": "uint64"
                              },
                              "unbonding_on_hold_ref_count": {
                                "title": "Strictly positive if this entry's unbonding has been stopped by external modules",
                                "type": "string",
                                "format": "int64"
                              }
                            },
                            "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
                          }
                        }
                      },
                      "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
                    }
                  },
                  "description": "QueryDelegationResponse is response type for the Query/UnbondingDelegation\nRPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/staking/v1beta1/validators/{validator_addr}/unbonding_delegations": {
      "get": {
        "tags": [
          "Query"
        ],
        "summary": "ValidatorUnbondingDelegations queries unbonding delegations of a validator.",
        "description": "When called from another module, this query might consume a high amount of\ngas if the pagination field is incorrectly set.",
        "operationId": "ValidatorUnbondingDelegations",
        "parameters": [
          {
            "name": "validator_addr",
            "in": "path",
            "description": "validator_addr defines the validator address to query for.",
            "required": true,
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "unbonding_responses": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "delegator_address": {
                            "type": "string",
                            "description": "delegator_address is the encoded address of the delegator."
                          },
                          "validator_address": {
                            "type": "string",
                            "description": "validator_address is the encoded address of the validator."
                          },
                          "entries": {
                            "type": "array",
                            "description": "entries are the unbonding delegation entries.",
                            "items": {
                              "type": "object",
                              "properties": {
                                "creation_height": {
                                  "type": "string",
                                  "description": "creation_height is the height which the unbonding took place.",
                                  "format": "int64"
                                },
                                "completion_time": {
                                  "type": "string",
                                  "description": "completion_time is the unix time for unbonding completion.",
                                  "format": "date-time"
                                },
                                "initial_balance": {
                                  "type": "string",
                                  "description": "initial_balance defines the tokens initially scheduled to receive at completion."
                                },
                                "balance": {
                                  "type": "string",
                                  "description": "balance defines the tokens to receive at completion."
                                },
                                "unbonding_id": {
                                  "title": "Incrementing id that uniquely identifies this entry",
                                  "type": "string",
                                  "format": "uint64"
                                },
                                "unbonding_on_hold_ref_count": {
                                  "title": "Strictly positive if this entry's unbonding has been stopped by external modules",
                                  "type": "string",
                                  "format": "int64"
                                }
                              },
                              "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
                            }
                          }
                        },
                        "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines the pagination in the response."
                    }
                  },
                  "description": "QueryValidatorUnbondingDelegationsResponse is response type for the\nQuery/ValidatorUnbondingDelegations RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/tx/v1beta1/decode": {
      "post": {
        "tags": [
          "Service"
        ],
        "summary": "TxDecode decodes the transaction.",
        "description": "Since: cosmos-sdk 0.47",
        "operationId": "TxDecode",
        "requestBody": {
          "content": {
            "*/*": {
              "schema": {
                "type": "object",
                "properties": {
                  "tx_bytes": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "description": "tx_bytes is the raw transaction.",
                    "format": "byte"
                  }
                },
                "description": "TxDecodeRequest is the request type for the Service.TxDecode\nRPC method.\n\nSince: cosmos-sdk 0.47"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/cosmos.tx.v1beta1.TxDecodeResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/cosmos/tx/v1beta1/decode/amino": {
      "post": {
        "tags": [
          "Service"
        ],
        "summary": "TxDecodeAmino decodes an Amino transaction from encoded bytes to JSON.",
        "description": "Since: cosmos-sdk 0.47",
        "operationId": "TxDecodeAmino",
        "requestBody": {
          "content": {
            "*/*": {
              "schema": {
                "type": "object",
                "properties": {
                  "amino_binary": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  }
                },
                "description": "TxDecodeAminoRequest is the request type for the Service.TxDecodeAmino\nRPC method.\n\nSince: cosmos-sdk 0.47"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "amino_json": {
                      "type": "string"
                    }
                  },
                  "description": "TxDecodeAminoResponse is the response type for the Service.TxDecodeAmino\nRPC method.\n\nSince: cosmos-sdk 0.47"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/cosmos/tx/v1beta1/encode": {
      "post": {
        "tags": [
          "Service"
        ],
        "summary": "TxEncode encodes the transaction.",
        "description": "Since: cosmos-sdk 0.47",
        "operationId": "TxEncode",
        "requestBody": {
          "content": {
            "*/*": {
              "schema": {
                "$ref": "#/components/schemas/cosmos.tx.v1beta1.TxEncodeRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "tx_bytes": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "tx_bytes is the encoded transaction bytes.",
                      "format": "byte"
                    }
                  },
                  "description": "TxEncodeResponse is the response type for the\nService.TxEncode method.\n\nSince: cosmos-sdk 0.47"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/cosmos/tx/v1beta1/encode/amino": {
      "post": {
        "tags": [
          "Service"
        ],
        "summary": "TxEncodeAmino encodes an Amino transaction from JSON to encoded bytes.",
        "description": "Since: cosmos-sdk 0.47",
        "operationId": "TxEncodeAmino",
        "requestBody": {
          "content": {
            "*/*": {
              "schema": {
                "type": "object",
                "properties": {
                  "amino_json": {
                    "type": "string"
                  }
                },
                "description": "TxEncodeAminoRequest is the request type for the Service.TxEncodeAmino\nRPC method.\n\nSince: cosmos-sdk 0.47"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "amino_binary": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "description": "TxEncodeAminoResponse is the response type for the Service.TxEncodeAmino\nRPC method.\n\nSince: cosmos-sdk 0.47"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/cosmos/tx/v1beta1/simulate": {
      "post": {
        "tags": [
          "Service"
        ],
        "summary": "Simulate simulates executing a transaction for estimating gas usage.",
        "operationId": "Simulate",
        "requestBody": {
          "content": {
            "*/*": {
              "schema": {
                "$ref": "#/components/schemas/cosmos.tx.v1beta1.SimulateRequest"
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "gas_info": {
                      "type": "object",
                      "properties": {
                        "gas_wanted": {
                          "type": "string",
                          "description": "GasWanted is the maximum units of work we allow this tx to perform.",
                          "format": "uint64"
                        },
                        "gas_used": {
                          "type": "string",
                          "description": "GasUsed is the amount of gas actually consumed.",
                          "format": "uint64"
                        }
                      },
                      "description": "gas_info is the information about gas used in the simulation."
                    },
                    "result": {
                      "type": "object",
                      "properties": {
                        "data": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Data is any data returned from message or handler execution. It MUST be\nlength prefixed in order to separate data from multiple message executions.\nDeprecated. This field is still populated, but prefer msg_response instead\nbecause it also contains the Msg response typeURL.",
                          "format": "byte"
                        },
                        "log": {
                          "type": "string",
                          "description": "Log contains the log information from message or handler execution."
                        },
                        "events": {
                          "type": "array",
                          "description": "Events contains a slice of Event objects that were emitted during message\nor handler execution.",
                          "items": {
                            "type": "object",
                            "properties": {
                              "type": {
                                "type": "string"
                              },
                              "attributes": {
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "key": {
                                      "type": "string"
                                    },
                                    "value": {
                                      "type": "string"
                                    },
                                    "index": {
                                      "type": "boolean"
                                    }
                                  },
                                  "description": "EventAttribute is a single key-value pair, associated with an event."
                                }
                              }
                            },
                            "description": "Event allows application developers to attach additional information to\nResponseFinalizeBlock and ResponseCheckTx.\nLater, transactions may be queried using these events."
                          }
                        },
                        "msg_responses": {
                          "type": "array",
                          "description": "msg_responses contains the Msg handler responses type packed in Anys.\n\nSince: cosmos-sdk 0.46",
                          "items": {
                            "type": "object",
                            "properties": {
                              "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                              },
                              "value": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "byte"
                              }
                            },
                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                          }
                        }
                      },
                      "description": "result is the result of the simulation."
                    }
                  },
                  "description": "SimulateResponse is the response type for the\nService.SimulateRPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/cosmos/tx/v1beta1/txs": {
      "get": {
        "tags": [
          "Service"
        ],
        "summary": "GetTxsEvent fetches txs by event.",
        "operationId": "GetTxsEvent",
        "parameters": [
          {
            "name": "events",
            "in": "query",
            "description": "events is the list of transaction event type.\nDeprecated post v0.47.x: use query instead, which should contain a valid\nevents query.",
            "style": "form",
            "explode": true,
            "schema": {
              "type": "array",
              "items": {
                "type": "string"
              }
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "order_by",
            "in": "query",
            "description": " - ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults\nto ASC in this case.\n - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order\n - ORDER_BY_DESC: ORDER_BY_DESC defines descending order",
            "schema": {
              "type": "string",
              "default": "ORDER_BY_UNSPECIFIED",
              "enum": [
                "ORDER_BY_UNSPECIFIED",
                "ORDER_BY_ASC",
                "ORDER_BY_DESC"
              ]
            }
          },
          {
            "name": "page",
            "in": "query",
            "description": "page is the page number to query, starts at 1. If not provided, will\ndefault to first page.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "query",
            "in": "query",
            "description": "query defines the transaction event query that is proxied to Tendermint's\nTxSearch RPC method. The query must be valid.\n\nSince cosmos-sdk 0.50",
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/cosmos.tx.v1beta1.GetTxsEventResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      },
      "post": {
        "tags": [
          "Service"
        ],
        "summary": "BroadcastTx broadcast transaction.",
        "operationId": "BroadcastTx",
        "requestBody": {
          "content": {
            "*/*": {
              "schema": {
                "type": "object",
                "properties": {
                  "tx_bytes": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "description": "tx_bytes is the raw transaction.",
                    "format": "byte"
                  },
                  "mode": {
                    "type": "string",
                    "description": "BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC\nmethod.\n\n - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering\n - BROADCAST_MODE_BLOCK: DEPRECATED: use BROADCAST_MODE_SYNC instead,\nBROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.\n - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits\nfor a CheckTx execution response only.\n - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client\nreturns immediately.",
                    "default": "BROADCAST_MODE_UNSPECIFIED",
                    "enum": [
                      "BROADCAST_MODE_UNSPECIFIED",
                      "BROADCAST_MODE_BLOCK",
                      "BROADCAST_MODE_SYNC",
                      "BROADCAST_MODE_ASYNC"
                    ]
                  }
                },
                "description": "BroadcastTxRequest is the request type for the Service.BroadcastTxRequest\nRPC method."
              }
            }
          },
          "required": true
        },
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "tx_response": {
                      "type": "object",
                      "properties": {
                        "height": {
                          "title": "The block height",
                          "type": "string",
                          "format": "int64"
                        },
                        "txhash": {
                          "type": "string",
                          "description": "The transaction hash."
                        },
                        "codespace": {
                          "title": "Namespace for the Code",
                          "type": "string"
                        },
                        "code": {
                          "type": "integer",
                          "description": "Response code.",
                          "format": "int64"
                        },
                        "data": {
                          "type": "string",
                          "description": "Result bytes, if any."
                        },
                        "raw_log": {
                          "type": "string",
                          "description": "The output of the application's logger (raw string). May be\nnon-deterministic."
                        },
                        "logs": {
                          "type": "array",
                          "description": "The output of the application's logger (typed). May be non-deterministic.",
                          "items": {
                            "type": "object",
                            "properties": {
                              "msg_index": {
                                "type": "integer",
                                "format": "int64"
                              },
                              "log": {
                                "type": "string"
                              },
                              "events": {
                                "type": "array",
                                "description": "Events contains a slice of Event objects that were emitted during some\nexecution.",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "type": {
                                      "type": "string"
                                    },
                                    "attributes": {
                                      "type": "array",
                                      "items": {
                                        "type": "object",
                                        "properties": {
                                          "key": {
                                            "type": "string"
                                          },
                                          "value": {
                                            "type": "string"
                                          }
                                        },
                                        "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
                                      }
                                    }
                                  },
                                  "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
                                }
                              }
                            },
                            "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log."
                          }
                        },
                        "info": {
                          "type": "string",
                          "description": "Additional information. May be non-deterministic."
                        },
                        "gas_wanted": {
                          "type": "string",
                          "description": "Amount of gas requested for transaction.",
                          "format": "int64"
                        },
                        "gas_used": {
                          "type": "string",
                          "description": "Amount of gas consumed by transaction.",
                          "format": "int64"
                        },
                        "tx": {
                          "type": "object",
                          "properties": {
                            "type_url": {
                              "type": "string",
                              "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                            },
                            "value": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Must be a valid serialized protocol buffer of the above specified type.",
                              "format": "byte"
                            }
                          },
                          "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                        },
                        "timestamp": {
                          "type": "string",
                          "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time."
                        },
                        "events": {
                          "type": "array",
                          "description": "Events defines all the events emitted by processing a transaction. Note,\nthese events include those emitted by processing all the messages and those\nemitted from the ante. Whereas Logs contains the events, with\nadditional metadata, emitted only by processing the messages.\n\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45",
                          "items": {
                            "type": "object",
                            "properties": {
                              "type": {
                                "type": "string"
                              },
                              "attributes": {
                                "type": "array",
                                "items": {
                                  "type": "object",
                                  "properties": {
                                    "key": {
                                      "type": "string"
                                    },
                                    "value": {
                                      "type": "string"
                                    },
                                    "index": {
                                      "type": "boolean"
                                    }
                                  },
                                  "description": "EventAttribute is a single key-value pair, associated with an event."
                                }
                              }
                            },
                            "description": "Event allows application developers to attach additional information to\nResponseFinalizeBlock and ResponseCheckTx.\nLater, transactions may be queried using these events."
                          }
                        }
                      },
                      "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded."
                    }
                  },
                  "description": "BroadcastTxResponse is the response type for the\nService.BroadcastTx method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        },
        "x-codegen-request-body-name": "body"
      }
    },
    "/cosmos/tx/v1beta1/txs/block/{height}": {
      "get": {
        "tags": [
          "Service"
        ],
        "summary": "GetBlockWithTxs fetches a block with decoded txs.",
        "description": "Since: cosmos-sdk 0.45.2",
        "operationId": "GetBlockWithTxs",
        "parameters": [
          {
            "name": "height",
            "in": "path",
            "description": "height is the height of the block to query.",
            "required": true,
            "schema": {
              "type": "string",
              "format": "int64"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/cosmos.tx.v1beta1.GetBlockWithTxsResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/tx/v1beta1/txs/{hash}": {
      "get": {
        "tags": [
          "Service"
        ],
        "summary": "GetTx fetches a tx by hash.",
        "operationId": "GetTx",
        "parameters": [
          {
            "name": "hash",
            "in": "path",
            "description": "hash is the tx hash to query, encoded as a hex string.",
            "required": true,
            "schema": {
              "type": "string"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "$ref": "#/components/schemas/cosmos.tx.v1beta1.GetTxResponse"
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/base/tendermint/v1beta1/abci_query": {
      "get": {
        "tags": [
          "Service"
        ],
        "summary": "ABCIQuery defines a query handler that supports ABCI queries directly to the\napplication, bypassing Tendermint completely. The ABCI query must contain\na valid and supported path, including app, custom, p2p, and store.",
        "description": "Since: cosmos-sdk 0.46",
        "operationId": "ABCIQuery",
        "parameters": [
          {
            "name": "data",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "path",
            "in": "query",
            "schema": {
              "type": "string"
            }
          },
          {
            "name": "height",
            "in": "query",
            "schema": {
              "type": "string",
              "format": "int64"
            }
          },
          {
            "name": "prove",
            "in": "query",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "code": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "log": {
                      "type": "string"
                    },
                    "info": {
                      "type": "string"
                    },
                    "index": {
                      "type": "string",
                      "format": "int64"
                    },
                    "key": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "proof_ops": {
                      "type": "object",
                      "properties": {
                        "ops": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "type": {
                                "type": "string"
                              },
                              "key": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "format": "byte"
                              },
                              "data": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "format": "byte"
                              }
                            },
                            "description": "ProofOp defines an operation used for calculating Merkle root. The data could\nbe arbitrary format, providing necessary data for example neighbouring node\nhash.\n\nNote: This type is a duplicate of the ProofOp proto type defined in Tendermint."
                          }
                        }
                      },
                      "description": "ProofOps is Merkle proof defined by the list of ProofOps.\n\nNote: This type is a duplicate of the ProofOps proto type defined in Tendermint."
                    },
                    "height": {
                      "type": "string",
                      "format": "int64"
                    },
                    "codespace": {
                      "type": "string"
                    }
                  },
                  "description": "ABCIQueryResponse defines the response structure for the ABCIQuery gRPC query.\n\nNote: This type is a duplicate of the ResponseQuery proto type defined in\nTendermint."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/base/tendermint/v1beta1/blocks/latest": {
      "get": {
        "tags": [
          "Service"
        ],
        "summary": "GetLatestBlock returns the latest block.",
        "operationId": "GetLatestBlock",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "block_id": {
                      "title": "BlockID",
                      "type": "object",
                      "properties": {
                        "hash": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        },
                        "part_set_header": {
                          "title": "PartsetHeader",
                          "type": "object",
                          "properties": {
                            "total": {
                              "type": "integer",
                              "format": "int64"
                            },
                            "hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            }
                          }
                        }
                      }
                    },
                    "block": {
                      "title": "Deprecated: please use `sdk_block` instead",
                      "type": "object",
                      "properties": {
                        "header": {
                          "type": "object",
                          "properties": {
                            "version": {
                              "title": "basic block info",
                              "type": "object",
                              "properties": {
                                "block": {
                                  "type": "string",
                                  "format": "uint64"
                                },
                                "app": {
                                  "type": "string",
                                  "format": "uint64"
                                }
                              },
                              "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                            },
                            "chain_id": {
                              "type": "string"
                            },
                            "height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "time": {
                              "type": "string",
                              "format": "date-time"
                            },
                            "last_block_id": {
                              "title": "BlockID",
                              "type": "object",
                              "properties": {
                                "hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "part_set_header": {
                                  "title": "PartsetHeader",
                                  "type": "object",
                                  "properties": {
                                    "total": {
                                      "type": "integer",
                                      "format": "int64"
                                    },
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  }
                                }
                              }
                            },
                            "last_commit_hash": {
                              "title": "hashes of block data",
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "data_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "validators_hash": {
                              "title": "hashes from the app output from the prev block",
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "next_validators_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "consensus_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "app_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "last_results_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "evidence_hash": {
                              "title": "consensus info",
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "proposer_address": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            }
                          },
                          "description": "Header defines the structure of a block header."
                        },
                        "data": {
                          "title": "Data contains the set of transactions included in the block",
                          "type": "object",
                          "properties": {
                            "txs": {
                              "type": "array",
                              "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs.",
                              "items": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "format": "byte"
                              }
                            }
                          }
                        },
                        "evidence": {
                          "type": "object",
                          "properties": {
                            "evidence": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "duplicate_vote_evidence": {
                                    "type": "object",
                                    "properties": {
                                      "vote_a": {
                                        "type": "object",
                                        "properties": {
                                          "type": {
                                            "type": "string",
                                            "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                            "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                            "enum": [
                                              "SIGNED_MSG_TYPE_UNKNOWN",
                                              "SIGNED_MSG_TYPE_PREVOTE",
                                              "SIGNED_MSG_TYPE_PRECOMMIT",
                                              "SIGNED_MSG_TYPE_PROPOSAL"
                                            ]
                                          },
                                          "height": {
                                            "type": "string",
                                            "format": "int64"
                                          },
                                          "round": {
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "block_id": {
                                            "title": "BlockID",
                                            "type": "object",
                                            "properties": {
                                              "hash": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "part_set_header": {
                                                "title": "PartsetHeader",
                                                "type": "object",
                                                "properties": {
                                                  "total": {
                                                    "type": "integer",
                                                    "format": "int64"
                                                  },
                                                  "hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          "timestamp": {
                                            "type": "string",
                                            "format": "date-time"
                                          },
                                          "validator_address": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "validator_index": {
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "signature": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                                            "format": "byte"
                                          },
                                          "extension": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                                            "format": "byte"
                                          },
                                          "extension_signature": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                                            "format": "byte"
                                          }
                                        },
                                        "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                                      },
                                      "vote_b": {
                                        "type": "object",
                                        "properties": {
                                          "type": {
                                            "type": "string",
                                            "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                            "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                            "enum": [
                                              "SIGNED_MSG_TYPE_UNKNOWN",
                                              "SIGNED_MSG_TYPE_PREVOTE",
                                              "SIGNED_MSG_TYPE_PRECOMMIT",
                                              "SIGNED_MSG_TYPE_PROPOSAL"
                                            ]
                                          },
                                          "height": {
                                            "type": "string",
                                            "format": "int64"
                                          },
                                          "round": {
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "block_id": {
                                            "title": "BlockID",
                                            "type": "object",
                                            "properties": {
                                              "hash": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "part_set_header": {
                                                "title": "PartsetHeader",
                                                "type": "object",
                                                "properties": {
                                                  "total": {
                                                    "type": "integer",
                                                    "format": "int64"
                                                  },
                                                  "hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          "timestamp": {
                                            "type": "string",
                                            "format": "date-time"
                                          },
                                          "validator_address": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "validator_index": {
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "signature": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                                            "format": "byte"
                                          },
                                          "extension": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                                            "format": "byte"
                                          },
                                          "extension_signature": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                                            "format": "byte"
                                          }
                                        },
                                        "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                                      },
                                      "total_voting_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "validator_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      }
                                    },
                                    "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                                  },
                                  "light_client_attack_evidence": {
                                    "type": "object",
                                    "properties": {
                                      "conflicting_block": {
                                        "type": "object",
                                        "properties": {
                                          "signed_header": {
                                            "type": "object",
                                            "properties": {
                                              "header": {
                                                "type": "object",
                                                "properties": {
                                                  "version": {
                                                    "title": "basic block info",
                                                    "type": "object",
                                                    "properties": {
                                                      "block": {
                                                        "type": "string",
                                                        "format": "uint64"
                                                      },
                                                      "app": {
                                                        "type": "string",
                                                        "format": "uint64"
                                                      }
                                                    },
                                                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                                  },
                                                  "chain_id": {
                                                    "type": "string"
                                                  },
                                                  "height": {
                                                    "type": "string",
                                                    "format": "int64"
                                                  },
                                                  "time": {
                                                    "type": "string",
                                                    "format": "date-time"
                                                  },
                                                  "last_block_id": {
                                                    "title": "BlockID",
                                                    "type": "object",
                                                    "properties": {
                                                      "hash": {
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string",
                                                        "format": "byte"
                                                      },
                                                      "part_set_header": {
                                                        "title": "PartsetHeader",
                                                        "type": "object",
                                                        "properties": {
                                                          "total": {
                                                            "type": "integer",
                                                            "format": "int64"
                                                          },
                                                          "hash": {
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string",
                                                            "format": "byte"
                                                          }
                                                        }
                                                      }
                                                    }
                                                  },
                                                  "last_commit_hash": {
                                                    "title": "hashes of block data",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "data_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "validators_hash": {
                                                    "title": "hashes from the app output from the prev block",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "next_validators_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "consensus_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "app_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "last_results_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "evidence_hash": {
                                                    "title": "consensus info",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "proposer_address": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  }
                                                },
                                                "description": "Header defines the structure of a block header."
                                              },
                                              "commit": {
                                                "type": "object",
                                                "properties": {
                                                  "height": {
                                                    "type": "string",
                                                    "format": "int64"
                                                  },
                                                  "round": {
                                                    "type": "integer",
                                                    "format": "int32"
                                                  },
                                                  "block_id": {
                                                    "title": "BlockID",
                                                    "type": "object",
                                                    "properties": {
                                                      "hash": {
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string",
                                                        "format": "byte"
                                                      },
                                                      "part_set_header": {
                                                        "title": "PartsetHeader",
                                                        "type": "object",
                                                        "properties": {
                                                          "total": {
                                                            "type": "integer",
                                                            "format": "int64"
                                                          },
                                                          "hash": {
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string",
                                                            "format": "byte"
                                                          }
                                                        }
                                                      }
                                                    }
                                                  },
                                                  "signatures": {
                                                    "type": "array",
                                                    "items": {
                                                      "type": "object",
                                                      "properties": {
                                                        "block_id_flag": {
                                                          "title": "BlockIdFlag indicates which BlockID the signature is for",
                                                          "type": "string",
                                                          "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                          "enum": [
                                                            "BLOCK_ID_FLAG_UNKNOWN",
                                                            "BLOCK_ID_FLAG_ABSENT",
                                                            "BLOCK_ID_FLAG_COMMIT",
                                                            "BLOCK_ID_FLAG_NIL"
                                                          ]
                                                        },
                                                        "validator_address": {
                                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                          "type": "string",
                                                          "format": "byte"
                                                        },
                                                        "timestamp": {
                                                          "type": "string",
                                                          "format": "date-time"
                                                        },
                                                        "signature": {
                                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                          "type": "string",
                                                          "format": "byte"
                                                        }
                                                      },
                                                      "description": "CommitSig is a part of the Vote included in a Commit."
                                                    }
                                                  }
                                                },
                                                "description": "Commit contains the evidence that a block was committed by a set of validators."
                                              }
                                            }
                                          },
                                          "validator_set": {
                                            "type": "object",
                                            "properties": {
                                              "validators": {
                                                "type": "array",
                                                "items": {
                                                  "type": "object",
                                                  "properties": {
                                                    "address": {
                                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                      "type": "string",
                                                      "format": "byte"
                                                    },
                                                    "pub_key": {
                                                      "title": "PublicKey defines the keys available for use with Validators",
                                                      "type": "object",
                                                      "properties": {
                                                        "ed25519": {
                                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                          "type": "string",
                                                          "format": "byte"
                                                        },
                                                        "secp256k1": {
                                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                          "type": "string",
                                                          "format": "byte"
                                                        }
                                                      }
                                                    },
                                                    "voting_power": {
                                                      "type": "string",
                                                      "format": "int64"
                                                    },
                                                    "proposer_priority": {
                                                      "type": "string",
                                                      "format": "int64"
                                                    }
                                                  }
                                                }
                                              },
                                              "proposer": {
                                                "type": "object",
                                                "properties": {
                                                  "address": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "pub_key": {
                                                    "title": "PublicKey defines the keys available for use with Validators",
                                                    "type": "object",
                                                    "properties": {
                                                      "ed25519": {
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string",
                                                        "format": "byte"
                                                      },
                                                      "secp256k1": {
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string",
                                                        "format": "byte"
                                                      }
                                                    }
                                                  },
                                                  "voting_power": {
                                                    "type": "string",
                                                    "format": "int64"
                                                  },
                                                  "proposer_priority": {
                                                    "type": "string",
                                                    "format": "int64"
                                                  }
                                                }
                                              },
                                              "total_voting_power": {
                                                "type": "string",
                                                "format": "int64"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "common_height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "byzantine_validators": {
                                        "type": "array",
                                        "items": {
                                          "type": "object",
                                          "properties": {
                                            "address": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "pub_key": {
                                              "title": "PublicKey defines the keys available for use with Validators",
                                              "type": "object",
                                              "properties": {
                                                "ed25519": {
                                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                  "type": "string",
                                                  "format": "byte"
                                                },
                                                "secp256k1": {
                                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                  "type": "string",
                                                  "format": "byte"
                                                }
                                              }
                                            },
                                            "voting_power": {
                                              "type": "string",
                                              "format": "int64"
                                            },
                                            "proposer_priority": {
                                              "type": "string",
                                              "format": "int64"
                                            }
                                          }
                                        }
                                      },
                                      "total_voting_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      }
                                    },
                                    "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                                  }
                                }
                              }
                            }
                          }
                        },
                        "last_commit": {
                          "type": "object",
                          "properties": {
                            "height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "round": {
                              "type": "integer",
                              "format": "int32"
                            },
                            "block_id": {
                              "title": "BlockID",
                              "type": "object",
                              "properties": {
                                "hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "part_set_header": {
                                  "title": "PartsetHeader",
                                  "type": "object",
                                  "properties": {
                                    "total": {
                                      "type": "integer",
                                      "format": "int64"
                                    },
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  }
                                }
                              }
                            },
                            "signatures": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "block_id_flag": {
                                    "title": "BlockIdFlag indicates which BlockID the signature is for",
                                    "type": "string",
                                    "default": "BLOCK_ID_FLAG_UNKNOWN",
                                    "enum": [
                                      "BLOCK_ID_FLAG_UNKNOWN",
                                      "BLOCK_ID_FLAG_ABSENT",
                                      "BLOCK_ID_FLAG_COMMIT",
                                      "BLOCK_ID_FLAG_NIL"
                                    ]
                                  },
                                  "validator_address": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "timestamp": {
                                    "type": "string",
                                    "format": "date-time"
                                  },
                                  "signature": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  }
                                },
                                "description": "CommitSig is a part of the Vote included in a Commit."
                              }
                            }
                          },
                          "description": "Commit contains the evidence that a block was committed by a set of validators."
                        }
                      }
                    },
                    "sdk_block": {
                      "title": "Since: cosmos-sdk 0.47",
                      "type": "object",
                      "properties": {
                        "header": {
                          "type": "object",
                          "properties": {
                            "version": {
                              "title": "basic block info",
                              "type": "object",
                              "properties": {
                                "block": {
                                  "type": "string",
                                  "format": "uint64"
                                },
                                "app": {
                                  "type": "string",
                                  "format": "uint64"
                                }
                              },
                              "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                            },
                            "chain_id": {
                              "type": "string"
                            },
                            "height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "time": {
                              "type": "string",
                              "format": "date-time"
                            },
                            "last_block_id": {
                              "title": "BlockID",
                              "type": "object",
                              "properties": {
                                "hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "part_set_header": {
                                  "title": "PartsetHeader",
                                  "type": "object",
                                  "properties": {
                                    "total": {
                                      "type": "integer",
                                      "format": "int64"
                                    },
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  }
                                }
                              }
                            },
                            "last_commit_hash": {
                              "title": "hashes of block data",
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "data_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "validators_hash": {
                              "title": "hashes from the app output from the prev block",
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "next_validators_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "consensus_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "app_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "last_results_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "evidence_hash": {
                              "title": "consensus info",
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "proposer_address": {
                              "type": "string",
                              "description": "proposer_address is the original block proposer address, formatted as a Bech32 string.\nIn Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string\nfor better UX."
                            }
                          },
                          "description": "Header defines the structure of a Tendermint block header."
                        },
                        "data": {
                          "title": "Data contains the set of transactions included in the block",
                          "type": "object",
                          "properties": {
                            "txs": {
                              "type": "array",
                              "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs.",
                              "items": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "format": "byte"
                              }
                            }
                          }
                        },
                        "evidence": {
                          "type": "object",
                          "properties": {
                            "evidence": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "duplicate_vote_evidence": {
                                    "type": "object",
                                    "properties": {
                                      "vote_a": {
                                        "type": "object",
                                        "properties": {
                                          "type": {
                                            "type": "string",
                                            "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                            "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                            "enum": [
                                              "SIGNED_MSG_TYPE_UNKNOWN",
                                              "SIGNED_MSG_TYPE_PREVOTE",
                                              "SIGNED_MSG_TYPE_PRECOMMIT",
                                              "SIGNED_MSG_TYPE_PROPOSAL"
                                            ]
                                          },
                                          "height": {
                                            "type": "string",
                                            "format": "int64"
                                          },
                                          "round": {
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "block_id": {
                                            "title": "BlockID",
                                            "type": "object",
                                            "properties": {
                                              "hash": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "part_set_header": {
                                                "title": "PartsetHeader",
                                                "type": "object",
                                                "properties": {
                                                  "total": {
                                                    "type": "integer",
                                                    "format": "int64"
                                                  },
                                                  "hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          "timestamp": {
                                            "type": "string",
                                            "format": "date-time"
                                          },
                                          "validator_address": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "validator_index": {
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "signature": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                                            "format": "byte"
                                          },
                                          "extension": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                                            "format": "byte"
                                          },
                                          "extension_signature": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                                            "format": "byte"
                                          }
                                        },
                                        "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                                      },
                                      "vote_b": {
                                        "type": "object",
                                        "properties": {
                                          "type": {
                                            "type": "string",
                                            "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                            "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                            "enum": [
                                              "SIGNED_MSG_TYPE_UNKNOWN",
                                              "SIGNED_MSG_TYPE_PREVOTE",
                                              "SIGNED_MSG_TYPE_PRECOMMIT",
                                              "SIGNED_MSG_TYPE_PROPOSAL"
                                            ]
                                          },
                                          "height": {
                                            "type": "string",
                                            "format": "int64"
                                          },
                                          "round": {
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "block_id": {
                                            "title": "BlockID",
                                            "type": "object",
                                            "properties": {
                                              "hash": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "part_set_header": {
                                                "title": "PartsetHeader",
                                                "type": "object",
                                                "properties": {
                                                  "total": {
                                                    "type": "integer",
                                                    "format": "int64"
                                                  },
                                                  "hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          "timestamp": {
                                            "type": "string",
                                            "format": "date-time"
                                          },
                                          "validator_address": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "validator_index": {
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "signature": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                                            "format": "byte"
                                          },
                                          "extension": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                                            "format": "byte"
                                          },
                                          "extension_signature": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                                            "format": "byte"
                                          }
                                        },
                                        "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                                      },
                                      "total_voting_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "validator_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      }
                                    },
                                    "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                                  },
                                  "light_client_attack_evidence": {
                                    "type": "object",
                                    "properties": {
                                      "conflicting_block": {
                                        "type": "object",
                                        "properties": {
                                          "signed_header": {
                                            "type": "object",
                                            "properties": {
                                              "header": {
                                                "type": "object",
                                                "properties": {
                                                  "version": {
                                                    "title": "basic block info",
                                                    "type": "object",
                                                    "properties": {
                                                      "block": {
                                                        "type": "string",
                                                        "format": "uint64"
                                                      },
                                                      "app": {
                                                        "type": "string",
                                                        "format": "uint64"
                                                      }
                                                    },
                                                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                                  },
                                                  "chain_id": {
                                                    "type": "string"
                                                  },
                                                  "height": {
                                                    "type": "string",
                                                    "format": "int64"
                                                  },
                                                  "time": {
                                                    "type": "string",
                                                    "format": "date-time"
                                                  },
                                                  "last_block_id": {
                                                    "title": "BlockID",
                                                    "type": "object",
                                                    "properties": {
                                                      "hash": {
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string",
                                                        "format": "byte"
                                                      },
                                                      "part_set_header": {
                                                        "title": "PartsetHeader",
                                                        "type": "object",
                                                        "properties": {
                                                          "total": {
                                                            "type": "integer",
                                                            "format": "int64"
                                                          },
                                                          "hash": {
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string",
                                                            "format": "byte"
                                                          }
                                                        }
                                                      }
                                                    }
                                                  },
                                                  "last_commit_hash": {
                                                    "title": "hashes of block data",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "data_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "validators_hash": {
                                                    "title": "hashes from the app output from the prev block",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "next_validators_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "consensus_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "app_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "last_results_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "evidence_hash": {
                                                    "title": "consensus info",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "proposer_address": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  }
                                                },
                                                "description": "Header defines the structure of a block header."
                                              },
                                              "commit": {
                                                "type": "object",
                                                "properties": {
                                                  "height": {
                                                    "type": "string",
                                                    "format": "int64"
                                                  },
                                                  "round": {
                                                    "type": "integer",
                                                    "format": "int32"
                                                  },
                                                  "block_id": {
                                                    "title": "BlockID",
                                                    "type": "object",
                                                    "properties": {
                                                      "hash": {
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string",
                                                        "format": "byte"
                                                      },
                                                      "part_set_header": {
                                                        "title": "PartsetHeader",
                                                        "type": "object",
                                                        "properties": {
                                                          "total": {
                                                            "type": "integer",
                                                            "format": "int64"
                                                          },
                                                          "hash": {
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string",
                                                            "format": "byte"
                                                          }
                                                        }
                                                      }
                                                    }
                                                  },
                                                  "signatures": {
                                                    "type": "array",
                                                    "items": {
                                                      "type": "object",
                                                      "properties": {
                                                        "block_id_flag": {
                                                          "title": "BlockIdFlag indicates which BlockID the signature is for",
                                                          "type": "string",
                                                          "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                          "enum": [
                                                            "BLOCK_ID_FLAG_UNKNOWN",
                                                            "BLOCK_ID_FLAG_ABSENT",
                                                            "BLOCK_ID_FLAG_COMMIT",
                                                            "BLOCK_ID_FLAG_NIL"
                                                          ]
                                                        },
                                                        "validator_address": {
                                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                          "type": "string",
                                                          "format": "byte"
                                                        },
                                                        "timestamp": {
                                                          "type": "string",
                                                          "format": "date-time"
                                                        },
                                                        "signature": {
                                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                          "type": "string",
                                                          "format": "byte"
                                                        }
                                                      },
                                                      "description": "CommitSig is a part of the Vote included in a Commit."
                                                    }
                                                  }
                                                },
                                                "description": "Commit contains the evidence that a block was committed by a set of validators."
                                              }
                                            }
                                          },
                                          "validator_set": {
                                            "type": "object",
                                            "properties": {
                                              "validators": {
                                                "type": "array",
                                                "items": {
                                                  "type": "object",
                                                  "properties": {
                                                    "address": {
                                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                      "type": "string",
                                                      "format": "byte"
                                                    },
                                                    "pub_key": {
                                                      "title": "PublicKey defines the keys available for use with Validators",
                                                      "type": "object",
                                                      "properties": {
                                                        "ed25519": {
                                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                          "type": "string",
                                                          "format": "byte"
                                                        },
                                                        "secp256k1": {
                                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                          "type": "string",
                                                          "format": "byte"
                                                        }
                                                      }
                                                    },
                                                    "voting_power": {
                                                      "type": "string",
                                                      "format": "int64"
                                                    },
                                                    "proposer_priority": {
                                                      "type": "string",
                                                      "format": "int64"
                                                    }
                                                  }
                                                }
                                              },
                                              "proposer": {
                                                "type": "object",
                                                "properties": {
                                                  "address": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "pub_key": {
                                                    "title": "PublicKey defines the keys available for use with Validators",
                                                    "type": "object",
                                                    "properties": {
                                                      "ed25519": {
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string",
                                                        "format": "byte"
                                                      },
                                                      "secp256k1": {
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string",
                                                        "format": "byte"
                                                      }
                                                    }
                                                  },
                                                  "voting_power": {
                                                    "type": "string",
                                                    "format": "int64"
                                                  },
                                                  "proposer_priority": {
                                                    "type": "string",
                                                    "format": "int64"
                                                  }
                                                }
                                              },
                                              "total_voting_power": {
                                                "type": "string",
                                                "format": "int64"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "common_height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "byzantine_validators": {
                                        "type": "array",
                                        "items": {
                                          "type": "object",
                                          "properties": {
                                            "address": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "pub_key": {
                                              "title": "PublicKey defines the keys available for use with Validators",
                                              "type": "object",
                                              "properties": {
                                                "ed25519": {
                                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                  "type": "string",
                                                  "format": "byte"
                                                },
                                                "secp256k1": {
                                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                  "type": "string",
                                                  "format": "byte"
                                                }
                                              }
                                            },
                                            "voting_power": {
                                              "type": "string",
                                              "format": "int64"
                                            },
                                            "proposer_priority": {
                                              "type": "string",
                                              "format": "int64"
                                            }
                                          }
                                        }
                                      },
                                      "total_voting_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      }
                                    },
                                    "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                                  }
                                }
                              }
                            }
                          }
                        },
                        "last_commit": {
                          "type": "object",
                          "properties": {
                            "height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "round": {
                              "type": "integer",
                              "format": "int32"
                            },
                            "block_id": {
                              "title": "BlockID",
                              "type": "object",
                              "properties": {
                                "hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "part_set_header": {
                                  "title": "PartsetHeader",
                                  "type": "object",
                                  "properties": {
                                    "total": {
                                      "type": "integer",
                                      "format": "int64"
                                    },
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  }
                                }
                              }
                            },
                            "signatures": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "block_id_flag": {
                                    "title": "BlockIdFlag indicates which BlockID the signature is for",
                                    "type": "string",
                                    "default": "BLOCK_ID_FLAG_UNKNOWN",
                                    "enum": [
                                      "BLOCK_ID_FLAG_UNKNOWN",
                                      "BLOCK_ID_FLAG_ABSENT",
                                      "BLOCK_ID_FLAG_COMMIT",
                                      "BLOCK_ID_FLAG_NIL"
                                    ]
                                  },
                                  "validator_address": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "timestamp": {
                                    "type": "string",
                                    "format": "date-time"
                                  },
                                  "signature": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  }
                                },
                                "description": "CommitSig is a part of the Vote included in a Commit."
                              }
                            }
                          },
                          "description": "Commit contains the evidence that a block was committed by a set of validators."
                        }
                      },
                      "description": "Block is tendermint type Block, with the Header proposer address\nfield converted to bech32 string."
                    }
                  },
                  "description": "GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/base/tendermint/v1beta1/blocks/{height}": {
      "get": {
        "tags": [
          "Service"
        ],
        "summary": "GetBlockByHeight queries block for given height.",
        "operationId": "GetBlockByHeight",
        "parameters": [
          {
            "name": "height",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "int64"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "block_id": {
                      "title": "BlockID",
                      "type": "object",
                      "properties": {
                        "hash": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        },
                        "part_set_header": {
                          "title": "PartsetHeader",
                          "type": "object",
                          "properties": {
                            "total": {
                              "type": "integer",
                              "format": "int64"
                            },
                            "hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            }
                          }
                        }
                      }
                    },
                    "block": {
                      "title": "Deprecated: please use `sdk_block` instead",
                      "type": "object",
                      "properties": {
                        "header": {
                          "type": "object",
                          "properties": {
                            "version": {
                              "title": "basic block info",
                              "type": "object",
                              "properties": {
                                "block": {
                                  "type": "string",
                                  "format": "uint64"
                                },
                                "app": {
                                  "type": "string",
                                  "format": "uint64"
                                }
                              },
                              "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                            },
                            "chain_id": {
                              "type": "string"
                            },
                            "height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "time": {
                              "type": "string",
                              "format": "date-time"
                            },
                            "last_block_id": {
                              "title": "BlockID",
                              "type": "object",
                              "properties": {
                                "hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "part_set_header": {
                                  "title": "PartsetHeader",
                                  "type": "object",
                                  "properties": {
                                    "total": {
                                      "type": "integer",
                                      "format": "int64"
                                    },
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  }
                                }
                              }
                            },
                            "last_commit_hash": {
                              "title": "hashes of block data",
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "data_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "validators_hash": {
                              "title": "hashes from the app output from the prev block",
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "next_validators_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "consensus_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "app_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "last_results_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "evidence_hash": {
                              "title": "consensus info",
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "proposer_address": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            }
                          },
                          "description": "Header defines the structure of a block header."
                        },
                        "data": {
                          "title": "Data contains the set of transactions included in the block",
                          "type": "object",
                          "properties": {
                            "txs": {
                              "type": "array",
                              "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs.",
                              "items": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "format": "byte"
                              }
                            }
                          }
                        },
                        "evidence": {
                          "type": "object",
                          "properties": {
                            "evidence": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "duplicate_vote_evidence": {
                                    "type": "object",
                                    "properties": {
                                      "vote_a": {
                                        "type": "object",
                                        "properties": {
                                          "type": {
                                            "type": "string",
                                            "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                            "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                            "enum": [
                                              "SIGNED_MSG_TYPE_UNKNOWN",
                                              "SIGNED_MSG_TYPE_PREVOTE",
                                              "SIGNED_MSG_TYPE_PRECOMMIT",
                                              "SIGNED_MSG_TYPE_PROPOSAL"
                                            ]
                                          },
                                          "height": {
                                            "type": "string",
                                            "format": "int64"
                                          },
                                          "round": {
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "block_id": {
                                            "title": "BlockID",
                                            "type": "object",
                                            "properties": {
                                              "hash": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "part_set_header": {
                                                "title": "PartsetHeader",
                                                "type": "object",
                                                "properties": {
                                                  "total": {
                                                    "type": "integer",
                                                    "format": "int64"
                                                  },
                                                  "hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          "timestamp": {
                                            "type": "string",
                                            "format": "date-time"
                                          },
                                          "validator_address": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "validator_index": {
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "signature": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                                            "format": "byte"
                                          },
                                          "extension": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                                            "format": "byte"
                                          },
                                          "extension_signature": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                                            "format": "byte"
                                          }
                                        },
                                        "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                                      },
                                      "vote_b": {
                                        "type": "object",
                                        "properties": {
                                          "type": {
                                            "type": "string",
                                            "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                            "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                            "enum": [
                                              "SIGNED_MSG_TYPE_UNKNOWN",
                                              "SIGNED_MSG_TYPE_PREVOTE",
                                              "SIGNED_MSG_TYPE_PRECOMMIT",
                                              "SIGNED_MSG_TYPE_PROPOSAL"
                                            ]
                                          },
                                          "height": {
                                            "type": "string",
                                            "format": "int64"
                                          },
                                          "round": {
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "block_id": {
                                            "title": "BlockID",
                                            "type": "object",
                                            "properties": {
                                              "hash": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "part_set_header": {
                                                "title": "PartsetHeader",
                                                "type": "object",
                                                "properties": {
                                                  "total": {
                                                    "type": "integer",
                                                    "format": "int64"
                                                  },
                                                  "hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          "timestamp": {
                                            "type": "string",
                                            "format": "date-time"
                                          },
                                          "validator_address": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "validator_index": {
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "signature": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                                            "format": "byte"
                                          },
                                          "extension": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                                            "format": "byte"
                                          },
                                          "extension_signature": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                                            "format": "byte"
                                          }
                                        },
                                        "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                                      },
                                      "total_voting_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "validator_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      }
                                    },
                                    "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                                  },
                                  "light_client_attack_evidence": {
                                    "type": "object",
                                    "properties": {
                                      "conflicting_block": {
                                        "type": "object",
                                        "properties": {
                                          "signed_header": {
                                            "type": "object",
                                            "properties": {
                                              "header": {
                                                "type": "object",
                                                "properties": {
                                                  "version": {
                                                    "title": "basic block info",
                                                    "type": "object",
                                                    "properties": {
                                                      "block": {
                                                        "type": "string",
                                                        "format": "uint64"
                                                      },
                                                      "app": {
                                                        "type": "string",
                                                        "format": "uint64"
                                                      }
                                                    },
                                                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                                  },
                                                  "chain_id": {
                                                    "type": "string"
                                                  },
                                                  "height": {
                                                    "type": "string",
                                                    "format": "int64"
                                                  },
                                                  "time": {
                                                    "type": "string",
                                                    "format": "date-time"
                                                  },
                                                  "last_block_id": {
                                                    "title": "BlockID",
                                                    "type": "object",
                                                    "properties": {
                                                      "hash": {
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string",
                                                        "format": "byte"
                                                      },
                                                      "part_set_header": {
                                                        "title": "PartsetHeader",
                                                        "type": "object",
                                                        "properties": {
                                                          "total": {
                                                            "type": "integer",
                                                            "format": "int64"
                                                          },
                                                          "hash": {
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string",
                                                            "format": "byte"
                                                          }
                                                        }
                                                      }
                                                    }
                                                  },
                                                  "last_commit_hash": {
                                                    "title": "hashes of block data",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "data_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "validators_hash": {
                                                    "title": "hashes from the app output from the prev block",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "next_validators_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "consensus_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "app_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "last_results_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "evidence_hash": {
                                                    "title": "consensus info",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "proposer_address": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  }
                                                },
                                                "description": "Header defines the structure of a block header."
                                              },
                                              "commit": {
                                                "type": "object",
                                                "properties": {
                                                  "height": {
                                                    "type": "string",
                                                    "format": "int64"
                                                  },
                                                  "round": {
                                                    "type": "integer",
                                                    "format": "int32"
                                                  },
                                                  "block_id": {
                                                    "title": "BlockID",
                                                    "type": "object",
                                                    "properties": {
                                                      "hash": {
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string",
                                                        "format": "byte"
                                                      },
                                                      "part_set_header": {
                                                        "title": "PartsetHeader",
                                                        "type": "object",
                                                        "properties": {
                                                          "total": {
                                                            "type": "integer",
                                                            "format": "int64"
                                                          },
                                                          "hash": {
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string",
                                                            "format": "byte"
                                                          }
                                                        }
                                                      }
                                                    }
                                                  },
                                                  "signatures": {
                                                    "type": "array",
                                                    "items": {
                                                      "type": "object",
                                                      "properties": {
                                                        "block_id_flag": {
                                                          "title": "BlockIdFlag indicates which BlockID the signature is for",
                                                          "type": "string",
                                                          "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                          "enum": [
                                                            "BLOCK_ID_FLAG_UNKNOWN",
                                                            "BLOCK_ID_FLAG_ABSENT",
                                                            "BLOCK_ID_FLAG_COMMIT",
                                                            "BLOCK_ID_FLAG_NIL"
                                                          ]
                                                        },
                                                        "validator_address": {
                                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                          "type": "string",
                                                          "format": "byte"
                                                        },
                                                        "timestamp": {
                                                          "type": "string",
                                                          "format": "date-time"
                                                        },
                                                        "signature": {
                                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                          "type": "string",
                                                          "format": "byte"
                                                        }
                                                      },
                                                      "description": "CommitSig is a part of the Vote included in a Commit."
                                                    }
                                                  }
                                                },
                                                "description": "Commit contains the evidence that a block was committed by a set of validators."
                                              }
                                            }
                                          },
                                          "validator_set": {
                                            "type": "object",
                                            "properties": {
                                              "validators": {
                                                "type": "array",
                                                "items": {
                                                  "type": "object",
                                                  "properties": {
                                                    "address": {
                                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                      "type": "string",
                                                      "format": "byte"
                                                    },
                                                    "pub_key": {
                                                      "title": "PublicKey defines the keys available for use with Validators",
                                                      "type": "object",
                                                      "properties": {
                                                        "ed25519": {
                                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                          "type": "string",
                                                          "format": "byte"
                                                        },
                                                        "secp256k1": {
                                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                          "type": "string",
                                                          "format": "byte"
                                                        }
                                                      }
                                                    },
                                                    "voting_power": {
                                                      "type": "string",
                                                      "format": "int64"
                                                    },
                                                    "proposer_priority": {
                                                      "type": "string",
                                                      "format": "int64"
                                                    }
                                                  }
                                                }
                                              },
                                              "proposer": {
                                                "type": "object",
                                                "properties": {
                                                  "address": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "pub_key": {
                                                    "title": "PublicKey defines the keys available for use with Validators",
                                                    "type": "object",
                                                    "properties": {
                                                      "ed25519": {
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string",
                                                        "format": "byte"
                                                      },
                                                      "secp256k1": {
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string",
                                                        "format": "byte"
                                                      }
                                                    }
                                                  },
                                                  "voting_power": {
                                                    "type": "string",
                                                    "format": "int64"
                                                  },
                                                  "proposer_priority": {
                                                    "type": "string",
                                                    "format": "int64"
                                                  }
                                                }
                                              },
                                              "total_voting_power": {
                                                "type": "string",
                                                "format": "int64"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "common_height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "byzantine_validators": {
                                        "type": "array",
                                        "items": {
                                          "type": "object",
                                          "properties": {
                                            "address": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "pub_key": {
                                              "title": "PublicKey defines the keys available for use with Validators",
                                              "type": "object",
                                              "properties": {
                                                "ed25519": {
                                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                  "type": "string",
                                                  "format": "byte"
                                                },
                                                "secp256k1": {
                                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                  "type": "string",
                                                  "format": "byte"
                                                }
                                              }
                                            },
                                            "voting_power": {
                                              "type": "string",
                                              "format": "int64"
                                            },
                                            "proposer_priority": {
                                              "type": "string",
                                              "format": "int64"
                                            }
                                          }
                                        }
                                      },
                                      "total_voting_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      }
                                    },
                                    "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                                  }
                                }
                              }
                            }
                          }
                        },
                        "last_commit": {
                          "type": "object",
                          "properties": {
                            "height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "round": {
                              "type": "integer",
                              "format": "int32"
                            },
                            "block_id": {
                              "title": "BlockID",
                              "type": "object",
                              "properties": {
                                "hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "part_set_header": {
                                  "title": "PartsetHeader",
                                  "type": "object",
                                  "properties": {
                                    "total": {
                                      "type": "integer",
                                      "format": "int64"
                                    },
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  }
                                }
                              }
                            },
                            "signatures": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "block_id_flag": {
                                    "title": "BlockIdFlag indicates which BlockID the signature is for",
                                    "type": "string",
                                    "default": "BLOCK_ID_FLAG_UNKNOWN",
                                    "enum": [
                                      "BLOCK_ID_FLAG_UNKNOWN",
                                      "BLOCK_ID_FLAG_ABSENT",
                                      "BLOCK_ID_FLAG_COMMIT",
                                      "BLOCK_ID_FLAG_NIL"
                                    ]
                                  },
                                  "validator_address": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "timestamp": {
                                    "type": "string",
                                    "format": "date-time"
                                  },
                                  "signature": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  }
                                },
                                "description": "CommitSig is a part of the Vote included in a Commit."
                              }
                            }
                          },
                          "description": "Commit contains the evidence that a block was committed by a set of validators."
                        }
                      }
                    },
                    "sdk_block": {
                      "title": "Since: cosmos-sdk 0.47",
                      "type": "object",
                      "properties": {
                        "header": {
                          "type": "object",
                          "properties": {
                            "version": {
                              "title": "basic block info",
                              "type": "object",
                              "properties": {
                                "block": {
                                  "type": "string",
                                  "format": "uint64"
                                },
                                "app": {
                                  "type": "string",
                                  "format": "uint64"
                                }
                              },
                              "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                            },
                            "chain_id": {
                              "type": "string"
                            },
                            "height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "time": {
                              "type": "string",
                              "format": "date-time"
                            },
                            "last_block_id": {
                              "title": "BlockID",
                              "type": "object",
                              "properties": {
                                "hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "part_set_header": {
                                  "title": "PartsetHeader",
                                  "type": "object",
                                  "properties": {
                                    "total": {
                                      "type": "integer",
                                      "format": "int64"
                                    },
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  }
                                }
                              }
                            },
                            "last_commit_hash": {
                              "title": "hashes of block data",
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "data_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "validators_hash": {
                              "title": "hashes from the app output from the prev block",
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "next_validators_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "consensus_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "app_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "last_results_hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "evidence_hash": {
                              "title": "consensus info",
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "proposer_address": {
                              "type": "string",
                              "description": "proposer_address is the original block proposer address, formatted as a Bech32 string.\nIn Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string\nfor better UX."
                            }
                          },
                          "description": "Header defines the structure of a Tendermint block header."
                        },
                        "data": {
                          "title": "Data contains the set of transactions included in the block",
                          "type": "object",
                          "properties": {
                            "txs": {
                              "type": "array",
                              "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs.",
                              "items": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "format": "byte"
                              }
                            }
                          }
                        },
                        "evidence": {
                          "type": "object",
                          "properties": {
                            "evidence": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "duplicate_vote_evidence": {
                                    "type": "object",
                                    "properties": {
                                      "vote_a": {
                                        "type": "object",
                                        "properties": {
                                          "type": {
                                            "type": "string",
                                            "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                            "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                            "enum": [
                                              "SIGNED_MSG_TYPE_UNKNOWN",
                                              "SIGNED_MSG_TYPE_PREVOTE",
                                              "SIGNED_MSG_TYPE_PRECOMMIT",
                                              "SIGNED_MSG_TYPE_PROPOSAL"
                                            ]
                                          },
                                          "height": {
                                            "type": "string",
                                            "format": "int64"
                                          },
                                          "round": {
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "block_id": {
                                            "title": "BlockID",
                                            "type": "object",
                                            "properties": {
                                              "hash": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "part_set_header": {
                                                "title": "PartsetHeader",
                                                "type": "object",
                                                "properties": {
                                                  "total": {
                                                    "type": "integer",
                                                    "format": "int64"
                                                  },
                                                  "hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          "timestamp": {
                                            "type": "string",
                                            "format": "date-time"
                                          },
                                          "validator_address": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "validator_index": {
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "signature": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                                            "format": "byte"
                                          },
                                          "extension": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                                            "format": "byte"
                                          },
                                          "extension_signature": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                                            "format": "byte"
                                          }
                                        },
                                        "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                                      },
                                      "vote_b": {
                                        "type": "object",
                                        "properties": {
                                          "type": {
                                            "type": "string",
                                            "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                            "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                            "enum": [
                                              "SIGNED_MSG_TYPE_UNKNOWN",
                                              "SIGNED_MSG_TYPE_PREVOTE",
                                              "SIGNED_MSG_TYPE_PRECOMMIT",
                                              "SIGNED_MSG_TYPE_PROPOSAL"
                                            ]
                                          },
                                          "height": {
                                            "type": "string",
                                            "format": "int64"
                                          },
                                          "round": {
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "block_id": {
                                            "title": "BlockID",
                                            "type": "object",
                                            "properties": {
                                              "hash": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "part_set_header": {
                                                "title": "PartsetHeader",
                                                "type": "object",
                                                "properties": {
                                                  "total": {
                                                    "type": "integer",
                                                    "format": "int64"
                                                  },
                                                  "hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  }
                                                }
                                              }
                                            }
                                          },
                                          "timestamp": {
                                            "type": "string",
                                            "format": "date-time"
                                          },
                                          "validator_address": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "validator_index": {
                                            "type": "integer",
                                            "format": "int32"
                                          },
                                          "signature": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                                            "format": "byte"
                                          },
                                          "extension": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                                            "format": "byte"
                                          },
                                          "extension_signature": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                                            "format": "byte"
                                          }
                                        },
                                        "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                                      },
                                      "total_voting_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "validator_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      }
                                    },
                                    "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                                  },
                                  "light_client_attack_evidence": {
                                    "type": "object",
                                    "properties": {
                                      "conflicting_block": {
                                        "type": "object",
                                        "properties": {
                                          "signed_header": {
                                            "type": "object",
                                            "properties": {
                                              "header": {
                                                "type": "object",
                                                "properties": {
                                                  "version": {
                                                    "title": "basic block info",
                                                    "type": "object",
                                                    "properties": {
                                                      "block": {
                                                        "type": "string",
                                                        "format": "uint64"
                                                      },
                                                      "app": {
                                                        "type": "string",
                                                        "format": "uint64"
                                                      }
                                                    },
                                                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                                  },
                                                  "chain_id": {
                                                    "type": "string"
                                                  },
                                                  "height": {
                                                    "type": "string",
                                                    "format": "int64"
                                                  },
                                                  "time": {
                                                    "type": "string",
                                                    "format": "date-time"
                                                  },
                                                  "last_block_id": {
                                                    "title": "BlockID",
                                                    "type": "object",
                                                    "properties": {
                                                      "hash": {
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string",
                                                        "format": "byte"
                                                      },
                                                      "part_set_header": {
                                                        "title": "PartsetHeader",
                                                        "type": "object",
                                                        "properties": {
                                                          "total": {
                                                            "type": "integer",
                                                            "format": "int64"
                                                          },
                                                          "hash": {
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string",
                                                            "format": "byte"
                                                          }
                                                        }
                                                      }
                                                    }
                                                  },
                                                  "last_commit_hash": {
                                                    "title": "hashes of block data",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "data_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "validators_hash": {
                                                    "title": "hashes from the app output from the prev block",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "next_validators_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "consensus_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "app_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "last_results_hash": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "evidence_hash": {
                                                    "title": "consensus info",
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "proposer_address": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  }
                                                },
                                                "description": "Header defines the structure of a block header."
                                              },
                                              "commit": {
                                                "type": "object",
                                                "properties": {
                                                  "height": {
                                                    "type": "string",
                                                    "format": "int64"
                                                  },
                                                  "round": {
                                                    "type": "integer",
                                                    "format": "int32"
                                                  },
                                                  "block_id": {
                                                    "title": "BlockID",
                                                    "type": "object",
                                                    "properties": {
                                                      "hash": {
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string",
                                                        "format": "byte"
                                                      },
                                                      "part_set_header": {
                                                        "title": "PartsetHeader",
                                                        "type": "object",
                                                        "properties": {
                                                          "total": {
                                                            "type": "integer",
                                                            "format": "int64"
                                                          },
                                                          "hash": {
                                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                            "type": "string",
                                                            "format": "byte"
                                                          }
                                                        }
                                                      }
                                                    }
                                                  },
                                                  "signatures": {
                                                    "type": "array",
                                                    "items": {
                                                      "type": "object",
                                                      "properties": {
                                                        "block_id_flag": {
                                                          "title": "BlockIdFlag indicates which BlockID the signature is for",
                                                          "type": "string",
                                                          "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                          "enum": [
                                                            "BLOCK_ID_FLAG_UNKNOWN",
                                                            "BLOCK_ID_FLAG_ABSENT",
                                                            "BLOCK_ID_FLAG_COMMIT",
                                                            "BLOCK_ID_FLAG_NIL"
                                                          ]
                                                        },
                                                        "validator_address": {
                                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                          "type": "string",
                                                          "format": "byte"
                                                        },
                                                        "timestamp": {
                                                          "type": "string",
                                                          "format": "date-time"
                                                        },
                                                        "signature": {
                                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                          "type": "string",
                                                          "format": "byte"
                                                        }
                                                      },
                                                      "description": "CommitSig is a part of the Vote included in a Commit."
                                                    }
                                                  }
                                                },
                                                "description": "Commit contains the evidence that a block was committed by a set of validators."
                                              }
                                            }
                                          },
                                          "validator_set": {
                                            "type": "object",
                                            "properties": {
                                              "validators": {
                                                "type": "array",
                                                "items": {
                                                  "type": "object",
                                                  "properties": {
                                                    "address": {
                                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                      "type": "string",
                                                      "format": "byte"
                                                    },
                                                    "pub_key": {
                                                      "title": "PublicKey defines the keys available for use with Validators",
                                                      "type": "object",
                                                      "properties": {
                                                        "ed25519": {
                                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                          "type": "string",
                                                          "format": "byte"
                                                        },
                                                        "secp256k1": {
                                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                          "type": "string",
                                                          "format": "byte"
                                                        }
                                                      }
                                                    },
                                                    "voting_power": {
                                                      "type": "string",
                                                      "format": "int64"
                                                    },
                                                    "proposer_priority": {
                                                      "type": "string",
                                                      "format": "int64"
                                                    }
                                                  }
                                                }
                                              },
                                              "proposer": {
                                                "type": "object",
                                                "properties": {
                                                  "address": {
                                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                    "type": "string",
                                                    "format": "byte"
                                                  },
                                                  "pub_key": {
                                                    "title": "PublicKey defines the keys available for use with Validators",
                                                    "type": "object",
                                                    "properties": {
                                                      "ed25519": {
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string",
                                                        "format": "byte"
                                                      },
                                                      "secp256k1": {
                                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                        "type": "string",
                                                        "format": "byte"
                                                      }
                                                    }
                                                  },
                                                  "voting_power": {
                                                    "type": "string",
                                                    "format": "int64"
                                                  },
                                                  "proposer_priority": {
                                                    "type": "string",
                                                    "format": "int64"
                                                  }
                                                }
                                              },
                                              "total_voting_power": {
                                                "type": "string",
                                                "format": "int64"
                                              }
                                            }
                                          }
                                        }
                                      },
                                      "common_height": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "byzantine_validators": {
                                        "type": "array",
                                        "items": {
                                          "type": "object",
                                          "properties": {
                                            "address": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "pub_key": {
                                              "title": "PublicKey defines the keys available for use with Validators",
                                              "type": "object",
                                              "properties": {
                                                "ed25519": {
                                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                  "type": "string",
                                                  "format": "byte"
                                                },
                                                "secp256k1": {
                                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                  "type": "string",
                                                  "format": "byte"
                                                }
                                              }
                                            },
                                            "voting_power": {
                                              "type": "string",
                                              "format": "int64"
                                            },
                                            "proposer_priority": {
                                              "type": "string",
                                              "format": "int64"
                                            }
                                          }
                                        }
                                      },
                                      "total_voting_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      }
                                    },
                                    "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                                  }
                                }
                              }
                            }
                          }
                        },
                        "last_commit": {
                          "type": "object",
                          "properties": {
                            "height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "round": {
                              "type": "integer",
                              "format": "int32"
                            },
                            "block_id": {
                              "title": "BlockID",
                              "type": "object",
                              "properties": {
                                "hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "part_set_header": {
                                  "title": "PartsetHeader",
                                  "type": "object",
                                  "properties": {
                                    "total": {
                                      "type": "integer",
                                      "format": "int64"
                                    },
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  }
                                }
                              }
                            },
                            "signatures": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "block_id_flag": {
                                    "title": "BlockIdFlag indicates which BlockID the signature is for",
                                    "type": "string",
                                    "default": "BLOCK_ID_FLAG_UNKNOWN",
                                    "enum": [
                                      "BLOCK_ID_FLAG_UNKNOWN",
                                      "BLOCK_ID_FLAG_ABSENT",
                                      "BLOCK_ID_FLAG_COMMIT",
                                      "BLOCK_ID_FLAG_NIL"
                                    ]
                                  },
                                  "validator_address": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "timestamp": {
                                    "type": "string",
                                    "format": "date-time"
                                  },
                                  "signature": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  }
                                },
                                "description": "CommitSig is a part of the Vote included in a Commit."
                              }
                            }
                          },
                          "description": "Commit contains the evidence that a block was committed by a set of validators."
                        }
                      },
                      "description": "Block is tendermint type Block, with the Header proposer address\nfield converted to bech32 string."
                    }
                  },
                  "description": "GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/base/tendermint/v1beta1/node_info": {
      "get": {
        "tags": [
          "Service"
        ],
        "summary": "GetNodeInfo queries the current node info.",
        "operationId": "GetNodeInfo",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "default_node_info": {
                      "type": "object",
                      "properties": {
                        "protocol_version": {
                          "type": "object",
                          "properties": {
                            "p2p": {
                              "type": "string",
                              "format": "uint64"
                            },
                            "block": {
                              "type": "string",
                              "format": "uint64"
                            },
                            "app": {
                              "type": "string",
                              "format": "uint64"
                            }
                          }
                        },
                        "default_node_id": {
                          "type": "string"
                        },
                        "listen_addr": {
                          "type": "string"
                        },
                        "network": {
                          "type": "string"
                        },
                        "version": {
                          "type": "string"
                        },
                        "channels": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        },
                        "moniker": {
                          "type": "string"
                        },
                        "other": {
                          "type": "object",
                          "properties": {
                            "tx_index": {
                              "type": "string"
                            },
                            "rpc_address": {
                              "type": "string"
                            }
                          }
                        }
                      }
                    },
                    "application_version": {
                      "type": "object",
                      "properties": {
                        "name": {
                          "type": "string"
                        },
                        "app_name": {
                          "type": "string"
                        },
                        "version": {
                          "type": "string"
                        },
                        "git_commit": {
                          "type": "string"
                        },
                        "build_tags": {
                          "type": "string"
                        },
                        "go_version": {
                          "type": "string"
                        },
                        "build_deps": {
                          "type": "array",
                          "items": {
                            "title": "Module is the type for VersionInfo",
                            "type": "object",
                            "properties": {
                              "path": {
                                "title": "module path",
                                "type": "string"
                              },
                              "version": {
                                "title": "module version",
                                "type": "string"
                              },
                              "sum": {
                                "title": "checksum",
                                "type": "string"
                              }
                            }
                          }
                        },
                        "cosmos_sdk_version": {
                          "title": "Since: cosmos-sdk 0.43",
                          "type": "string"
                        }
                      },
                      "description": "VersionInfo is the type for the GetNodeInfoResponse message."
                    }
                  },
                  "description": "GetNodeInfoResponse is the response type for the Query/GetNodeInfo RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/base/tendermint/v1beta1/syncing": {
      "get": {
        "tags": [
          "Service"
        ],
        "summary": "GetSyncing queries node syncing.",
        "operationId": "GetSyncing",
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "syncing": {
                      "type": "boolean"
                    }
                  },
                  "description": "GetSyncingResponse is the response type for the Query/GetSyncing RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/base/tendermint/v1beta1/validatorsets/latest": {
      "get": {
        "tags": [
          "Service"
        ],
        "summary": "GetLatestValidatorSet queries latest validator-set.",
        "operationId": "GetLatestValidatorSet",
        "parameters": [
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "block_height": {
                      "type": "string",
                      "format": "int64"
                    },
                    "validators": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "address": {
                            "type": "string"
                          },
                          "pub_key": {
                            "type": "object",
                            "properties": {
                              "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                              },
                              "value": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "byte"
                              }
                            },
                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                          },
                          "voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "proposer_priority": {
                            "type": "string",
                            "format": "int64"
                          }
                        },
                        "description": "Validator is the type for the validator-set."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines an pagination for the response."
                    }
                  },
                  "description": "GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    },
    "/cosmos/base/tendermint/v1beta1/validatorsets/{height}": {
      "get": {
        "tags": [
          "Service"
        ],
        "summary": "GetValidatorSetByHeight queries validator-set at a given height.",
        "operationId": "GetValidatorSetByHeight",
        "parameters": [
          {
            "name": "height",
            "in": "path",
            "required": true,
            "schema": {
              "type": "string",
              "format": "int64"
            }
          },
          {
            "name": "pagination.key",
            "in": "query",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "schema": {
              "type": "string",
              "format": "byte"
            }
          },
          {
            "name": "pagination.offset",
            "in": "query",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.limit",
            "in": "query",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "schema": {
              "type": "string",
              "format": "uint64"
            }
          },
          {
            "name": "pagination.count_total",
            "in": "query",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set.",
            "schema": {
              "type": "boolean"
            }
          },
          {
            "name": "pagination.reverse",
            "in": "query",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43",
            "schema": {
              "type": "boolean"
            }
          }
        ],
        "responses": {
          "200": {
            "description": "A successful response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "block_height": {
                      "type": "string",
                      "format": "int64"
                    },
                    "validators": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "address": {
                            "type": "string"
                          },
                          "pub_key": {
                            "type": "object",
                            "properties": {
                              "type_url": {
                                "type": "string",
                                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                              },
                              "value": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                                "format": "byte"
                              }
                            },
                            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                          },
                          "voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "proposer_priority": {
                            "type": "string",
                            "format": "int64"
                          }
                        },
                        "description": "Validator is the type for the validator-set."
                      }
                    },
                    "pagination": {
                      "type": "object",
                      "properties": {
                        "next_key": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                          "format": "byte"
                        },
                        "total": {
                          "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                          "type": "string",
                          "format": "uint64"
                        }
                      },
                      "description": "pagination defines an pagination for the response."
                    }
                  },
                  "description": "GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method."
                }
              }
            }
          },
          "default": {
            "description": "An unexpected error response.",
            "content": {
              "*/*": {
                "schema": {
                  "type": "object",
                  "properties": {
                    "error": {
                      "type": "string"
                    },
                    "code": {
                      "type": "integer",
                      "format": "int32"
                    },
                    "message": {
                      "type": "string"
                    },
                    "details": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type_url": {
                            "type": "string",
                            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                          },
                          "value": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "description": "Must be a valid serialized protocol buffer of the above specified type.",
                            "format": "byte"
                          }
                        },
                        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  },
  "components": {
    "schemas": {
      "cosmos.base.query.v1beta1.PageRequest": {
        "title": "PageRequest is to be embedded in gRPC request messages for efficient\npagination. Ex:",
        "type": "object",
        "properties": {
          "key": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "key is a value returned in PageResponse.next_key to begin\nquerying the next page most efficiently. Only one of offset or key\nshould be set.",
            "format": "byte"
          },
          "offset": {
            "type": "string",
            "description": "offset is a numeric offset that can be used when key is unavailable.\nIt is less efficient than using key. Only one of offset or key should\nbe set.",
            "format": "uint64"
          },
          "limit": {
            "type": "string",
            "description": "limit is the total number of results to be returned in the result page.\nIf left empty it will default to a value to be set by each app.",
            "format": "uint64"
          },
          "count_total": {
            "type": "boolean",
            "description": "count_total is set to true  to indicate that the result set should include\na count of the total number of items available for pagination in UIs.\ncount_total is only respected when offset is used. It is ignored when key\nis set."
          },
          "reverse": {
            "type": "boolean",
            "description": "reverse is set to true if results are to be returned in the descending order.\n\nSince: cosmos-sdk 0.43"
          }
        },
        "description": "message SomeRequest {\n         Foo some_parameter = 1;\n         PageRequest pagination = 2;\n }"
      },
      "cosmos.base.query.v1beta1.PageResponse": {
        "type": "object",
        "properties": {
          "next_key": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
            "format": "byte"
          },
          "total": {
            "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
            "type": "string",
            "format": "uint64"
          }
        },
        "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
      },
      "cosmos.base.v1beta1.Coin": {
        "type": "object",
        "properties": {
          "denom": {
            "type": "string"
          },
          "amount": {
            "type": "string"
          }
        },
        "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
      },
      "evmos.claims.v1.Action": {
        "type": "string",
        "description": "Action defines the list of available actions to claim the airdrop tokens.\n\n - ACTION_UNSPECIFIED: ACTION_UNSPECIFIED defines an invalid action.\n - ACTION_VOTE: ACTION_VOTE defines a proposal vote.\n - ACTION_DELEGATE: ACTION_DELEGATE defines an staking delegation.\n - ACTION_EVM: ACTION_EVM defines an EVM transaction.\n - ACTION_IBC_TRANSFER: ACTION_IBC_TRANSFER defines a fungible token transfer transaction via IBC.",
        "default": "ACTION_UNSPECIFIED",
        "enum": [
          "ACTION_UNSPECIFIED",
          "ACTION_VOTE",
          "ACTION_DELEGATE",
          "ACTION_EVM",
          "ACTION_IBC_TRANSFER"
        ]
      },
      "evmos.claims.v1.Claim": {
        "type": "object",
        "properties": {
          "action": {
            "title": "action enum",
            "type": "string",
            "description": "Action defines the list of available actions to claim the airdrop tokens.\n\n - ACTION_UNSPECIFIED: ACTION_UNSPECIFIED defines an invalid action.\n - ACTION_VOTE: ACTION_VOTE defines a proposal vote.\n - ACTION_DELEGATE: ACTION_DELEGATE defines an staking delegation.\n - ACTION_EVM: ACTION_EVM defines an EVM transaction.\n - ACTION_IBC_TRANSFER: ACTION_IBC_TRANSFER defines a fungible token transfer transaction via IBC.",
            "default": "ACTION_UNSPECIFIED",
            "enum": [
              "ACTION_UNSPECIFIED",
              "ACTION_VOTE",
              "ACTION_DELEGATE",
              "ACTION_EVM",
              "ACTION_IBC_TRANSFER"
            ]
          },
          "completed": {
            "title": "completed is true if the action has been completed",
            "type": "boolean"
          },
          "claimable_amount": {
            "title": "claimable_amount of tokens for the action. Zero if completed",
            "type": "string"
          }
        },
        "description": "Claim defines the action, completed flag and the remaining claimable amount\nfor a given user. This is only used during client queries."
      },
      "evmos.claims.v1.ClaimsRecordAddress": {
        "type": "object",
        "properties": {
          "address": {
            "title": "address of claiming user in either bech32 or hex format",
            "type": "string"
          },
          "initial_claimable_amount": {
            "title": "initial_claimable_amount for the user",
            "type": "string"
          },
          "actions_completed": {
            "title": "actions_completed is a slice that describes which actions were completed",
            "type": "array",
            "items": {
              "type": "boolean"
            }
          }
        },
        "description": "ClaimsRecordAddress is the claims metadata per address that is used at\nGenesis."
      },
      "evmos.claims.v1.Params": {
        "type": "object",
        "properties": {
          "enable_claims": {
            "title": "enable_claims is the parameter to enable the claiming process",
            "type": "boolean"
          },
          "airdrop_start_time": {
            "title": "airdrop_start_time defines the timestamp of the airdrop start",
            "type": "string",
            "format": "date-time"
          },
          "duration_until_decay": {
            "title": "duration_until_decay of claimable tokens begin",
            "type": "string"
          },
          "duration_of_decay": {
            "title": "duration_of_decay for token claim decay period",
            "type": "string"
          },
          "claims_denom": {
            "title": "claims_denom is the denomination of the claimable coin",
            "type": "string"
          },
          "authorized_channels": {
            "type": "array",
            "description": "authorized_channels is the list of authorized channel identifiers that can perform address\nattestations via IBC.",
            "items": {
              "type": "string"
            }
          },
          "evm_channels": {
            "title": "evm_channels is the list of channel identifiers from EVM compatible chains",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "description": "Params defines the claims module's parameters."
      },
      "evmos.claims.v1.QueryClaimsRecordResponse": {
        "type": "object",
        "properties": {
          "initial_claimable_amount": {
            "title": "initial_claimable_amount of the user",
            "type": "string"
          },
          "claims": {
            "title": "claims of the user",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "action": {
                  "title": "action enum",
                  "type": "string",
                  "description": "Action defines the list of available actions to claim the airdrop tokens.\n\n - ACTION_UNSPECIFIED: ACTION_UNSPECIFIED defines an invalid action.\n - ACTION_VOTE: ACTION_VOTE defines a proposal vote.\n - ACTION_DELEGATE: ACTION_DELEGATE defines an staking delegation.\n - ACTION_EVM: ACTION_EVM defines an EVM transaction.\n - ACTION_IBC_TRANSFER: ACTION_IBC_TRANSFER defines a fungible token transfer transaction via IBC.",
                  "default": "ACTION_UNSPECIFIED",
                  "enum": [
                    "ACTION_UNSPECIFIED",
                    "ACTION_VOTE",
                    "ACTION_DELEGATE",
                    "ACTION_EVM",
                    "ACTION_IBC_TRANSFER"
                  ]
                },
                "completed": {
                  "title": "completed is true if the action has been completed",
                  "type": "boolean"
                },
                "claimable_amount": {
                  "title": "claimable_amount of tokens for the action. Zero if completed",
                  "type": "string"
                }
              },
              "description": "Claim defines the action, completed flag and the remaining claimable amount\nfor a given user. This is only used during client queries."
            }
          }
        },
        "description": "QueryClaimsRecordResponse is the response type for the Query/ClaimsRecord RPC\nmethod."
      },
      "evmos.claims.v1.QueryClaimsRecordsResponse": {
        "type": "object",
        "properties": {
          "claims": {
            "title": "claims defines all claims records",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "title": "address of claiming user in either bech32 or hex format",
                  "type": "string"
                },
                "initial_claimable_amount": {
                  "title": "initial_claimable_amount for the user",
                  "type": "string"
                },
                "actions_completed": {
                  "title": "actions_completed is a slice that describes which actions were completed",
                  "type": "array",
                  "items": {
                    "type": "boolean"
                  }
                }
              },
              "description": "ClaimsRecordAddress is the claims metadata per address that is used at\nGenesis."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryClaimsRecordsResponse is the response type for the Query/ClaimsRecords\nRPC method."
      },
      "evmos.claims.v1.QueryParamsResponse": {
        "type": "object",
        "properties": {
          "params": {
            "type": "object",
            "properties": {
              "enable_claims": {
                "title": "enable_claims is the parameter to enable the claiming process",
                "type": "boolean"
              },
              "airdrop_start_time": {
                "title": "airdrop_start_time defines the timestamp of the airdrop start",
                "type": "string",
                "format": "date-time"
              },
              "duration_until_decay": {
                "title": "duration_until_decay of claimable tokens begin",
                "type": "string"
              },
              "duration_of_decay": {
                "title": "duration_of_decay for token claim decay period",
                "type": "string"
              },
              "claims_denom": {
                "title": "claims_denom is the denomination of the claimable coin",
                "type": "string"
              },
              "authorized_channels": {
                "type": "array",
                "description": "authorized_channels is the list of authorized channel identifiers that can perform address\nattestations via IBC.",
                "items": {
                  "type": "string"
                }
              },
              "evm_channels": {
                "title": "evm_channels is the list of channel identifiers from EVM compatible chains",
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "description": "params defines the parameters of the module."
          }
        },
        "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
      },
      "evmos.claims.v1.QueryTotalUnclaimedResponse": {
        "type": "object",
        "properties": {
          "coins": {
            "title": "coins defines the unclaimed coins",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            }
          }
        },
        "description": "QueryTotalUnclaimedResponse is the response type for the Query/TotalUnclaimed\nRPC method."
      },
      "google.protobuf.Any": {
        "type": "object",
        "properties": {
          "type_url": {
            "type": "string",
            "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
          },
          "value": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "Must be a valid serialized protocol buffer of the above specified type.",
            "format": "byte"
          }
        },
        "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
      },
      "grpc.gateway.runtime.Error": {
        "type": "object",
        "properties": {
          "error": {
            "type": "string"
          },
          "code": {
            "type": "integer",
            "format": "int32"
          },
          "message": {
            "type": "string"
          },
          "details": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "byte"
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            }
          }
        }
      },
      "evmos.epochs.v1.EpochInfo": {
        "type": "object",
        "properties": {
          "identifier": {
            "title": "identifier of the epoch",
            "type": "string"
          },
          "start_time": {
            "title": "start_time of the epoch",
            "type": "string",
            "format": "date-time"
          },
          "duration": {
            "title": "duration of the epoch",
            "type": "string"
          },
          "current_epoch": {
            "title": "current_epoch is the integer identifier of the epoch",
            "type": "string",
            "format": "int64"
          },
          "current_epoch_start_time": {
            "title": "current_epoch_start_time defines the timestamp of the start of the epoch",
            "type": "string",
            "format": "date-time"
          },
          "epoch_counting_started": {
            "title": "epoch_counting_started reflects if the counting for the epoch has started",
            "type": "boolean"
          },
          "current_epoch_start_height": {
            "title": "current_epoch_start_height of the epoch",
            "type": "string",
            "format": "int64"
          }
        },
        "description": "EpochInfo defines the message interface containing the relevant informations about\nan epoch."
      },
      "evmos.epochs.v1.QueryCurrentEpochResponse": {
        "type": "object",
        "properties": {
          "current_epoch": {
            "title": "current_epoch is the number of the current epoch",
            "type": "string",
            "format": "int64"
          }
        },
        "description": "QueryCurrentEpochResponse is the response type for the Query/EpochInfos RPC\nmethod."
      },
      "evmos.epochs.v1.QueryEpochsInfoResponse": {
        "type": "object",
        "properties": {
          "epochs": {
            "title": "epochs is a slice of all EpochInfos",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "identifier": {
                  "title": "identifier of the epoch",
                  "type": "string"
                },
                "start_time": {
                  "title": "start_time of the epoch",
                  "type": "string",
                  "format": "date-time"
                },
                "duration": {
                  "title": "duration of the epoch",
                  "type": "string"
                },
                "current_epoch": {
                  "title": "current_epoch is the integer identifier of the epoch",
                  "type": "string",
                  "format": "int64"
                },
                "current_epoch_start_time": {
                  "title": "current_epoch_start_time defines the timestamp of the start of the epoch",
                  "type": "string",
                  "format": "date-time"
                },
                "epoch_counting_started": {
                  "title": "epoch_counting_started reflects if the counting for the epoch has started",
                  "type": "boolean"
                },
                "current_epoch_start_height": {
                  "title": "current_epoch_start_height of the epoch",
                  "type": "string",
                  "format": "int64"
                }
              },
              "description": "EpochInfo defines the message interface containing the relevant informations about\nan epoch."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines an optional pagination for the request."
          }
        },
        "description": "QueryEpochsInfoResponse is the response type for the Query/EpochInfos RPC\nmethod."
      },
      "evmos.erc20.v1.Owner": {
        "type": "string",
        "description": "Owner enumerates the ownership of a ERC20 contract.\n\n - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.\n - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.\n - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account.",
        "default": "OWNER_UNSPECIFIED",
        "enum": [
          "OWNER_UNSPECIFIED",
          "OWNER_MODULE",
          "OWNER_EXTERNAL"
        ]
      },
      "evmos.erc20.v1.Params": {
        "title": "Params defines the erc20 module params",
        "type": "object",
        "properties": {
          "enable_erc20": {
            "type": "boolean",
            "description": "enable_erc20 is the parameter to enable the conversion of Cosmos coins <--> ERC20 tokens."
          },
          "enable_evm_hook": {
            "type": "boolean",
            "description": "enable_evm_hook is the parameter to enable the EVM hook that converts an ERC20 token to a Cosmos\nCoin by transferring the Tokens through a MsgEthereumTx to the ModuleAddress Ethereum address."
          }
        }
      },
      "evmos.erc20.v1.QueryParamsResponse": {
        "type": "object",
        "properties": {
          "params": {
            "title": "params are the erc20 module parameters",
            "type": "object",
            "properties": {
              "enable_erc20": {
                "type": "boolean",
                "description": "enable_erc20 is the parameter to enable the conversion of Cosmos coins <--> ERC20 tokens."
              },
              "enable_evm_hook": {
                "type": "boolean",
                "description": "enable_evm_hook is the parameter to enable the EVM hook that converts an ERC20 token to a Cosmos\nCoin by transferring the Tokens through a MsgEthereumTx to the ModuleAddress Ethereum address."
              }
            }
          }
        },
        "description": "QueryParamsResponse is the response type for the Query/Params RPC\nmethod."
      },
      "evmos.erc20.v1.QueryTokenPairResponse": {
        "type": "object",
        "properties": {
          "token_pair": {
            "title": "token_pairs returns the info about a registered token pair for the erc20 module",
            "type": "object",
            "properties": {
              "erc20_address": {
                "title": "erc20_address is the hex address of ERC20 contract token",
                "type": "string"
              },
              "denom": {
                "title": "denom defines the cosmos base denomination to be mapped to",
                "type": "string"
              },
              "enabled": {
                "title": "enabled defines the token mapping enable status",
                "type": "boolean"
              },
              "contract_owner": {
                "title": "contract_owner is the an ENUM specifying the type of ERC20 owner (0 invalid, 1 ModuleAccount, 2 external address)",
                "type": "string",
                "description": "Owner enumerates the ownership of a ERC20 contract.\n\n - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.\n - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.\n - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account.",
                "default": "OWNER_UNSPECIFIED",
                "enum": [
                  "OWNER_UNSPECIFIED",
                  "OWNER_MODULE",
                  "OWNER_EXTERNAL"
                ]
              }
            },
            "description": "TokenPair defines an instance that records a pairing consisting of a native\n Cosmos Coin and an ERC20 token address."
          }
        },
        "description": "QueryTokenPairResponse is the response type for the Query/TokenPair RPC\nmethod."
      },
      "evmos.erc20.v1.QueryTokenPairsResponse": {
        "type": "object",
        "properties": {
          "token_pairs": {
            "title": "token_pairs is a slice of registered token pairs for the erc20 module",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "erc20_address": {
                  "title": "erc20_address is the hex address of ERC20 contract token",
                  "type": "string"
                },
                "denom": {
                  "title": "denom defines the cosmos base denomination to be mapped to",
                  "type": "string"
                },
                "enabled": {
                  "title": "enabled defines the token mapping enable status",
                  "type": "boolean"
                },
                "contract_owner": {
                  "title": "contract_owner is the an ENUM specifying the type of ERC20 owner (0 invalid, 1 ModuleAccount, 2 external address)",
                  "type": "string",
                  "description": "Owner enumerates the ownership of a ERC20 contract.\n\n - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.\n - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.\n - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account.",
                  "default": "OWNER_UNSPECIFIED",
                  "enum": [
                    "OWNER_UNSPECIFIED",
                    "OWNER_MODULE",
                    "OWNER_EXTERNAL"
                  ]
                }
              },
              "description": "TokenPair defines an instance that records a pairing consisting of a native\n Cosmos Coin and an ERC20 token address."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryTokenPairsResponse is the response type for the Query/TokenPairs RPC\nmethod."
      },
      "evmos.erc20.v1.TokenPair": {
        "type": "object",
        "properties": {
          "erc20_address": {
            "title": "erc20_address is the hex address of ERC20 contract token",
            "type": "string"
          },
          "denom": {
            "title": "denom defines the cosmos base denomination to be mapped to",
            "type": "string"
          },
          "enabled": {
            "title": "enabled defines the token mapping enable status",
            "type": "boolean"
          },
          "contract_owner": {
            "title": "contract_owner is the an ENUM specifying the type of ERC20 owner (0 invalid, 1 ModuleAccount, 2 external address)",
            "type": "string",
            "description": "Owner enumerates the ownership of a ERC20 contract.\n\n - OWNER_UNSPECIFIED: OWNER_UNSPECIFIED defines an invalid/undefined owner.\n - OWNER_MODULE: OWNER_MODULE - erc20 is owned by the erc20 module account.\n - OWNER_EXTERNAL: OWNER_EXTERNAL - erc20 is owned by an external account.",
            "default": "OWNER_UNSPECIFIED",
            "enum": [
              "OWNER_UNSPECIFIED",
              "OWNER_MODULE",
              "OWNER_EXTERNAL"
            ]
          }
        },
        "description": "TokenPair defines an instance that records a pairing consisting of a native\n Cosmos Coin and an ERC20 token address."
      },
      "cosmos.base.v1beta1.DecCoin": {
        "type": "object",
        "properties": {
          "denom": {
            "type": "string"
          },
          "amount": {
            "type": "string"
          }
        },
        "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
      },
      "evmos.incentives.v1.GasMeter": {
        "title": "GasMeter tracks the cumulative gas spent per participant in one epoch",
        "type": "object",
        "properties": {
          "contract": {
            "title": "contract is the hex address of the incentivized smart contract",
            "type": "string"
          },
          "participant": {
            "title": "participant address that interacts with the incentive",
            "type": "string"
          },
          "cumulative_gas": {
            "title": "cumulative_gas spent during the epoch",
            "type": "string",
            "format": "uint64"
          }
        }
      },
      "evmos.incentives.v1.Incentive": {
        "title": "Incentive defines an instance that organizes distribution conditions for a\ngiven smart contract",
        "type": "object",
        "properties": {
          "contract": {
            "title": "contract address of the smart contract to be incentivized",
            "type": "string"
          },
          "allocations": {
            "title": "allocations is a slice of denoms and percentages of rewards to be allocated",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
            }
          },
          "epochs": {
            "title": "epochs defines the number of remaining epochs for the incentive",
            "type": "integer",
            "format": "int64"
          },
          "start_time": {
            "title": "start_time of the incentive distribution",
            "type": "string",
            "format": "date-time"
          },
          "total_gas": {
            "title": "total_gas is the cumulative gas spent by all gas meters of the incentive during the epoch",
            "type": "string",
            "format": "uint64"
          }
        }
      },
      "evmos.incentives.v1.Params": {
        "title": "Params defines the incentives module params",
        "type": "object",
        "properties": {
          "enable_incentives": {
            "title": "enable_incentives is the parameter to enable incentives",
            "type": "boolean"
          },
          "allocation_limit": {
            "title": "allocation_limit is the maximum percentage an incentive can allocate per denomination",
            "type": "string"
          },
          "incentives_epoch_identifier": {
            "title": "incentives_epoch_identifier for the epochs module hooks",
            "type": "string"
          },
          "reward_scaler": {
            "title": "reward_scaler is the scaling factor for capping rewards",
            "type": "string"
          }
        }
      },
      "evmos.incentives.v1.QueryAllocationMeterResponse": {
        "type": "object",
        "properties": {
          "allocation_meter": {
            "title": "allocation_meter defines the allocation of the queried denom",
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
          }
        },
        "description": "QueryAllocationMeterResponse is the response type for the\nQuery/AllocationMeter RPC method."
      },
      "evmos.incentives.v1.QueryAllocationMetersResponse": {
        "type": "object",
        "properties": {
          "allocation_meters": {
            "title": "allocation_meters is a slice of all allocations",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryAllocationMetersResponse is the response type for the\nQuery/AllocationMeters RPC method."
      },
      "evmos.incentives.v1.QueryGasMeterResponse": {
        "type": "object",
        "properties": {
          "gas_meter": {
            "title": "gas_meter is a gas meter for one participant on an incentivized smart contract",
            "type": "string",
            "format": "uint64"
          }
        },
        "description": "QueryGasMeterResponse is the response type for the Query/Incentive RPC\nmethod."
      },
      "evmos.incentives.v1.QueryGasMetersResponse": {
        "type": "object",
        "properties": {
          "gas_meters": {
            "title": "gas_meters is a slice of the gas meters for an incentivized smart contract",
            "type": "array",
            "items": {
              "title": "GasMeter tracks the cumulative gas spent per participant in one epoch",
              "type": "object",
              "properties": {
                "contract": {
                  "title": "contract is the hex address of the incentivized smart contract",
                  "type": "string"
                },
                "participant": {
                  "title": "participant address that interacts with the incentive",
                  "type": "string"
                },
                "cumulative_gas": {
                  "title": "cumulative_gas spent during the epoch",
                  "type": "string",
                  "format": "uint64"
                }
              }
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryGasMetersResponse is the response type for the Query/Incentives RPC\nmethod."
      },
      "evmos.incentives.v1.QueryIncentiveResponse": {
        "type": "object",
        "properties": {
          "incentive": {
            "title": "Incentive defines an instance that organizes distribution conditions for a\ngiven smart contract",
            "type": "object",
            "properties": {
              "contract": {
                "title": "contract address of the smart contract to be incentivized",
                "type": "string"
              },
              "allocations": {
                "title": "allocations is a slice of denoms and percentages of rewards to be allocated",
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "epochs": {
                "title": "epochs defines the number of remaining epochs for the incentive",
                "type": "integer",
                "format": "int64"
              },
              "start_time": {
                "title": "start_time of the incentive distribution",
                "type": "string",
                "format": "date-time"
              },
              "total_gas": {
                "title": "total_gas is the cumulative gas spent by all gas meters of the incentive during the epoch",
                "type": "string",
                "format": "uint64"
              }
            }
          }
        },
        "description": "QueryIncentiveResponse is the response type for the Query/Incentive RPC\nmethod."
      },
      "evmos.incentives.v1.QueryIncentivesResponse": {
        "type": "object",
        "properties": {
          "incentives": {
            "title": "incentives is a slice of all incentives",
            "type": "array",
            "items": {
              "title": "Incentive defines an instance that organizes distribution conditions for a\ngiven smart contract",
              "type": "object",
              "properties": {
                "contract": {
                  "title": "contract address of the smart contract to be incentivized",
                  "type": "string"
                },
                "allocations": {
                  "title": "allocations is a slice of denoms and percentages of rewards to be allocated",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                  }
                },
                "epochs": {
                  "title": "epochs defines the number of remaining epochs for the incentive",
                  "type": "integer",
                  "format": "int64"
                },
                "start_time": {
                  "title": "start_time of the incentive distribution",
                  "type": "string",
                  "format": "date-time"
                },
                "total_gas": {
                  "title": "total_gas is the cumulative gas spent by all gas meters of the incentive during the epoch",
                  "type": "string",
                  "format": "uint64"
                }
              }
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryIncentivesResponse is the response type for the Query/Incentives RPC\nmethod."
      },
      "evmos.incentives.v1.QueryParamsResponse": {
        "type": "object",
        "properties": {
          "params": {
            "title": "params are the incentives module parameters",
            "type": "object",
            "properties": {
              "enable_incentives": {
                "title": "enable_incentives is the parameter to enable incentives",
                "type": "boolean"
              },
              "allocation_limit": {
                "title": "allocation_limit is the maximum percentage an incentive can allocate per denomination",
                "type": "string"
              },
              "incentives_epoch_identifier": {
                "title": "incentives_epoch_identifier for the epochs module hooks",
                "type": "string"
              },
              "reward_scaler": {
                "title": "reward_scaler is the scaling factor for capping rewards",
                "type": "string"
              }
            }
          }
        },
        "description": "QueryParamsResponse is the response type for the Query/Params RPC\nmethod."
      },
      "evmos.inflation.v1.ExponentialCalculation": {
        "title": "ExponentialCalculation holds factors to calculate exponential inflation on\neach period. Calculation reference:\nperiodProvision = exponentialDecay       *  bondingIncentive\nf(x)            = (a * (1 - r) ^ x + c)  *  (1 + max_variance - bondedRatio *\n(max_variance / bonding_target))",
        "type": "object",
        "properties": {
          "a": {
            "title": "a defines the initial value",
            "type": "string"
          },
          "r": {
            "title": "r defines the reduction factor",
            "type": "string"
          },
          "c": {
            "title": "c defines the parameter for long term inflation",
            "type": "string"
          },
          "bonding_target": {
            "title": "bonding_target",
            "type": "string"
          },
          "max_variance": {
            "title": "max_variance",
            "type": "string"
          }
        }
      },
      "evmos.inflation.v1.InflationDistribution": {
        "title": "InflationDistribution defines the distribution in which inflation is\nallocated through minting on each epoch (staking, incentives, community). It\nexcludes the team vesting distribution, as this is minted once at genesis.\nThe initial InflationDistribution can be calculated from the Evmos Token\nModel like this:\nmintDistribution1 = distribution1 / (1 - teamVestingDistribution)\n0.5333333         = 40%           / (1 - 25%)",
        "type": "object",
        "properties": {
          "staking_rewards": {
            "title": "staking_rewards defines the proportion of the minted minted_denom that is\nto be allocated as staking rewards",
            "type": "string"
          },
          "usage_incentives": {
            "title": "usage_incentives defines the proportion of the minted minted_denom that is\nto be allocated to the incentives module address",
            "type": "string"
          },
          "community_pool": {
            "title": "community_pool defines the proportion of the minted minted_denom that is to\nbe allocated to the community pool",
            "type": "string"
          }
        }
      },
      "evmos.inflation.v1.Params": {
        "type": "object",
        "properties": {
          "mint_denom": {
            "title": "mint_denom specifies the type of coin to mint",
            "type": "string"
          },
          "exponential_calculation": {
            "title": "exponential_calculation takes in the variables to calculate exponential inflation",
            "type": "object",
            "properties": {
              "a": {
                "title": "a defines the initial value",
                "type": "string"
              },
              "r": {
                "title": "r defines the reduction factor",
                "type": "string"
              },
              "c": {
                "title": "c defines the parameter for long term inflation",
                "type": "string"
              },
              "bonding_target": {
                "title": "bonding_target",
                "type": "string"
              },
              "max_variance": {
                "title": "max_variance",
                "type": "string"
              }
            }
          },
          "inflation_distribution": {
            "title": "inflation_distribution of the minted denom",
            "type": "object",
            "properties": {
              "staking_rewards": {
                "title": "staking_rewards defines the proportion of the minted minted_denom that is\nto be allocated as staking rewards",
                "type": "string"
              },
              "usage_incentives": {
                "title": "usage_incentives defines the proportion of the minted minted_denom that is\nto be allocated to the incentives module address",
                "type": "string"
              },
              "community_pool": {
                "title": "community_pool defines the proportion of the minted minted_denom that is to\nbe allocated to the community pool",
                "type": "string"
              }
            }
          },
          "enable_inflation": {
            "title": "enable_inflation is the parameter that enables inflation and halts increasing the skipped_epochs",
            "type": "boolean"
          }
        },
        "description": "Params holds parameters for the inflation module."
      },
      "evmos.inflation.v1.QueryCirculatingSupplyResponse": {
        "type": "object",
        "properties": {
          "circulating_supply": {
            "title": "circulating_supply is the total amount of coins in circulation",
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
          }
        },
        "description": "QueryCirculatingSupplyResponse is the response type for the\nQuery/CirculatingSupply RPC method."
      },
      "evmos.inflation.v1.QueryEpochMintProvisionResponse": {
        "type": "object",
        "properties": {
          "epoch_mint_provision": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "epoch_mint_provision is the current minting per epoch provision value."
          }
        },
        "description": "QueryEpochMintProvisionResponse is the response type for the\nQuery/EpochMintProvision RPC method."
      },
      "evmos.inflation.v1.QueryInflationRateResponse": {
        "type": "object",
        "properties": {
          "inflation_rate": {
            "title": "inflation_rate by which the total supply increases within one period",
            "type": "string"
          }
        },
        "description": "QueryInflationRateResponse is the response type for the Query/InflationRate\nRPC method."
      },
      "evmos.inflation.v1.QueryParamsResponse": {
        "type": "object",
        "properties": {
          "params": {
            "type": "object",
            "properties": {
              "mint_denom": {
                "title": "mint_denom specifies the type of coin to mint",
                "type": "string"
              },
              "exponential_calculation": {
                "title": "exponential_calculation takes in the variables to calculate exponential inflation",
                "type": "object",
                "properties": {
                  "a": {
                    "title": "a defines the initial value",
                    "type": "string"
                  },
                  "r": {
                    "title": "r defines the reduction factor",
                    "type": "string"
                  },
                  "c": {
                    "title": "c defines the parameter for long term inflation",
                    "type": "string"
                  },
                  "bonding_target": {
                    "title": "bonding_target",
                    "type": "string"
                  },
                  "max_variance": {
                    "title": "max_variance",
                    "type": "string"
                  }
                }
              },
              "inflation_distribution": {
                "title": "inflation_distribution of the minted denom",
                "type": "object",
                "properties": {
                  "staking_rewards": {
                    "title": "staking_rewards defines the proportion of the minted minted_denom that is\nto be allocated as staking rewards",
                    "type": "string"
                  },
                  "usage_incentives": {
                    "title": "usage_incentives defines the proportion of the minted minted_denom that is\nto be allocated to the incentives module address",
                    "type": "string"
                  },
                  "community_pool": {
                    "title": "community_pool defines the proportion of the minted minted_denom that is to\nbe allocated to the community pool",
                    "type": "string"
                  }
                }
              },
              "enable_inflation": {
                "title": "enable_inflation is the parameter that enables inflation and halts increasing the skipped_epochs",
                "type": "boolean"
              }
            },
            "description": "params defines the parameters of the module."
          }
        },
        "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
      },
      "evmos.inflation.v1.QueryPeriodResponse": {
        "type": "object",
        "properties": {
          "period": {
            "type": "string",
            "description": "period is the current minting per epoch provision value.",
            "format": "uint64"
          }
        },
        "description": "QueryPeriodResponse is the response type for the Query/Period RPC method."
      },
      "evmos.inflation.v1.QuerySkippedEpochsResponse": {
        "type": "object",
        "properties": {
          "skipped_epochs": {
            "type": "string",
            "description": "skipped_epochs is the number of epochs that the inflation module has been disabled.",
            "format": "uint64"
          }
        },
        "description": "QuerySkippedEpochsResponse is the response type for the Query/SkippedEpochs\nRPC method."
      },
      "evmos.vesting.v1.QueryBalancesResponse": {
        "type": "object",
        "properties": {
          "locked": {
            "title": "locked defines the current amount of locked tokens",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            }
          },
          "unvested": {
            "title": "unvested defines the current amount of unvested tokens",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            }
          },
          "vested": {
            "title": "vested defines the current amount of vested tokens",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            }
          }
        },
        "description": "QueryBalancesResponse is the response type for the Query/Balances RPC\nmethod."
      },
      "evmos.recovery.v1.Params": {
        "title": "Params holds parameters for the recovery module",
        "type": "object",
        "properties": {
          "enable_recovery": {
            "title": "enable_recovery IBC middleware",
            "type": "boolean"
          },
          "packet_timeout_duration": {
            "title": "packet_timeout_duration is the duration added to timeout timestamp for balances recovered via IBC packets",
            "type": "string"
          }
        }
      },
      "evmos.recovery.v1.QueryParamsResponse": {
        "type": "object",
        "properties": {
          "params": {
            "title": "Params holds parameters for the recovery module",
            "type": "object",
            "properties": {
              "enable_recovery": {
                "title": "enable_recovery IBC middleware",
                "type": "boolean"
              },
              "packet_timeout_duration": {
                "title": "packet_timeout_duration is the duration added to timeout timestamp for balances recovered via IBC packets",
                "type": "string"
              }
            },
            "description": "params defines the parameters of the module."
          }
        },
        "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
      },
      "evmos.revenue.v1.Params": {
        "title": "Params defines the revenue module params",
        "type": "object",
        "properties": {
          "enable_revenue": {
            "title": "enable_revenue defines a parameter to enable the revenue module",
            "type": "boolean"
          },
          "developer_shares": {
            "title": "developer_shares defines the proportion of the transaction fees to be\ndistributed to the registered contract owner",
            "type": "string"
          },
          "addr_derivation_cost_create": {
            "title": "addr_derivation_cost_create defines the cost of address derivation for\nverifying the contract deployer at fee registration",
            "type": "string",
            "format": "uint64"
          }
        }
      },
      "evmos.revenue.v1.QueryDeployerRevenuesResponse": {
        "type": "object",
        "properties": {
          "contract_addresses": {
            "title": "contract_addresses is the slice of registered contract addresses for a deployer",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryDeployerRevenuesResponse is the response type for the\nQuery/DeployerRevenues RPC method."
      },
      "evmos.revenue.v1.QueryParamsResponse": {
        "type": "object",
        "properties": {
          "params": {
            "title": "params is the returned revenue parameter",
            "type": "object",
            "properties": {
              "enable_revenue": {
                "title": "enable_revenue defines a parameter to enable the revenue module",
                "type": "boolean"
              },
              "developer_shares": {
                "title": "developer_shares defines the proportion of the transaction fees to be\ndistributed to the registered contract owner",
                "type": "string"
              },
              "addr_derivation_cost_create": {
                "title": "addr_derivation_cost_create defines the cost of address derivation for\nverifying the contract deployer at fee registration",
                "type": "string",
                "format": "uint64"
              }
            }
          }
        },
        "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
      },
      "evmos.revenue.v1.QueryRevenueResponse": {
        "type": "object",
        "properties": {
          "revenue": {
            "title": "Revenue defines an instance that organizes fee distribution conditions for\nthe owner of a given smart contract",
            "type": "object",
            "properties": {
              "contract_address": {
                "title": "contract_address is the hex address of a registered contract",
                "type": "string"
              },
              "deployer_address": {
                "title": "deployer_address is the bech32 address of message sender. It must be the same as the origin EOA\nsending the transaction which deploys the contract",
                "type": "string"
              },
              "withdrawer_address": {
                "title": "withdrawer_address is the bech32 address of account receiving the transaction fees it defaults to\ndeployer_address",
                "type": "string"
              }
            }
          }
        },
        "description": "QueryRevenueResponse is the response type for the Query/Revenue RPC method."
      },
      "evmos.revenue.v1.QueryRevenuesResponse": {
        "type": "object",
        "properties": {
          "revenues": {
            "title": "revenues is a slice of all stored Reveneue",
            "type": "array",
            "items": {
              "title": "Revenue defines an instance that organizes fee distribution conditions for\nthe owner of a given smart contract",
              "type": "object",
              "properties": {
                "contract_address": {
                  "title": "contract_address is the hex address of a registered contract",
                  "type": "string"
                },
                "deployer_address": {
                  "title": "deployer_address is the bech32 address of message sender. It must be the same as the origin EOA\nsending the transaction which deploys the contract",
                  "type": "string"
                },
                "withdrawer_address": {
                  "title": "withdrawer_address is the bech32 address of account receiving the transaction fees it defaults to\ndeployer_address",
                  "type": "string"
                }
              }
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryRevenuesResponse is the response type for the Query/Revenues RPC method."
      },
      "evmos.revenue.v1.QueryWithdrawerRevenuesResponse": {
        "type": "object",
        "properties": {
          "contract_addresses": {
            "title": "contract_addresses is the slice of registered contract addresses for a withdrawer",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryWithdrawerRevenuesResponse is the response type for the\nQuery/WithdrawerRevenues RPC method."
      },
      "evmos.revenue.v1.Revenue": {
        "title": "Revenue defines an instance that organizes fee distribution conditions for\nthe owner of a given smart contract",
        "type": "object",
        "properties": {
          "contract_address": {
            "title": "contract_address is the hex address of a registered contract",
            "type": "string"
          },
          "deployer_address": {
            "title": "deployer_address is the bech32 address of message sender. It must be the same as the origin EOA\nsending the transaction which deploys the contract",
            "type": "string"
          },
          "withdrawer_address": {
            "title": "withdrawer_address is the bech32 address of account receiving the transaction fees it defaults to\ndeployer_address",
            "type": "string"
          }
        }
      },
      "ethermint.evm.v1.ChainConfig": {
        "type": "object",
        "properties": {
          "homestead_block": {
            "title": "homestead_block switch (nil no fork, 0 = already homestead)",
            "type": "string"
          },
          "dao_fork_block": {
            "title": "dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork)",
            "type": "string"
          },
          "dao_fork_support": {
            "title": "dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork",
            "type": "boolean"
          },
          "eip150_block": {
            "title": "eip150_block: EIP150 implements the Gas price changes\n(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)",
            "type": "string"
          },
          "eip150_hash": {
            "title": "eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed)",
            "type": "string"
          },
          "eip155_block": {
            "title": "eip155_block: EIP155Block HF block",
            "type": "string"
          },
          "eip158_block": {
            "title": "eip158_block: EIP158 HF block",
            "type": "string"
          },
          "byzantium_block": {
            "title": "byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium)",
            "type": "string"
          },
          "constantinople_block": {
            "title": "constantinople_block: Constantinople switch block (nil no fork, 0 = already activated)",
            "type": "string"
          },
          "petersburg_block": {
            "title": "petersburg_block: Petersburg switch block (nil same as Constantinople)",
            "type": "string"
          },
          "istanbul_block": {
            "title": "istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul)",
            "type": "string"
          },
          "muir_glacier_block": {
            "title": "muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated)",
            "type": "string"
          },
          "berlin_block": {
            "title": "berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin)",
            "type": "string"
          },
          "london_block": {
            "title": "london_block: London switch block (nil = no fork, 0 = already on london)",
            "type": "string"
          },
          "arrow_glacier_block": {
            "title": "arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated)",
            "type": "string"
          },
          "gray_glacier_block": {
            "title": "gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated)",
            "type": "string"
          },
          "merge_netsplit_block": {
            "title": "merge_netsplit_block: Virtual fork after The Merge to use as a network splitter",
            "type": "string"
          },
          "shanghai_block": {
            "title": "shanghai_block switch block (nil = no fork, 0 = already on shanghai)",
            "type": "string"
          },
          "cancun_block": {
            "title": "cancun_block switch block (nil = no fork, 0 = already on cancun)",
            "type": "string"
          }
        },
        "description": "ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values\ninstead of *big.Int."
      },
      "ethermint.evm.v1.EstimateGasResponse": {
        "title": "EstimateGasResponse defines EstimateGas response",
        "type": "object",
        "properties": {
          "gas": {
            "title": "gas returns the estimated gas",
            "type": "string",
            "format": "uint64"
          }
        }
      },
      "ethermint.evm.v1.Log": {
        "type": "object",
        "properties": {
          "address": {
            "title": "address of the contract that generated the event",
            "type": "string"
          },
          "topics": {
            "type": "array",
            "description": "topics is a list of topics provided by the contract.",
            "items": {
              "type": "string"
            }
          },
          "data": {
            "title": "data which is supplied by the contract, usually ABI-encoded",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "block_number": {
            "title": "block_number of the block in which the transaction was included",
            "type": "string",
            "format": "uint64"
          },
          "tx_hash": {
            "title": "tx_hash is the transaction hash",
            "type": "string"
          },
          "tx_index": {
            "title": "tx_index of the transaction in the block",
            "type": "string",
            "format": "uint64"
          },
          "block_hash": {
            "title": "block_hash of the block in which the transaction was included",
            "type": "string"
          },
          "index": {
            "title": "index of the log in the block",
            "type": "string",
            "format": "uint64"
          },
          "removed": {
            "type": "boolean",
            "description": "removed is true if this log was reverted due to a chain\nreorganisation. You must pay attention to this field if you receive logs\nthrough a filter query."
          }
        },
        "description": "Log represents an protobuf compatible Ethereum Log that defines a contract\nlog event. These events are generated by the LOG opcode and stored/indexed by\nthe node.\n\nNOTE: address, topics and data are consensus fields. The rest of the fields\nare derived, i.e. filled in by the nodes, but not secured by consensus."
      },
      "ethermint.evm.v1.MsgEthereumTx": {
        "type": "object",
        "properties": {
          "data": {
            "title": "data is inner transaction data of the Ethereum transaction",
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "size": {
            "title": "size is the encoded storage size of the transaction (DEPRECATED)",
            "type": "number",
            "format": "double"
          },
          "hash": {
            "title": "hash of the transaction in hex format",
            "type": "string"
          },
          "from": {
            "title": "from is the ethereum signer address in hex format. This address value is checked\nagainst the address derived from the signature (V, R, S) using the\nsecp256k1 elliptic curve",
            "type": "string"
          }
        },
        "description": "MsgEthereumTx encapsulates an Ethereum transaction as an SDK message."
      },
      "ethermint.evm.v1.MsgEthereumTxResponse": {
        "type": "object",
        "properties": {
          "hash": {
            "title": "hash of the ethereum transaction in hex format. This hash differs from the\nTendermint sha256 hash of the transaction bytes. See\nhttps://github.com/tendermint/tendermint/issues/6539 for reference",
            "type": "string"
          },
          "logs": {
            "type": "array",
            "description": "logs contains the transaction hash and the proto-compatible ethereum\nlogs.",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "title": "address of the contract that generated the event",
                  "type": "string"
                },
                "topics": {
                  "type": "array",
                  "description": "topics is a list of topics provided by the contract.",
                  "items": {
                    "type": "string"
                  }
                },
                "data": {
                  "title": "data which is supplied by the contract, usually ABI-encoded",
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "format": "byte"
                },
                "block_number": {
                  "title": "block_number of the block in which the transaction was included",
                  "type": "string",
                  "format": "uint64"
                },
                "tx_hash": {
                  "title": "tx_hash is the transaction hash",
                  "type": "string"
                },
                "tx_index": {
                  "title": "tx_index of the transaction in the block",
                  "type": "string",
                  "format": "uint64"
                },
                "block_hash": {
                  "title": "block_hash of the block in which the transaction was included",
                  "type": "string"
                },
                "index": {
                  "title": "index of the log in the block",
                  "type": "string",
                  "format": "uint64"
                },
                "removed": {
                  "type": "boolean",
                  "description": "removed is true if this log was reverted due to a chain\nreorganisation. You must pay attention to this field if you receive logs\nthrough a filter query."
                }
              },
              "description": "Log represents an protobuf compatible Ethereum Log that defines a contract\nlog event. These events are generated by the LOG opcode and stored/indexed by\nthe node.\n\nNOTE: address, topics and data are consensus fields. The rest of the fields\nare derived, i.e. filled in by the nodes, but not secured by consensus."
            }
          },
          "ret": {
            "title": "ret is the returned data from evm function (result or data supplied with revert\nopcode)",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "vm_error": {
            "title": "vm_error is the error returned by vm execution",
            "type": "string"
          },
          "gas_used": {
            "title": "gas_used specifies how much gas was consumed by the transaction",
            "type": "string",
            "format": "uint64"
          }
        },
        "description": "MsgEthereumTxResponse defines the Msg/EthereumTx response type."
      },
      "ethermint.evm.v1.Params": {
        "title": "Params defines the EVM module parameters",
        "type": "object",
        "properties": {
          "evm_denom": {
            "type": "string",
            "description": "evm_denom represents the token denomination used to run the EVM state\ntransitions."
          },
          "enable_create": {
            "title": "enable_create toggles state transitions that use the vm.Create function",
            "type": "boolean"
          },
          "enable_call": {
            "title": "enable_call toggles state transitions that use the vm.Call function",
            "type": "boolean"
          },
          "extra_eips": {
            "title": "extra_eips defines the additional EIPs for the vm.Config",
            "type": "array",
            "items": {
              "type": "string",
              "format": "int64"
            }
          },
          "chain_config": {
            "title": "chain_config defines the EVM chain configuration parameters",
            "type": "object",
            "properties": {
              "homestead_block": {
                "title": "homestead_block switch (nil no fork, 0 = already homestead)",
                "type": "string"
              },
              "dao_fork_block": {
                "title": "dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork)",
                "type": "string"
              },
              "dao_fork_support": {
                "title": "dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork",
                "type": "boolean"
              },
              "eip150_block": {
                "title": "eip150_block: EIP150 implements the Gas price changes\n(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)",
                "type": "string"
              },
              "eip150_hash": {
                "title": "eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed)",
                "type": "string"
              },
              "eip155_block": {
                "title": "eip155_block: EIP155Block HF block",
                "type": "string"
              },
              "eip158_block": {
                "title": "eip158_block: EIP158 HF block",
                "type": "string"
              },
              "byzantium_block": {
                "title": "byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium)",
                "type": "string"
              },
              "constantinople_block": {
                "title": "constantinople_block: Constantinople switch block (nil no fork, 0 = already activated)",
                "type": "string"
              },
              "petersburg_block": {
                "title": "petersburg_block: Petersburg switch block (nil same as Constantinople)",
                "type": "string"
              },
              "istanbul_block": {
                "title": "istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul)",
                "type": "string"
              },
              "muir_glacier_block": {
                "title": "muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated)",
                "type": "string"
              },
              "berlin_block": {
                "title": "berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin)",
                "type": "string"
              },
              "london_block": {
                "title": "london_block: London switch block (nil = no fork, 0 = already on london)",
                "type": "string"
              },
              "arrow_glacier_block": {
                "title": "arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated)",
                "type": "string"
              },
              "gray_glacier_block": {
                "title": "gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated)",
                "type": "string"
              },
              "merge_netsplit_block": {
                "title": "merge_netsplit_block: Virtual fork after The Merge to use as a network splitter",
                "type": "string"
              },
              "shanghai_block": {
                "title": "shanghai_block switch block (nil = no fork, 0 = already on shanghai)",
                "type": "string"
              },
              "cancun_block": {
                "title": "cancun_block switch block (nil = no fork, 0 = already on cancun)",
                "type": "string"
              }
            },
            "description": "ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values\ninstead of *big.Int."
          },
          "allow_unprotected_txs": {
            "type": "boolean",
            "description": "allow_unprotected_txs defines if replay-protected (i.e non EIP155\nsigned) transactions can be executed on the state machine."
          },
          "active_precompiles": {
            "title": "active_precompiles defines the slice of hex addresses of the precompiled\ncontracts that are active",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        }
      },
      "ethermint.evm.v1.QueryAccountResponse": {
        "type": "object",
        "properties": {
          "balance": {
            "type": "string",
            "description": "balance is the balance of the EVM denomination."
          },
          "code_hash": {
            "type": "string",
            "description": "code_hash is the hex-formatted code bytes from the EOA."
          },
          "nonce": {
            "type": "string",
            "description": "nonce is the account's sequence number.",
            "format": "uint64"
          }
        },
        "description": "QueryAccountResponse is the response type for the Query/Account RPC method."
      },
      "ethermint.evm.v1.QueryBalanceResponse": {
        "type": "object",
        "properties": {
          "balance": {
            "type": "string",
            "description": "balance is the balance of the EVM denomination."
          }
        },
        "description": "QueryBalanceResponse is the response type for the Query/Balance RPC method."
      },
      "ethermint.evm.v1.QueryBaseFeeResponse": {
        "type": "object",
        "properties": {
          "base_fee": {
            "title": "base_fee is the EIP1559 base fee",
            "type": "string"
          }
        },
        "description": "QueryBaseFeeResponse returns the EIP1559 base fee."
      },
      "ethermint.evm.v1.QueryCodeResponse": {
        "type": "object",
        "properties": {
          "code": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "code represents the code bytes from an ethereum address.",
            "format": "byte"
          }
        },
        "description": "QueryCodeResponse is the response type for the Query/Code RPC\nmethod."
      },
      "ethermint.evm.v1.QueryCosmosAccountResponse": {
        "type": "object",
        "properties": {
          "cosmos_address": {
            "type": "string",
            "description": "cosmos_address is the cosmos address of the account."
          },
          "sequence": {
            "type": "string",
            "description": "sequence is the account's sequence number.",
            "format": "uint64"
          },
          "account_number": {
            "title": "account_number is the account number",
            "type": "string",
            "format": "uint64"
          }
        },
        "description": "QueryCosmosAccountResponse is the response type for the Query/CosmosAccount\nRPC method."
      },
      "ethermint.evm.v1.QueryParamsResponse": {
        "type": "object",
        "properties": {
          "params": {
            "title": "Params defines the EVM module parameters",
            "type": "object",
            "properties": {
              "evm_denom": {
                "type": "string",
                "description": "evm_denom represents the token denomination used to run the EVM state\ntransitions."
              },
              "enable_create": {
                "title": "enable_create toggles state transitions that use the vm.Create function",
                "type": "boolean"
              },
              "enable_call": {
                "title": "enable_call toggles state transitions that use the vm.Call function",
                "type": "boolean"
              },
              "extra_eips": {
                "title": "extra_eips defines the additional EIPs for the vm.Config",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "int64"
                }
              },
              "chain_config": {
                "title": "chain_config defines the EVM chain configuration parameters",
                "type": "object",
                "properties": {
                  "homestead_block": {
                    "title": "homestead_block switch (nil no fork, 0 = already homestead)",
                    "type": "string"
                  },
                  "dao_fork_block": {
                    "title": "dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork)",
                    "type": "string"
                  },
                  "dao_fork_support": {
                    "title": "dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork",
                    "type": "boolean"
                  },
                  "eip150_block": {
                    "title": "eip150_block: EIP150 implements the Gas price changes\n(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)",
                    "type": "string"
                  },
                  "eip150_hash": {
                    "title": "eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed)",
                    "type": "string"
                  },
                  "eip155_block": {
                    "title": "eip155_block: EIP155Block HF block",
                    "type": "string"
                  },
                  "eip158_block": {
                    "title": "eip158_block: EIP158 HF block",
                    "type": "string"
                  },
                  "byzantium_block": {
                    "title": "byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium)",
                    "type": "string"
                  },
                  "constantinople_block": {
                    "title": "constantinople_block: Constantinople switch block (nil no fork, 0 = already activated)",
                    "type": "string"
                  },
                  "petersburg_block": {
                    "title": "petersburg_block: Petersburg switch block (nil same as Constantinople)",
                    "type": "string"
                  },
                  "istanbul_block": {
                    "title": "istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul)",
                    "type": "string"
                  },
                  "muir_glacier_block": {
                    "title": "muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated)",
                    "type": "string"
                  },
                  "berlin_block": {
                    "title": "berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin)",
                    "type": "string"
                  },
                  "london_block": {
                    "title": "london_block: London switch block (nil = no fork, 0 = already on london)",
                    "type": "string"
                  },
                  "arrow_glacier_block": {
                    "title": "arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated)",
                    "type": "string"
                  },
                  "gray_glacier_block": {
                    "title": "gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated)",
                    "type": "string"
                  },
                  "merge_netsplit_block": {
                    "title": "merge_netsplit_block: Virtual fork after The Merge to use as a network splitter",
                    "type": "string"
                  },
                  "shanghai_block": {
                    "title": "shanghai_block switch block (nil = no fork, 0 = already on shanghai)",
                    "type": "string"
                  },
                  "cancun_block": {
                    "title": "cancun_block switch block (nil = no fork, 0 = already on cancun)",
                    "type": "string"
                  }
                },
                "description": "ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values\ninstead of *big.Int."
              },
              "allow_unprotected_txs": {
                "type": "boolean",
                "description": "allow_unprotected_txs defines if replay-protected (i.e non EIP155\nsigned) transactions can be executed on the state machine."
              },
              "active_precompiles": {
                "title": "active_precompiles defines the slice of hex addresses of the precompiled\ncontracts that are active",
                "type": "array",
                "items": {
                  "type": "string"
                }
              }
            },
            "description": "params define the evm module parameters."
          }
        },
        "description": "QueryParamsResponse defines the response type for querying x/evm parameters."
      },
      "ethermint.evm.v1.QueryStorageResponse": {
        "type": "object",
        "properties": {
          "value": {
            "type": "string",
            "description": "value defines the storage state value hash associated with the given key."
          }
        },
        "description": "QueryStorageResponse is the response type for the Query/Storage RPC\nmethod."
      },
      "ethermint.evm.v1.QueryTraceBlockResponse": {
        "title": "QueryTraceBlockResponse defines TraceBlock response",
        "type": "object",
        "properties": {
          "data": {
            "title": "data is the response serialized in bytes",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          }
        }
      },
      "ethermint.evm.v1.QueryTraceTxResponse": {
        "title": "QueryTraceTxResponse defines TraceTx response",
        "type": "object",
        "properties": {
          "data": {
            "title": "data is the response serialized in bytes",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          }
        }
      },
      "ethermint.evm.v1.QueryValidatorAccountResponse": {
        "type": "object",
        "properties": {
          "account_address": {
            "type": "string",
            "description": "account_address is the cosmos address of the account in bech32 format."
          },
          "sequence": {
            "type": "string",
            "description": "sequence is the account's sequence number.",
            "format": "uint64"
          },
          "account_number": {
            "title": "account_number is the account number",
            "type": "string",
            "format": "uint64"
          }
        },
        "description": "QueryValidatorAccountResponse is the response type for the\nQuery/ValidatorAccount RPC method."
      },
      "ethermint.evm.v1.TraceConfig": {
        "type": "object",
        "properties": {
          "tracer": {
            "title": "tracer is a custom javascript tracer",
            "type": "string"
          },
          "timeout": {
            "title": "timeout overrides the default timeout of 5 seconds for JavaScript-based tracing\ncalls",
            "type": "string"
          },
          "reexec": {
            "title": "reexec defines the number of blocks the tracer is willing to go back",
            "type": "string",
            "format": "uint64"
          },
          "disable_stack": {
            "title": "disable_stack switches stack capture",
            "type": "boolean"
          },
          "disable_storage": {
            "title": "disable_storage switches storage capture",
            "type": "boolean"
          },
          "debug": {
            "title": "debug can be used to print output during capture end",
            "type": "boolean"
          },
          "limit": {
            "title": "limit defines the maximum length of output, but zero means unlimited",
            "type": "integer",
            "format": "int32"
          },
          "overrides": {
            "title": "overrides can be used to execute a trace using future fork rules",
            "type": "object",
            "properties": {
              "homestead_block": {
                "title": "homestead_block switch (nil no fork, 0 = already homestead)",
                "type": "string"
              },
              "dao_fork_block": {
                "title": "dao_fork_block corresponds to TheDAO hard-fork switch block (nil no fork)",
                "type": "string"
              },
              "dao_fork_support": {
                "title": "dao_fork_support defines whether the nodes supports or opposes the DAO hard-fork",
                "type": "boolean"
              },
              "eip150_block": {
                "title": "eip150_block: EIP150 implements the Gas price changes\n(https://github.com/ethereum/EIPs/issues/150) EIP150 HF block (nil no fork)",
                "type": "string"
              },
              "eip150_hash": {
                "title": "eip150_hash: EIP150 HF hash (needed for header only clients as only gas pricing changed)",
                "type": "string"
              },
              "eip155_block": {
                "title": "eip155_block: EIP155Block HF block",
                "type": "string"
              },
              "eip158_block": {
                "title": "eip158_block: EIP158 HF block",
                "type": "string"
              },
              "byzantium_block": {
                "title": "byzantium_block: Byzantium switch block (nil no fork, 0 = already on byzantium)",
                "type": "string"
              },
              "constantinople_block": {
                "title": "constantinople_block: Constantinople switch block (nil no fork, 0 = already activated)",
                "type": "string"
              },
              "petersburg_block": {
                "title": "petersburg_block: Petersburg switch block (nil same as Constantinople)",
                "type": "string"
              },
              "istanbul_block": {
                "title": "istanbul_block: Istanbul switch block (nil no fork, 0 = already on istanbul)",
                "type": "string"
              },
              "muir_glacier_block": {
                "title": "muir_glacier_block: Eip-2384 (bomb delay) switch block (nil no fork, 0 = already activated)",
                "type": "string"
              },
              "berlin_block": {
                "title": "berlin_block: Berlin switch block (nil = no fork, 0 = already on berlin)",
                "type": "string"
              },
              "london_block": {
                "title": "london_block: London switch block (nil = no fork, 0 = already on london)",
                "type": "string"
              },
              "arrow_glacier_block": {
                "title": "arrow_glacier_block: Eip-4345 (bomb delay) switch block (nil = no fork, 0 = already activated)",
                "type": "string"
              },
              "gray_glacier_block": {
                "title": "gray_glacier_block: EIP-5133 (bomb delay) switch block (nil = no fork, 0 = already activated)",
                "type": "string"
              },
              "merge_netsplit_block": {
                "title": "merge_netsplit_block: Virtual fork after The Merge to use as a network splitter",
                "type": "string"
              },
              "shanghai_block": {
                "title": "shanghai_block switch block (nil = no fork, 0 = already on shanghai)",
                "type": "string"
              },
              "cancun_block": {
                "title": "cancun_block switch block (nil = no fork, 0 = already on cancun)",
                "type": "string"
              }
            },
            "description": "ChainConfig defines the Ethereum ChainConfig parameters using *sdk.Int values\ninstead of *big.Int."
          },
          "enable_memory": {
            "title": "enable_memory switches memory capture",
            "type": "boolean"
          },
          "enable_return_data": {
            "title": "enable_return_data switches the capture of return data",
            "type": "boolean"
          },
          "tracer_json_config": {
            "title": "tracer_json_config configures the tracer using a JSON string",
            "type": "string"
          }
        },
        "description": "TraceConfig holds extra parameters to trace functions."
      },
      "ethermint.feemarket.v1.Params": {
        "title": "Params defines the EVM module parameters",
        "type": "object",
        "properties": {
          "no_base_fee": {
            "title": "no_base_fee forces the EIP-1559 base fee to 0 (needed for 0 price calls)",
            "type": "boolean"
          },
          "base_fee_change_denominator": {
            "type": "integer",
            "description": "base_fee_change_denominator bounds the amount the base fee can change\nbetween blocks.",
            "format": "int64"
          },
          "elasticity_multiplier": {
            "type": "integer",
            "description": "elasticity_multiplier bounds the maximum gas limit an EIP-1559 block may\nhave.",
            "format": "int64"
          },
          "enable_height": {
            "type": "string",
            "description": "enable_height defines at which block height the base fee calculation is enabled.",
            "format": "int64"
          },
          "base_fee": {
            "type": "string",
            "description": "base_fee for EIP-1559 blocks."
          },
          "min_gas_price": {
            "title": "min_gas_price defines the minimum gas price value for cosmos and eth transactions",
            "type": "string"
          },
          "min_gas_multiplier": {
            "title": "min_gas_multiplier bounds the minimum gas used to be charged\nto senders based on gas limit",
            "type": "string"
          }
        }
      },
      "ethermint.feemarket.v1.QueryBaseFeeResponse": {
        "type": "object",
        "properties": {
          "base_fee": {
            "title": "base_fee is the EIP1559 base fee",
            "type": "string"
          }
        },
        "description": "QueryBaseFeeResponse returns the EIP1559 base fee."
      },
      "ethermint.feemarket.v1.QueryBlockGasResponse": {
        "type": "object",
        "properties": {
          "gas": {
            "title": "gas is the returned block gas",
            "type": "string",
            "format": "int64"
          }
        },
        "description": "QueryBlockGasResponse returns block gas used for a given height."
      },
      "ethermint.feemarket.v1.QueryParamsResponse": {
        "type": "object",
        "properties": {
          "params": {
            "title": "Params defines the EVM module parameters",
            "type": "object",
            "properties": {
              "no_base_fee": {
                "title": "no_base_fee forces the EIP-1559 base fee to 0 (needed for 0 price calls)",
                "type": "boolean"
              },
              "base_fee_change_denominator": {
                "type": "integer",
                "description": "base_fee_change_denominator bounds the amount the base fee can change\nbetween blocks.",
                "format": "int64"
              },
              "elasticity_multiplier": {
                "type": "integer",
                "description": "elasticity_multiplier bounds the maximum gas limit an EIP-1559 block may\nhave.",
                "format": "int64"
              },
              "enable_height": {
                "type": "string",
                "description": "enable_height defines at which block height the base fee calculation is enabled.",
                "format": "int64"
              },
              "base_fee": {
                "type": "string",
                "description": "base_fee for EIP-1559 blocks."
              },
              "min_gas_price": {
                "title": "min_gas_price defines the minimum gas price value for cosmos and eth transactions",
                "type": "string"
              },
              "min_gas_multiplier": {
                "title": "min_gas_multiplier bounds the minimum gas used to be charged\nto senders based on gas limit",
                "type": "string"
              }
            },
            "description": "params define the evm module parameters."
          }
        },
        "description": "QueryParamsResponse defines the response type for querying x/evm parameters."
      },
      "ibc.applications.transfer.v1.DenomTrace": {
        "type": "object",
        "properties": {
          "path": {
            "type": "string",
            "description": "path defines the chain of port/channel identifiers used for tracing the\nsource of the fungible token."
          },
          "base_denom": {
            "type": "string",
            "description": "base denomination of the relayed fungible token."
          }
        },
        "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the\nsource tracing information path."
      },
      "ibc.applications.transfer.v1.Params": {
        "type": "object",
        "properties": {
          "send_enabled": {
            "type": "boolean",
            "description": "send_enabled enables or disables all cross-chain token transfers from this\nchain."
          },
          "receive_enabled": {
            "type": "boolean",
            "description": "receive_enabled enables or disables all cross-chain token transfers to this\nchain."
          }
        },
        "description": "Params defines the set of IBC transfer parameters.\nNOTE: To prevent a single token from being transferred, set the\nTransfersEnabled parameter to true and then set the bank module's SendEnabled\nparameter for the denomination to false."
      },
      "ibc.applications.transfer.v1.QueryDenomHashResponse": {
        "type": "object",
        "properties": {
          "hash": {
            "type": "string",
            "description": "hash (in hex format) of the denomination trace information."
          }
        },
        "description": "QueryDenomHashResponse is the response type for the Query/DenomHash RPC\nmethod."
      },
      "ibc.applications.transfer.v1.QueryDenomTraceResponse": {
        "type": "object",
        "properties": {
          "denom_trace": {
            "type": "object",
            "properties": {
              "path": {
                "type": "string",
                "description": "path defines the chain of port/channel identifiers used for tracing the\nsource of the fungible token."
              },
              "base_denom": {
                "type": "string",
                "description": "base denomination of the relayed fungible token."
              }
            },
            "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the\nsource tracing information path."
          }
        },
        "description": "QueryDenomTraceResponse is the response type for the Query/DenomTrace RPC\nmethod."
      },
      "ibc.applications.transfer.v1.QueryDenomTracesResponse": {
        "type": "object",
        "properties": {
          "denom_traces": {
            "type": "array",
            "description": "denom_traces returns all denominations trace information.",
            "items": {
              "type": "object",
              "properties": {
                "path": {
                  "type": "string",
                  "description": "path defines the chain of port/channel identifiers used for tracing the\nsource of the fungible token."
                },
                "base_denom": {
                  "type": "string",
                  "description": "base denomination of the relayed fungible token."
                }
              },
              "description": "DenomTrace contains the base denomination for ICS20 fungible tokens and the\nsource tracing information path."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryConnectionsResponse is the response type for the Query/DenomTraces RPC\nmethod."
      },
      "ibc.applications.transfer.v1.QueryEscrowAddressResponse": {
        "type": "object",
        "properties": {
          "escrow_address": {
            "title": "the escrow account address",
            "type": "string"
          }
        },
        "description": "QueryEscrowAddressResponse is the response type of the EscrowAddress RPC method."
      },
      "ibc.applications.transfer.v1.QueryParamsResponse": {
        "type": "object",
        "properties": {
          "params": {
            "type": "object",
            "properties": {
              "send_enabled": {
                "type": "boolean",
                "description": "send_enabled enables or disables all cross-chain token transfers from this\nchain."
              },
              "receive_enabled": {
                "type": "boolean",
                "description": "receive_enabled enables or disables all cross-chain token transfers to this\nchain."
              }
            },
            "description": "params defines the parameters of the module."
          }
        },
        "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
      },
      "ibc.applications.transfer.v1.QueryTotalEscrowForDenomResponse": {
        "type": "object",
        "properties": {
          "amount": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          }
        },
        "description": "QueryTotalEscrowForDenomResponse is the response type for TotalEscrowForDenom RPC method."
      },
      "ibc.core.client.v1.ConsensusStateWithHeight": {
        "type": "object",
        "properties": {
          "height": {
            "title": "consensus state height",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          },
          "consensus_state": {
            "title": "consensus state",
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          }
        },
        "description": "ConsensusStateWithHeight defines a consensus state with an additional height\nfield."
      },
      "ibc.core.client.v1.Height": {
        "title": "Height is a monotonically increasing data type\nthat can be compared against another Height for the purposes of updating and\nfreezing clients",
        "type": "object",
        "properties": {
          "revision_number": {
            "title": "the revision that the client is currently on",
            "type": "string",
            "format": "uint64"
          },
          "revision_height": {
            "title": "the height within the given revision",
            "type": "string",
            "format": "uint64"
          }
        },
        "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
      },
      "ibc.core.client.v1.IdentifiedClientState": {
        "type": "object",
        "properties": {
          "client_id": {
            "title": "client identifier",
            "type": "string"
          },
          "client_state": {
            "title": "client state",
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          }
        },
        "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
      },
      "ibc.core.client.v1.Params": {
        "type": "object",
        "properties": {
          "allowed_clients": {
            "type": "array",
            "description": "allowed_clients defines the list of allowed client state types which can be created\nand interacted with. If a client type is removed from the allowed clients list, usage\nof this client will be disabled until it is added again to the list.",
            "items": {
              "type": "string"
            }
          }
        },
        "description": "Params defines the set of IBC light client parameters."
      },
      "ibc.core.client.v1.QueryClientParamsResponse": {
        "type": "object",
        "properties": {
          "params": {
            "type": "object",
            "properties": {
              "allowed_clients": {
                "type": "array",
                "description": "allowed_clients defines the list of allowed client state types which can be created\nand interacted with. If a client type is removed from the allowed clients list, usage\nof this client will be disabled until it is added again to the list.",
                "items": {
                  "type": "string"
                }
              }
            },
            "description": "params defines the parameters of the module."
          }
        },
        "description": "QueryClientParamsResponse is the response type for the Query/ClientParams RPC\nmethod."
      },
      "ibc.core.client.v1.QueryClientStateResponse": {
        "type": "object",
        "properties": {
          "client_state": {
            "title": "client state associated with the request identifier",
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "proof": {
            "title": "merkle proof of existence",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "proof_height": {
            "title": "height at which the proof was retrieved",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        },
        "description": "QueryClientStateResponse is the response type for the Query/ClientState RPC\nmethod. Besides the client state, it includes a proof and the height from\nwhich the proof was retrieved."
      },
      "ibc.core.client.v1.QueryClientStatesResponse": {
        "type": "object",
        "properties": {
          "client_states": {
            "type": "array",
            "description": "list of stored ClientStates of the chain.",
            "items": {
              "type": "object",
              "properties": {
                "client_id": {
                  "title": "client identifier",
                  "type": "string"
                },
                "client_state": {
                  "title": "client state",
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "byte"
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                }
              },
              "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
            }
          },
          "pagination": {
            "title": "pagination response",
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
          }
        },
        "description": "QueryClientStatesResponse is the response type for the Query/ClientStates RPC\nmethod."
      },
      "ibc.core.client.v1.QueryClientStatusResponse": {
        "type": "object",
        "properties": {
          "status": {
            "type": "string"
          }
        },
        "description": "QueryClientStatusResponse is the response type for the Query/ClientStatus RPC\nmethod. It returns the current status of the IBC client."
      },
      "ibc.core.client.v1.QueryConsensusStateHeightsResponse": {
        "title": "QueryConsensusStateHeightsResponse is the response type for the\nQuery/ConsensusStateHeights RPC method",
        "type": "object",
        "properties": {
          "consensus_state_heights": {
            "title": "consensus state heights",
            "type": "array",
            "items": {
              "title": "Height is a monotonically increasing data type\nthat can be compared against another Height for the purposes of updating and\nfreezing clients",
              "type": "object",
              "properties": {
                "revision_number": {
                  "title": "the revision that the client is currently on",
                  "type": "string",
                  "format": "uint64"
                },
                "revision_height": {
                  "title": "the height within the given revision",
                  "type": "string",
                  "format": "uint64"
                }
              },
              "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
            }
          },
          "pagination": {
            "title": "pagination response",
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
          }
        }
      },
      "ibc.core.client.v1.QueryConsensusStateResponse": {
        "title": "QueryConsensusStateResponse is the response type for the Query/ConsensusState\nRPC method",
        "type": "object",
        "properties": {
          "consensus_state": {
            "title": "consensus state associated with the client identifier at the given height",
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "proof": {
            "title": "merkle proof of existence",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "proof_height": {
            "title": "Height is a monotonically increasing data type\nthat can be compared against another Height for the purposes of updating and\nfreezing clients",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        }
      },
      "ibc.core.client.v1.QueryConsensusStatesResponse": {
        "title": "QueryConsensusStatesResponse is the response type for the\nQuery/ConsensusStates RPC method",
        "type": "object",
        "properties": {
          "consensus_states": {
            "title": "consensus states associated with the identifier",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "height": {
                  "title": "consensus state height",
                  "type": "object",
                  "properties": {
                    "revision_number": {
                      "title": "the revision that the client is currently on",
                      "type": "string",
                      "format": "uint64"
                    },
                    "revision_height": {
                      "title": "the height within the given revision",
                      "type": "string",
                      "format": "uint64"
                    }
                  },
                  "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
                },
                "consensus_state": {
                  "title": "consensus state",
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "byte"
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                }
              },
              "description": "ConsensusStateWithHeight defines a consensus state with an additional height\nfield."
            }
          },
          "pagination": {
            "title": "pagination response",
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
          }
        }
      },
      "ibc.core.client.v1.QueryUpgradedClientStateResponse": {
        "type": "object",
        "properties": {
          "upgraded_client_state": {
            "title": "client state associated with the request identifier",
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          }
        },
        "description": "QueryUpgradedClientStateResponse is the response type for the\nQuery/UpgradedClientState RPC method."
      },
      "ibc.core.client.v1.QueryUpgradedConsensusStateResponse": {
        "type": "object",
        "properties": {
          "upgraded_consensus_state": {
            "title": "Consensus state associated with the request identifier",
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          }
        },
        "description": "QueryUpgradedConsensusStateResponse is the response type for the\nQuery/UpgradedConsensusState RPC method."
      },
      "ibc.core.commitment.v1.MerklePrefix": {
        "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))",
        "type": "object",
        "properties": {
          "key_prefix": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          }
        }
      },
      "ibc.core.connection.v1.ConnectionEnd": {
        "type": "object",
        "properties": {
          "client_id": {
            "type": "string",
            "description": "client associated with this connection."
          },
          "versions": {
            "type": "array",
            "description": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection.",
            "items": {
              "type": "object",
              "properties": {
                "identifier": {
                  "title": "unique version identifier",
                  "type": "string"
                },
                "features": {
                  "title": "list of features compatible with the specified identifier",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              },
              "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
            }
          },
          "state": {
            "type": "string",
            "description": "current state of the connection end.",
            "default": "STATE_UNINITIALIZED_UNSPECIFIED",
            "enum": [
              "STATE_UNINITIALIZED_UNSPECIFIED",
              "STATE_INIT",
              "STATE_TRYOPEN",
              "STATE_OPEN"
            ]
          },
          "counterparty": {
            "type": "object",
            "properties": {
              "client_id": {
                "type": "string",
                "description": "identifies the client on the counterparty chain associated with a given\nconnection."
              },
              "connection_id": {
                "type": "string",
                "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
              },
              "prefix": {
                "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))",
                "type": "object",
                "properties": {
                  "key_prefix": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  }
                },
                "description": "commitment merkle prefix of the counterparty chain."
              }
            },
            "description": "counterparty chain associated with this connection."
          },
          "delay_period": {
            "type": "string",
            "description": "delay period that must pass before a consensus state can be used for\npacket-verification NOTE: delay period logic is only implemented by some\nclients.",
            "format": "uint64"
          }
        },
        "description": "ConnectionEnd defines a stateful object on a chain connected to another\nseparate one.\nNOTE: there must only be 2 defined ConnectionEnds to establish\na connection between two chains."
      },
      "ibc.core.connection.v1.Counterparty": {
        "type": "object",
        "properties": {
          "client_id": {
            "type": "string",
            "description": "identifies the client on the counterparty chain associated with a given\nconnection."
          },
          "connection_id": {
            "type": "string",
            "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
          },
          "prefix": {
            "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))",
            "type": "object",
            "properties": {
              "key_prefix": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              }
            },
            "description": "commitment merkle prefix of the counterparty chain."
          }
        },
        "description": "Counterparty defines the counterparty chain associated with a connection end."
      },
      "ibc.core.connection.v1.IdentifiedConnection": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "connection identifier."
          },
          "client_id": {
            "type": "string",
            "description": "client associated with this connection."
          },
          "versions": {
            "title": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "identifier": {
                  "title": "unique version identifier",
                  "type": "string"
                },
                "features": {
                  "title": "list of features compatible with the specified identifier",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              },
              "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
            }
          },
          "state": {
            "type": "string",
            "description": "current state of the connection end.",
            "default": "STATE_UNINITIALIZED_UNSPECIFIED",
            "enum": [
              "STATE_UNINITIALIZED_UNSPECIFIED",
              "STATE_INIT",
              "STATE_TRYOPEN",
              "STATE_OPEN"
            ]
          },
          "counterparty": {
            "type": "object",
            "properties": {
              "client_id": {
                "type": "string",
                "description": "identifies the client on the counterparty chain associated with a given\nconnection."
              },
              "connection_id": {
                "type": "string",
                "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
              },
              "prefix": {
                "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))",
                "type": "object",
                "properties": {
                  "key_prefix": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  }
                },
                "description": "commitment merkle prefix of the counterparty chain."
              }
            },
            "description": "counterparty chain associated with this connection."
          },
          "delay_period": {
            "type": "string",
            "description": "delay period associated with this connection.",
            "format": "uint64"
          }
        },
        "description": "IdentifiedConnection defines a connection with additional connection\nidentifier field."
      },
      "ibc.core.connection.v1.Params": {
        "type": "object",
        "properties": {
          "max_expected_time_per_block": {
            "type": "string",
            "description": "maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the\nlargest amount of time that the chain might reasonably take to produce the next block under normal operating\nconditions. A safe choice is 3-5x the expected time per block.",
            "format": "uint64"
          }
        },
        "description": "Params defines the set of Connection parameters."
      },
      "ibc.core.connection.v1.QueryClientConnectionsResponse": {
        "title": "QueryClientConnectionsResponse is the response type for the\nQuery/ClientConnections RPC method",
        "type": "object",
        "properties": {
          "connection_paths": {
            "type": "array",
            "description": "slice of all the connection paths associated with a client.",
            "items": {
              "type": "string"
            }
          },
          "proof": {
            "title": "merkle proof of existence",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "proof_height": {
            "title": "height at which the proof was generated",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        }
      },
      "ibc.core.connection.v1.QueryConnectionClientStateResponse": {
        "title": "QueryConnectionClientStateResponse is the response type for the\nQuery/ConnectionClientState RPC method",
        "type": "object",
        "properties": {
          "identified_client_state": {
            "title": "client state associated with the channel",
            "type": "object",
            "properties": {
              "client_id": {
                "title": "client identifier",
                "type": "string"
              },
              "client_state": {
                "title": "client state",
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                    "format": "byte"
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              }
            },
            "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
          },
          "proof": {
            "title": "merkle proof of existence",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "proof_height": {
            "title": "height at which the proof was retrieved",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        }
      },
      "ibc.core.connection.v1.QueryConnectionConsensusStateResponse": {
        "title": "QueryConnectionConsensusStateResponse is the response type for the\nQuery/ConnectionConsensusState RPC method",
        "type": "object",
        "properties": {
          "consensus_state": {
            "title": "consensus state associated with the channel",
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "client_id": {
            "title": "client ID associated with the consensus state",
            "type": "string"
          },
          "proof": {
            "title": "merkle proof of existence",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "proof_height": {
            "title": "height at which the proof was retrieved",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        }
      },
      "ibc.core.connection.v1.QueryConnectionParamsResponse": {
        "type": "object",
        "properties": {
          "params": {
            "type": "object",
            "properties": {
              "max_expected_time_per_block": {
                "type": "string",
                "description": "maximum expected time per block (in nanoseconds), used to enforce block delay. This parameter should reflect the\nlargest amount of time that the chain might reasonably take to produce the next block under normal operating\nconditions. A safe choice is 3-5x the expected time per block.",
                "format": "uint64"
              }
            },
            "description": "params defines the parameters of the module."
          }
        },
        "description": "QueryConnectionParamsResponse is the response type for the Query/ConnectionParams RPC method."
      },
      "ibc.core.connection.v1.QueryConnectionResponse": {
        "type": "object",
        "properties": {
          "connection": {
            "title": "connection associated with the request identifier",
            "type": "object",
            "properties": {
              "client_id": {
                "type": "string",
                "description": "client associated with this connection."
              },
              "versions": {
                "type": "array",
                "description": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection.",
                "items": {
                  "type": "object",
                  "properties": {
                    "identifier": {
                      "title": "unique version identifier",
                      "type": "string"
                    },
                    "features": {
                      "title": "list of features compatible with the specified identifier",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
                }
              },
              "state": {
                "type": "string",
                "description": "current state of the connection end.",
                "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                "enum": [
                  "STATE_UNINITIALIZED_UNSPECIFIED",
                  "STATE_INIT",
                  "STATE_TRYOPEN",
                  "STATE_OPEN"
                ]
              },
              "counterparty": {
                "type": "object",
                "properties": {
                  "client_id": {
                    "type": "string",
                    "description": "identifies the client on the counterparty chain associated with a given\nconnection."
                  },
                  "connection_id": {
                    "type": "string",
                    "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
                  },
                  "prefix": {
                    "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))",
                    "type": "object",
                    "properties": {
                      "key_prefix": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "description": "commitment merkle prefix of the counterparty chain."
                  }
                },
                "description": "counterparty chain associated with this connection."
              },
              "delay_period": {
                "type": "string",
                "description": "delay period that must pass before a consensus state can be used for\npacket-verification NOTE: delay period logic is only implemented by some\nclients.",
                "format": "uint64"
              }
            },
            "description": "ConnectionEnd defines a stateful object on a chain connected to another\nseparate one.\nNOTE: there must only be 2 defined ConnectionEnds to establish\na connection between two chains."
          },
          "proof": {
            "title": "merkle proof of existence",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "proof_height": {
            "title": "height at which the proof was retrieved",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        },
        "description": "QueryConnectionResponse is the response type for the Query/Connection RPC\nmethod. Besides the connection end, it includes a proof and the height from\nwhich the proof was retrieved."
      },
      "ibc.core.connection.v1.QueryConnectionsResponse": {
        "type": "object",
        "properties": {
          "connections": {
            "type": "array",
            "description": "list of stored connections of the chain.",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "description": "connection identifier."
                },
                "client_id": {
                  "type": "string",
                  "description": "client associated with this connection."
                },
                "versions": {
                  "title": "IBC version which can be utilised to determine encodings or protocols for\nchannels or packets utilising this connection",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "identifier": {
                        "title": "unique version identifier",
                        "type": "string"
                      },
                      "features": {
                        "title": "list of features compatible with the specified identifier",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    },
                    "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
                  }
                },
                "state": {
                  "type": "string",
                  "description": "current state of the connection end.",
                  "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                  "enum": [
                    "STATE_UNINITIALIZED_UNSPECIFIED",
                    "STATE_INIT",
                    "STATE_TRYOPEN",
                    "STATE_OPEN"
                  ]
                },
                "counterparty": {
                  "type": "object",
                  "properties": {
                    "client_id": {
                      "type": "string",
                      "description": "identifies the client on the counterparty chain associated with a given\nconnection."
                    },
                    "connection_id": {
                      "type": "string",
                      "description": "identifies the connection end on the counterparty chain associated with a\ngiven connection."
                    },
                    "prefix": {
                      "title": "MerklePrefix is merkle path prefixed to the key.\nThe constructed key from the Path and the key will be append(Path.KeyPath,\nappend(Path.KeyPrefix, key...))",
                      "type": "object",
                      "properties": {
                        "key_prefix": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "description": "commitment merkle prefix of the counterparty chain."
                    }
                  },
                  "description": "counterparty chain associated with this connection."
                },
                "delay_period": {
                  "type": "string",
                  "description": "delay period associated with this connection.",
                  "format": "uint64"
                }
              },
              "description": "IdentifiedConnection defines a connection with additional connection\nidentifier field."
            }
          },
          "pagination": {
            "title": "pagination response",
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
          },
          "height": {
            "title": "query block height",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        },
        "description": "QueryConnectionsResponse is the response type for the Query/Connections RPC\nmethod."
      },
      "ibc.core.connection.v1.State": {
        "type": "string",
        "description": "State defines if a connection is in one of the following states:\nINIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A connection end has just started the opening handshake.\n - STATE_TRYOPEN: A connection end has acknowledged the handshake step on the counterparty\nchain.\n - STATE_OPEN: A connection end has completed the handshake.",
        "default": "STATE_UNINITIALIZED_UNSPECIFIED",
        "enum": [
          "STATE_UNINITIALIZED_UNSPECIFIED",
          "STATE_INIT",
          "STATE_TRYOPEN",
          "STATE_OPEN"
        ]
      },
      "ibc.core.connection.v1.Version": {
        "type": "object",
        "properties": {
          "identifier": {
            "title": "unique version identifier",
            "type": "string"
          },
          "features": {
            "title": "list of features compatible with the specified identifier",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "description": "Version defines the versioning scheme used to negotiate the IBC verison in\nthe connection handshake."
      },
      "ibc.core.channel.v1.Channel": {
        "type": "object",
        "properties": {
          "state": {
            "title": "current state of the channel end",
            "type": "string",
            "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets.",
            "default": "STATE_UNINITIALIZED_UNSPECIFIED",
            "enum": [
              "STATE_UNINITIALIZED_UNSPECIFIED",
              "STATE_INIT",
              "STATE_TRYOPEN",
              "STATE_OPEN",
              "STATE_CLOSED"
            ]
          },
          "ordering": {
            "title": "whether the channel is ordered or unordered",
            "type": "string",
            "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent",
            "default": "ORDER_NONE_UNSPECIFIED",
            "enum": [
              "ORDER_NONE_UNSPECIFIED",
              "ORDER_UNORDERED",
              "ORDER_ORDERED"
            ]
          },
          "counterparty": {
            "title": "counterparty channel end",
            "type": "object",
            "properties": {
              "port_id": {
                "type": "string",
                "description": "port on the counterparty chain which owns the other end of the channel."
              },
              "channel_id": {
                "title": "channel end on the counterparty chain",
                "type": "string"
              }
            }
          },
          "connection_hops": {
            "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "version": {
            "title": "opaque channel version, which is agreed upon during the handshake",
            "type": "string"
          }
        },
        "description": "Channel defines pipeline for exactly-once packet delivery between specific\nmodules on separate blockchains, which has at least one end capable of\nsending packets and one end capable of receiving packets."
      },
      "ibc.core.channel.v1.Counterparty": {
        "title": "Counterparty defines a channel end counterparty",
        "type": "object",
        "properties": {
          "port_id": {
            "type": "string",
            "description": "port on the counterparty chain which owns the other end of the channel."
          },
          "channel_id": {
            "title": "channel end on the counterparty chain",
            "type": "string"
          }
        }
      },
      "ibc.core.channel.v1.IdentifiedChannel": {
        "type": "object",
        "properties": {
          "state": {
            "title": "current state of the channel end",
            "type": "string",
            "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets.",
            "default": "STATE_UNINITIALIZED_UNSPECIFIED",
            "enum": [
              "STATE_UNINITIALIZED_UNSPECIFIED",
              "STATE_INIT",
              "STATE_TRYOPEN",
              "STATE_OPEN",
              "STATE_CLOSED"
            ]
          },
          "ordering": {
            "title": "whether the channel is ordered or unordered",
            "type": "string",
            "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent",
            "default": "ORDER_NONE_UNSPECIFIED",
            "enum": [
              "ORDER_NONE_UNSPECIFIED",
              "ORDER_UNORDERED",
              "ORDER_ORDERED"
            ]
          },
          "counterparty": {
            "title": "counterparty channel end",
            "type": "object",
            "properties": {
              "port_id": {
                "type": "string",
                "description": "port on the counterparty chain which owns the other end of the channel."
              },
              "channel_id": {
                "title": "channel end on the counterparty chain",
                "type": "string"
              }
            }
          },
          "connection_hops": {
            "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel",
            "type": "array",
            "items": {
              "type": "string"
            }
          },
          "version": {
            "title": "opaque channel version, which is agreed upon during the handshake",
            "type": "string"
          },
          "port_id": {
            "title": "port identifier",
            "type": "string"
          },
          "channel_id": {
            "title": "channel identifier",
            "type": "string"
          }
        },
        "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
      },
      "ibc.core.channel.v1.Order": {
        "title": "Order defines if a channel is ORDERED or UNORDERED",
        "type": "string",
        "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent",
        "default": "ORDER_NONE_UNSPECIFIED",
        "enum": [
          "ORDER_NONE_UNSPECIFIED",
          "ORDER_UNORDERED",
          "ORDER_ORDERED"
        ]
      },
      "ibc.core.channel.v1.PacketState": {
        "type": "object",
        "properties": {
          "port_id": {
            "type": "string",
            "description": "channel port identifier."
          },
          "channel_id": {
            "type": "string",
            "description": "channel unique identifier."
          },
          "sequence": {
            "type": "string",
            "description": "packet sequence.",
            "format": "uint64"
          },
          "data": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "embedded data that represents packet state.",
            "format": "byte"
          }
        },
        "description": "PacketState defines the generic type necessary to retrieve and store\npacket commitments, acknowledgements, and receipts.\nCaller is responsible for knowing the context necessary to interpret this\nstate as a commitment, acknowledgement, or a receipt."
      },
      "ibc.core.channel.v1.QueryChannelClientStateResponse": {
        "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method",
        "type": "object",
        "properties": {
          "identified_client_state": {
            "title": "client state associated with the channel",
            "type": "object",
            "properties": {
              "client_id": {
                "title": "client identifier",
                "type": "string"
              },
              "client_state": {
                "title": "client state",
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                    "format": "byte"
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              }
            },
            "description": "IdentifiedClientState defines a client state with an additional client\nidentifier field."
          },
          "proof": {
            "title": "merkle proof of existence",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "proof_height": {
            "title": "height at which the proof was retrieved",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        }
      },
      "ibc.core.channel.v1.QueryChannelConsensusStateResponse": {
        "title": "QueryChannelClientStateResponse is the Response type for the\nQuery/QueryChannelClientState RPC method",
        "type": "object",
        "properties": {
          "consensus_state": {
            "title": "consensus state associated with the channel",
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "client_id": {
            "title": "client ID associated with the consensus state",
            "type": "string"
          },
          "proof": {
            "title": "merkle proof of existence",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "proof_height": {
            "title": "height at which the proof was retrieved",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        }
      },
      "ibc.core.channel.v1.QueryChannelResponse": {
        "type": "object",
        "properties": {
          "channel": {
            "title": "channel associated with the request identifiers",
            "type": "object",
            "properties": {
              "state": {
                "title": "current state of the channel end",
                "type": "string",
                "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets.",
                "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                "enum": [
                  "STATE_UNINITIALIZED_UNSPECIFIED",
                  "STATE_INIT",
                  "STATE_TRYOPEN",
                  "STATE_OPEN",
                  "STATE_CLOSED"
                ]
              },
              "ordering": {
                "title": "whether the channel is ordered or unordered",
                "type": "string",
                "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent",
                "default": "ORDER_NONE_UNSPECIFIED",
                "enum": [
                  "ORDER_NONE_UNSPECIFIED",
                  "ORDER_UNORDERED",
                  "ORDER_ORDERED"
                ]
              },
              "counterparty": {
                "title": "counterparty channel end",
                "type": "object",
                "properties": {
                  "port_id": {
                    "type": "string",
                    "description": "port on the counterparty chain which owns the other end of the channel."
                  },
                  "channel_id": {
                    "title": "channel end on the counterparty chain",
                    "type": "string"
                  }
                }
              },
              "connection_hops": {
                "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel",
                "type": "array",
                "items": {
                  "type": "string"
                }
              },
              "version": {
                "title": "opaque channel version, which is agreed upon during the handshake",
                "type": "string"
              }
            },
            "description": "Channel defines pipeline for exactly-once packet delivery between specific\nmodules on separate blockchains, which has at least one end capable of\nsending packets and one end capable of receiving packets."
          },
          "proof": {
            "title": "merkle proof of existence",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "proof_height": {
            "title": "height at which the proof was retrieved",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        },
        "description": "QueryChannelResponse is the response type for the Query/Channel RPC method.\nBesides the Channel end, it includes a proof and the height from which the\nproof was retrieved."
      },
      "ibc.core.channel.v1.QueryChannelsResponse": {
        "type": "object",
        "properties": {
          "channels": {
            "type": "array",
            "description": "list of stored channels of the chain.",
            "items": {
              "type": "object",
              "properties": {
                "state": {
                  "title": "current state of the channel end",
                  "type": "string",
                  "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets.",
                  "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                  "enum": [
                    "STATE_UNINITIALIZED_UNSPECIFIED",
                    "STATE_INIT",
                    "STATE_TRYOPEN",
                    "STATE_OPEN",
                    "STATE_CLOSED"
                  ]
                },
                "ordering": {
                  "title": "whether the channel is ordered or unordered",
                  "type": "string",
                  "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent",
                  "default": "ORDER_NONE_UNSPECIFIED",
                  "enum": [
                    "ORDER_NONE_UNSPECIFIED",
                    "ORDER_UNORDERED",
                    "ORDER_ORDERED"
                  ]
                },
                "counterparty": {
                  "title": "counterparty channel end",
                  "type": "object",
                  "properties": {
                    "port_id": {
                      "type": "string",
                      "description": "port on the counterparty chain which owns the other end of the channel."
                    },
                    "channel_id": {
                      "title": "channel end on the counterparty chain",
                      "type": "string"
                    }
                  }
                },
                "connection_hops": {
                  "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "version": {
                  "title": "opaque channel version, which is agreed upon during the handshake",
                  "type": "string"
                },
                "port_id": {
                  "title": "port identifier",
                  "type": "string"
                },
                "channel_id": {
                  "title": "channel identifier",
                  "type": "string"
                }
              },
              "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
            }
          },
          "pagination": {
            "title": "pagination response",
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
          },
          "height": {
            "title": "query block height",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        },
        "description": "QueryChannelsResponse is the response type for the Query/Channels RPC method."
      },
      "ibc.core.channel.v1.QueryConnectionChannelsResponse": {
        "title": "QueryConnectionChannelsResponse is the Response type for the\nQuery/QueryConnectionChannels RPC method",
        "type": "object",
        "properties": {
          "channels": {
            "type": "array",
            "description": "list of channels associated with a connection.",
            "items": {
              "type": "object",
              "properties": {
                "state": {
                  "title": "current state of the channel end",
                  "type": "string",
                  "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets.",
                  "default": "STATE_UNINITIALIZED_UNSPECIFIED",
                  "enum": [
                    "STATE_UNINITIALIZED_UNSPECIFIED",
                    "STATE_INIT",
                    "STATE_TRYOPEN",
                    "STATE_OPEN",
                    "STATE_CLOSED"
                  ]
                },
                "ordering": {
                  "title": "whether the channel is ordered or unordered",
                  "type": "string",
                  "description": "- ORDER_NONE_UNSPECIFIED: zero-value for channel ordering\n - ORDER_UNORDERED: packets can be delivered in any order, which may differ from the order in\nwhich they were sent.\n - ORDER_ORDERED: packets are delivered exactly in the order which they were sent",
                  "default": "ORDER_NONE_UNSPECIFIED",
                  "enum": [
                    "ORDER_NONE_UNSPECIFIED",
                    "ORDER_UNORDERED",
                    "ORDER_ORDERED"
                  ]
                },
                "counterparty": {
                  "title": "counterparty channel end",
                  "type": "object",
                  "properties": {
                    "port_id": {
                      "type": "string",
                      "description": "port on the counterparty chain which owns the other end of the channel."
                    },
                    "channel_id": {
                      "title": "channel end on the counterparty chain",
                      "type": "string"
                    }
                  }
                },
                "connection_hops": {
                  "title": "list of connection identifiers, in order, along which packets sent on\nthis channel will travel",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                },
                "version": {
                  "title": "opaque channel version, which is agreed upon during the handshake",
                  "type": "string"
                },
                "port_id": {
                  "title": "port identifier",
                  "type": "string"
                },
                "channel_id": {
                  "title": "channel identifier",
                  "type": "string"
                }
              },
              "description": "IdentifiedChannel defines a channel with additional port and channel\nidentifier fields."
            }
          },
          "pagination": {
            "title": "pagination response",
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
          },
          "height": {
            "title": "query block height",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        }
      },
      "ibc.core.channel.v1.QueryNextSequenceReceiveResponse": {
        "title": "QuerySequenceResponse is the request type for the\nQuery/QueryNextSequenceReceiveResponse RPC method",
        "type": "object",
        "properties": {
          "next_sequence_receive": {
            "title": "next sequence receive number",
            "type": "string",
            "format": "uint64"
          },
          "proof": {
            "title": "merkle proof of existence",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "proof_height": {
            "title": "height at which the proof was retrieved",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        }
      },
      "ibc.core.channel.v1.QueryNextSequenceSendResponse": {
        "title": "QueryNextSequenceSendResponse is the request type for the\nQuery/QueryNextSequenceSend RPC method",
        "type": "object",
        "properties": {
          "next_sequence_send": {
            "title": "next sequence send number",
            "type": "string",
            "format": "uint64"
          },
          "proof": {
            "title": "merkle proof of existence",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "proof_height": {
            "title": "height at which the proof was retrieved",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        }
      },
      "ibc.core.channel.v1.QueryPacketAcknowledgementResponse": {
        "title": "QueryPacketAcknowledgementResponse defines the client query response for a\npacket which also includes a proof and the height from which the\nproof was retrieved",
        "type": "object",
        "properties": {
          "acknowledgement": {
            "title": "packet associated with the request fields",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "proof": {
            "title": "merkle proof of existence",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "proof_height": {
            "title": "height at which the proof was retrieved",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        }
      },
      "ibc.core.channel.v1.QueryPacketAcknowledgementsResponse": {
        "title": "QueryPacketAcknowledgemetsResponse is the request type for the\nQuery/QueryPacketAcknowledgements RPC method",
        "type": "object",
        "properties": {
          "acknowledgements": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "port_id": {
                  "type": "string",
                  "description": "channel port identifier."
                },
                "channel_id": {
                  "type": "string",
                  "description": "channel unique identifier."
                },
                "sequence": {
                  "type": "string",
                  "description": "packet sequence.",
                  "format": "uint64"
                },
                "data": {
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "description": "embedded data that represents packet state.",
                  "format": "byte"
                }
              },
              "description": "PacketState defines the generic type necessary to retrieve and store\npacket commitments, acknowledgements, and receipts.\nCaller is responsible for knowing the context necessary to interpret this\nstate as a commitment, acknowledgement, or a receipt."
            }
          },
          "pagination": {
            "title": "pagination response",
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
          },
          "height": {
            "title": "query block height",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        }
      },
      "ibc.core.channel.v1.QueryPacketCommitmentResponse": {
        "title": "QueryPacketCommitmentResponse defines the client query response for a packet\nwhich also includes a proof and the height from which the proof was\nretrieved",
        "type": "object",
        "properties": {
          "commitment": {
            "title": "packet associated with the request fields",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "proof": {
            "title": "merkle proof of existence",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "proof_height": {
            "title": "height at which the proof was retrieved",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        }
      },
      "ibc.core.channel.v1.QueryPacketCommitmentsResponse": {
        "title": "QueryPacketCommitmentsResponse is the request type for the\nQuery/QueryPacketCommitments RPC method",
        "type": "object",
        "properties": {
          "commitments": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "port_id": {
                  "type": "string",
                  "description": "channel port identifier."
                },
                "channel_id": {
                  "type": "string",
                  "description": "channel unique identifier."
                },
                "sequence": {
                  "type": "string",
                  "description": "packet sequence.",
                  "format": "uint64"
                },
                "data": {
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "description": "embedded data that represents packet state.",
                  "format": "byte"
                }
              },
              "description": "PacketState defines the generic type necessary to retrieve and store\npacket commitments, acknowledgements, and receipts.\nCaller is responsible for knowing the context necessary to interpret this\nstate as a commitment, acknowledgement, or a receipt."
            }
          },
          "pagination": {
            "title": "pagination response",
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
          },
          "height": {
            "title": "query block height",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        }
      },
      "ibc.core.channel.v1.QueryPacketReceiptResponse": {
        "title": "QueryPacketReceiptResponse defines the client query response for a packet\nreceipt which also includes a proof, and the height from which the proof was\nretrieved",
        "type": "object",
        "properties": {
          "received": {
            "title": "success flag for if receipt exists",
            "type": "boolean"
          },
          "proof": {
            "title": "merkle proof of existence",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "proof_height": {
            "title": "height at which the proof was retrieved",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        }
      },
      "ibc.core.channel.v1.QueryUnreceivedAcksResponse": {
        "title": "QueryUnreceivedAcksResponse is the response type for the\nQuery/UnreceivedAcks RPC method",
        "type": "object",
        "properties": {
          "sequences": {
            "title": "list of unreceived acknowledgement sequences",
            "type": "array",
            "items": {
              "type": "string",
              "format": "uint64"
            }
          },
          "height": {
            "title": "query block height",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        }
      },
      "ibc.core.channel.v1.QueryUnreceivedPacketsResponse": {
        "title": "QueryUnreceivedPacketsResponse is the response type for the\nQuery/UnreceivedPacketCommitments RPC method",
        "type": "object",
        "properties": {
          "sequences": {
            "title": "list of unreceived packet sequences",
            "type": "array",
            "items": {
              "type": "string",
              "format": "uint64"
            }
          },
          "height": {
            "title": "query block height",
            "type": "object",
            "properties": {
              "revision_number": {
                "title": "the revision that the client is currently on",
                "type": "string",
                "format": "uint64"
              },
              "revision_height": {
                "title": "the height within the given revision",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Normally the RevisionHeight is incremented at each height while keeping\nRevisionNumber the same. However some consensus algorithms may choose to\nreset the height in certain conditions e.g. hard forks, state-machine\nbreaking changes In these cases, the RevisionNumber is incremented so that\nheight continues to be monitonically increasing even as the RevisionHeight\ngets reset"
          }
        }
      },
      "ibc.core.channel.v1.State": {
        "type": "string",
        "description": "State defines if a channel is in one of the following states:\nCLOSED, INIT, TRYOPEN, OPEN or UNINITIALIZED.\n\n - STATE_UNINITIALIZED_UNSPECIFIED: Default State\n - STATE_INIT: A channel has just started the opening handshake.\n - STATE_TRYOPEN: A channel has acknowledged the handshake step on the counterparty chain.\n - STATE_OPEN: A channel has completed the handshake. Open channels are\nready to send and receive packets.\n - STATE_CLOSED: A channel has been closed and can no longer be used to send or receive\npackets.",
        "default": "STATE_UNINITIALIZED_UNSPECIFIED",
        "enum": [
          "STATE_UNINITIALIZED_UNSPECIFIED",
          "STATE_INIT",
          "STATE_TRYOPEN",
          "STATE_OPEN",
          "STATE_CLOSED"
        ]
      },
      "cosmos.auth.v1beta1.AddressBytesToStringResponse": {
        "type": "object",
        "properties": {
          "address_string": {
            "type": "string"
          }
        },
        "description": "AddressBytesToStringResponse is the response type for AddressString rpc method.\n\nSince: cosmos-sdk 0.46"
      },
      "cosmos.auth.v1beta1.AddressStringToBytesResponse": {
        "type": "object",
        "properties": {
          "address_bytes": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          }
        },
        "description": "AddressStringToBytesResponse is the response type for AddressBytes rpc method.\n\nSince: cosmos-sdk 0.46"
      },
      "cosmos.auth.v1beta1.BaseAccount": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string"
          },
          "pub_key": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "account_number": {
            "type": "string",
            "format": "uint64"
          },
          "sequence": {
            "type": "string",
            "format": "uint64"
          }
        },
        "description": "BaseAccount defines a base account type. It contains all the necessary fields\nfor basic account functionality. Any custom account type should extend this\ntype for additional functionality (e.g. vesting)."
      },
      "cosmos.auth.v1beta1.Bech32PrefixResponse": {
        "type": "object",
        "properties": {
          "bech32_prefix": {
            "type": "string"
          }
        },
        "description": "Bech32PrefixResponse is the response type for Bech32Prefix rpc method.\n\nSince: cosmos-sdk 0.46"
      },
      "cosmos.auth.v1beta1.Params": {
        "type": "object",
        "properties": {
          "max_memo_characters": {
            "type": "string",
            "format": "uint64"
          },
          "tx_sig_limit": {
            "type": "string",
            "format": "uint64"
          },
          "tx_size_cost_per_byte": {
            "type": "string",
            "format": "uint64"
          },
          "sig_verify_cost_ed25519": {
            "type": "string",
            "format": "uint64"
          },
          "sig_verify_cost_secp256k1": {
            "type": "string",
            "format": "uint64"
          }
        },
        "description": "Params defines the parameters for the auth module."
      },
      "cosmos.auth.v1beta1.QueryAccountAddressByIDResponse": {
        "title": "QueryAccountAddressByIDResponse is the response type for AccountAddressByID rpc method",
        "type": "object",
        "properties": {
          "account_address": {
            "type": "string"
          }
        },
        "description": "Since: cosmos-sdk 0.46.2"
      },
      "cosmos.auth.v1beta1.QueryAccountInfoResponse": {
        "type": "object",
        "properties": {
          "info": {
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "pub_key": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                    "format": "byte"
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "account_number": {
                "type": "string",
                "format": "uint64"
              },
              "sequence": {
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "info is the account info which is represented by BaseAccount."
          }
        },
        "description": "QueryAccountInfoResponse is the Query/AccountInfo response type.\n\nSince: cosmos-sdk 0.47"
      },
      "cosmos.auth.v1beta1.QueryAccountResponse": {
        "type": "object",
        "properties": {
          "account": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          }
        },
        "description": "QueryAccountResponse is the response type for the Query/Account RPC method."
      },
      "cosmos.auth.v1beta1.QueryAccountsResponse": {
        "type": "object",
        "properties": {
          "accounts": {
            "title": "accounts are the existing accounts",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "byte"
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryAccountsResponse is the response type for the Query/Accounts RPC method.\n\nSince: cosmos-sdk 0.43"
      },
      "cosmos.auth.v1beta1.QueryModuleAccountByNameResponse": {
        "type": "object",
        "properties": {
          "account": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          }
        },
        "description": "QueryModuleAccountByNameResponse is the response type for the Query/ModuleAccountByName RPC method."
      },
      "cosmos.auth.v1beta1.QueryModuleAccountsResponse": {
        "type": "object",
        "properties": {
          "accounts": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "byte"
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            }
          }
        },
        "description": "QueryModuleAccountsResponse is the response type for the Query/ModuleAccounts RPC method.\n\nSince: cosmos-sdk 0.46"
      },
      "cosmos.auth.v1beta1.QueryParamsResponse": {
        "type": "object",
        "properties": {
          "params": {
            "type": "object",
            "properties": {
              "max_memo_characters": {
                "type": "string",
                "format": "uint64"
              },
              "tx_sig_limit": {
                "type": "string",
                "format": "uint64"
              },
              "tx_size_cost_per_byte": {
                "type": "string",
                "format": "uint64"
              },
              "sig_verify_cost_ed25519": {
                "type": "string",
                "format": "uint64"
              },
              "sig_verify_cost_secp256k1": {
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "params defines the parameters of the module."
          }
        },
        "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
      },
      "cosmos.authz.v1beta1.Grant": {
        "type": "object",
        "properties": {
          "authorization": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "expiration": {
            "title": "time when the grant will expire and will be pruned. If null, then the grant\ndoesn't have a time expiration (other conditions  in `authorization`\nmay apply to invalidate the grant)",
            "type": "string",
            "format": "date-time"
          }
        },
        "description": "Grant gives permissions to execute\nthe provide method with expiration time."
      },
      "cosmos.authz.v1beta1.GrantAuthorization": {
        "title": "GrantAuthorization extends a grant with both the addresses of the grantee and granter.\nIt is used in genesis.proto and query.proto",
        "type": "object",
        "properties": {
          "granter": {
            "type": "string"
          },
          "grantee": {
            "type": "string"
          },
          "authorization": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "expiration": {
            "type": "string",
            "format": "date-time"
          }
        }
      },
      "cosmos.authz.v1beta1.QueryGranteeGrantsResponse": {
        "type": "object",
        "properties": {
          "grants": {
            "type": "array",
            "description": "grants is a list of grants granted to the grantee.",
            "items": {
              "title": "GrantAuthorization extends a grant with both the addresses of the grantee and granter.\nIt is used in genesis.proto and query.proto",
              "type": "object",
              "properties": {
                "granter": {
                  "type": "string"
                },
                "grantee": {
                  "type": "string"
                },
                "authorization": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "byte"
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                },
                "expiration": {
                  "type": "string",
                  "format": "date-time"
                }
              }
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines an pagination for the response."
          }
        },
        "description": "QueryGranteeGrantsResponse is the response type for the Query/GranteeGrants RPC method."
      },
      "cosmos.authz.v1beta1.QueryGranterGrantsResponse": {
        "type": "object",
        "properties": {
          "grants": {
            "type": "array",
            "description": "grants is a list of grants granted by the granter.",
            "items": {
              "title": "GrantAuthorization extends a grant with both the addresses of the grantee and granter.\nIt is used in genesis.proto and query.proto",
              "type": "object",
              "properties": {
                "granter": {
                  "type": "string"
                },
                "grantee": {
                  "type": "string"
                },
                "authorization": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "byte"
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                },
                "expiration": {
                  "type": "string",
                  "format": "date-time"
                }
              }
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines an pagination for the response."
          }
        },
        "description": "QueryGranterGrantsResponse is the response type for the Query/GranterGrants RPC method."
      },
      "cosmos.authz.v1beta1.QueryGrantsResponse": {
        "type": "object",
        "properties": {
          "grants": {
            "type": "array",
            "description": "authorizations is a list of grants granted for grantee by granter.",
            "items": {
              "type": "object",
              "properties": {
                "authorization": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "byte"
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                },
                "expiration": {
                  "title": "time when the grant will expire and will be pruned. If null, then the grant\ndoesn't have a time expiration (other conditions  in `authorization`\nmay apply to invalidate the grant)",
                  "type": "string",
                  "format": "date-time"
                }
              },
              "description": "Grant gives permissions to execute\nthe provide method with expiration time."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines an pagination for the response."
          }
        },
        "description": "QueryGrantsResponse is the response type for the Query/Authorizations RPC method."
      },
      "cosmos.bank.v1beta1.DenomOwner": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string",
            "description": "address defines the address that owns a particular denomination."
          },
          "balance": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          }
        },
        "description": "DenomOwner defines structure representing an account that owns or holds a\nparticular denominated token. It contains the account address and account\nbalance of the denominated token.\n\nSince: cosmos-sdk 0.46"
      },
      "cosmos.bank.v1beta1.DenomUnit": {
        "type": "object",
        "properties": {
          "denom": {
            "type": "string",
            "description": "denom represents the string name of the given denom unit (e.g uatom)."
          },
          "exponent": {
            "type": "integer",
            "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 10^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom).",
            "format": "int64"
          },
          "aliases": {
            "title": "aliases is a list of string aliases for the given denom",
            "type": "array",
            "items": {
              "type": "string"
            }
          }
        },
        "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
      },
      "cosmos.bank.v1beta1.Metadata": {
        "type": "object",
        "properties": {
          "description": {
            "type": "string"
          },
          "denom_units": {
            "title": "denom_units represents the list of DenomUnit's for a given coin",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string",
                  "description": "denom represents the string name of the given denom unit (e.g uatom)."
                },
                "exponent": {
                  "type": "integer",
                  "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 10^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom).",
                  "format": "int64"
                },
                "aliases": {
                  "title": "aliases is a list of string aliases for the given denom",
                  "type": "array",
                  "items": {
                    "type": "string"
                  }
                }
              },
              "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
            }
          },
          "base": {
            "type": "string",
            "description": "base represents the base denom (should be the DenomUnit with exponent = 0)."
          },
          "display": {
            "type": "string",
            "description": "display indicates the suggested denom that should be\ndisplayed in clients."
          },
          "name": {
            "title": "name defines the name of the token (eg: Cosmos Atom)",
            "type": "string",
            "description": "Since: cosmos-sdk 0.43"
          },
          "symbol": {
            "type": "string",
            "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.\n\nSince: cosmos-sdk 0.43"
          },
          "uri": {
            "type": "string",
            "description": "URI to a document (on or off-chain) that contains additional information. Optional.\n\nSince: cosmos-sdk 0.46"
          },
          "uri_hash": {
            "type": "string",
            "description": "URIHash is a sha256 hash of a document pointed by URI. It's used to verify that\nthe document didn't change. Optional.\n\nSince: cosmos-sdk 0.46"
          }
        },
        "description": "Metadata represents a struct that describes\na basic token."
      },
      "cosmos.bank.v1beta1.Params": {
        "type": "object",
        "properties": {
          "send_enabled": {
            "type": "array",
            "description": "Deprecated: Use of SendEnabled in params is deprecated.\nFor genesis, use the newly added send_enabled field in the genesis object.\nStorage, lookup, and manipulation of this information is now in the keeper.\n\nAs of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files.",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "enabled": {
                  "type": "boolean"
                }
              },
              "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable)."
            }
          },
          "default_send_enabled": {
            "type": "boolean"
          }
        },
        "description": "Params defines the parameters for the bank module."
      },
      "cosmos.bank.v1beta1.QueryAllBalancesResponse": {
        "type": "object",
        "properties": {
          "balances": {
            "type": "array",
            "description": "balances is the balances of all the coins.",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryAllBalancesResponse is the response type for the Query/AllBalances RPC\nmethod."
      },
      "cosmos.bank.v1beta1.QueryBalanceResponse": {
        "type": "object",
        "properties": {
          "balance": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          }
        },
        "description": "QueryBalanceResponse is the response type for the Query/Balance RPC method."
      },
      "cosmos.bank.v1beta1.QueryDenomMetadataByQueryStringResponse": {
        "type": "object",
        "properties": {
          "metadata": {
            "type": "object",
            "properties": {
              "description": {
                "type": "string"
              },
              "denom_units": {
                "title": "denom_units represents the list of DenomUnit's for a given coin",
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string",
                      "description": "denom represents the string name of the given denom unit (e.g uatom)."
                    },
                    "exponent": {
                      "type": "integer",
                      "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 10^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom).",
                      "format": "int64"
                    },
                    "aliases": {
                      "title": "aliases is a list of string aliases for the given denom",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
                }
              },
              "base": {
                "type": "string",
                "description": "base represents the base denom (should be the DenomUnit with exponent = 0)."
              },
              "display": {
                "type": "string",
                "description": "display indicates the suggested denom that should be\ndisplayed in clients."
              },
              "name": {
                "title": "name defines the name of the token (eg: Cosmos Atom)",
                "type": "string",
                "description": "Since: cosmos-sdk 0.43"
              },
              "symbol": {
                "type": "string",
                "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.\n\nSince: cosmos-sdk 0.43"
              },
              "uri": {
                "type": "string",
                "description": "URI to a document (on or off-chain) that contains additional information. Optional.\n\nSince: cosmos-sdk 0.46"
              },
              "uri_hash": {
                "type": "string",
                "description": "URIHash is a sha256 hash of a document pointed by URI. It's used to verify that\nthe document didn't change. Optional.\n\nSince: cosmos-sdk 0.46"
              }
            },
            "description": "Metadata represents a struct that describes\na basic token."
          }
        },
        "description": "QueryDenomMetadataByQueryStringResponse is the response type for the Query/DenomMetadata RPC\nmethod. Identical with QueryDenomMetadataResponse but receives denom as query string in request."
      },
      "cosmos.bank.v1beta1.QueryDenomMetadataResponse": {
        "type": "object",
        "properties": {
          "metadata": {
            "type": "object",
            "properties": {
              "description": {
                "type": "string"
              },
              "denom_units": {
                "title": "denom_units represents the list of DenomUnit's for a given coin",
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string",
                      "description": "denom represents the string name of the given denom unit (e.g uatom)."
                    },
                    "exponent": {
                      "type": "integer",
                      "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 10^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom).",
                      "format": "int64"
                    },
                    "aliases": {
                      "title": "aliases is a list of string aliases for the given denom",
                      "type": "array",
                      "items": {
                        "type": "string"
                      }
                    }
                  },
                  "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
                }
              },
              "base": {
                "type": "string",
                "description": "base represents the base denom (should be the DenomUnit with exponent = 0)."
              },
              "display": {
                "type": "string",
                "description": "display indicates the suggested denom that should be\ndisplayed in clients."
              },
              "name": {
                "title": "name defines the name of the token (eg: Cosmos Atom)",
                "type": "string",
                "description": "Since: cosmos-sdk 0.43"
              },
              "symbol": {
                "type": "string",
                "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.\n\nSince: cosmos-sdk 0.43"
              },
              "uri": {
                "type": "string",
                "description": "URI to a document (on or off-chain) that contains additional information. Optional.\n\nSince: cosmos-sdk 0.46"
              },
              "uri_hash": {
                "type": "string",
                "description": "URIHash is a sha256 hash of a document pointed by URI. It's used to verify that\nthe document didn't change. Optional.\n\nSince: cosmos-sdk 0.46"
              }
            },
            "description": "Metadata represents a struct that describes\na basic token."
          }
        },
        "description": "QueryDenomMetadataResponse is the response type for the Query/DenomMetadata RPC\nmethod."
      },
      "cosmos.bank.v1beta1.QueryDenomOwnersResponse": {
        "type": "object",
        "properties": {
          "denom_owners": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string",
                  "description": "address defines the address that owns a particular denomination."
                },
                "balance": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "description": "DenomOwner defines structure representing an account that owns or holds a\nparticular denominated token. It contains the account address and account\nbalance of the denominated token.\n\nSince: cosmos-sdk 0.46"
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryDenomOwnersResponse defines the RPC response of a DenomOwners RPC query.\n\nSince: cosmos-sdk 0.46"
      },
      "cosmos.bank.v1beta1.QueryDenomsMetadataResponse": {
        "type": "object",
        "properties": {
          "metadatas": {
            "type": "array",
            "description": "metadata provides the client information for all the registered tokens.",
            "items": {
              "type": "object",
              "properties": {
                "description": {
                  "type": "string"
                },
                "denom_units": {
                  "title": "denom_units represents the list of DenomUnit's for a given coin",
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string",
                        "description": "denom represents the string name of the given denom unit (e.g uatom)."
                      },
                      "exponent": {
                        "type": "integer",
                        "description": "exponent represents power of 10 exponent that one must\nraise the base_denom to in order to equal the given DenomUnit's denom\n1 denom = 10^exponent base_denom\n(e.g. with a base_denom of uatom, one can create a DenomUnit of 'atom' with\nexponent = 6, thus: 1 atom = 10^6 uatom).",
                        "format": "int64"
                      },
                      "aliases": {
                        "title": "aliases is a list of string aliases for the given denom",
                        "type": "array",
                        "items": {
                          "type": "string"
                        }
                      }
                    },
                    "description": "DenomUnit represents a struct that describes a given\ndenomination unit of the basic token."
                  }
                },
                "base": {
                  "type": "string",
                  "description": "base represents the base denom (should be the DenomUnit with exponent = 0)."
                },
                "display": {
                  "type": "string",
                  "description": "display indicates the suggested denom that should be\ndisplayed in clients."
                },
                "name": {
                  "title": "name defines the name of the token (eg: Cosmos Atom)",
                  "type": "string",
                  "description": "Since: cosmos-sdk 0.43"
                },
                "symbol": {
                  "type": "string",
                  "description": "symbol is the token symbol usually shown on exchanges (eg: ATOM). This can\nbe the same as the display.\n\nSince: cosmos-sdk 0.43"
                },
                "uri": {
                  "type": "string",
                  "description": "URI to a document (on or off-chain) that contains additional information. Optional.\n\nSince: cosmos-sdk 0.46"
                },
                "uri_hash": {
                  "type": "string",
                  "description": "URIHash is a sha256 hash of a document pointed by URI. It's used to verify that\nthe document didn't change. Optional.\n\nSince: cosmos-sdk 0.46"
                }
              },
              "description": "Metadata represents a struct that describes\na basic token."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryDenomsMetadataResponse is the response type for the Query/DenomsMetadata RPC\nmethod."
      },
      "cosmos.bank.v1beta1.QueryParamsResponse": {
        "type": "object",
        "properties": {
          "params": {
            "type": "object",
            "properties": {
              "send_enabled": {
                "type": "array",
                "description": "Deprecated: Use of SendEnabled in params is deprecated.\nFor genesis, use the newly added send_enabled field in the genesis object.\nStorage, lookup, and manipulation of this information is now in the keeper.\n\nAs of cosmos-sdk 0.47, this only exists for backwards compatibility of genesis files.",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "enabled": {
                      "type": "boolean"
                    }
                  },
                  "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable)."
                }
              },
              "default_send_enabled": {
                "type": "boolean"
              }
            },
            "description": "params provides the parameters of the bank module."
          }
        },
        "description": "QueryParamsResponse defines the response type for querying x/bank parameters."
      },
      "cosmos.bank.v1beta1.QuerySendEnabledResponse": {
        "type": "object",
        "properties": {
          "send_enabled": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "enabled": {
                  "type": "boolean"
                }
              },
              "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable)."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response. This field is only\npopulated if the denoms field in the request is empty."
          }
        },
        "description": "QuerySendEnabledResponse defines the RPC response of a SendEnable query.\n\nSince: cosmos-sdk 0.47"
      },
      "cosmos.bank.v1beta1.QuerySpendableBalanceByDenomResponse": {
        "type": "object",
        "properties": {
          "balance": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          }
        },
        "description": "QuerySpendableBalanceByDenomResponse defines the gRPC response structure for\nquerying an account's spendable balance for a specific denom.\n\nSince: cosmos-sdk 0.47"
      },
      "cosmos.bank.v1beta1.QuerySpendableBalancesResponse": {
        "type": "object",
        "properties": {
          "balances": {
            "type": "array",
            "description": "balances is the spendable balances of all the coins.",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QuerySpendableBalancesResponse defines the gRPC response structure for querying\nan account's spendable balances.\n\nSince: cosmos-sdk 0.46"
      },
      "cosmos.bank.v1beta1.QuerySupplyOfResponse": {
        "type": "object",
        "properties": {
          "amount": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          }
        },
        "description": "QuerySupplyOfResponse is the response type for the Query/SupplyOf RPC method."
      },
      "cosmos.bank.v1beta1.QueryTotalSupplyResponse": {
        "title": "QueryTotalSupplyResponse is the response type for the Query/TotalSupply RPC\nmethod",
        "type": "object",
        "properties": {
          "supply": {
            "title": "supply is the supply of the coins",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response.\n\nSince: cosmos-sdk 0.43"
          }
        }
      },
      "cosmos.bank.v1beta1.SendEnabled": {
        "type": "object",
        "properties": {
          "denom": {
            "type": "string"
          },
          "enabled": {
            "type": "boolean"
          }
        },
        "description": "SendEnabled maps coin denom to a send_enabled status (whether a denom is\nsendable)."
      },
      "cosmos.distribution.v1beta1.DelegationDelegatorReward": {
        "type": "object",
        "properties": {
          "validator_address": {
            "type": "string"
          },
          "reward": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
            }
          }
        },
        "description": "DelegationDelegatorReward represents the properties\nof a delegator's delegation reward."
      },
      "cosmos.distribution.v1beta1.Params": {
        "type": "object",
        "properties": {
          "community_tax": {
            "type": "string"
          },
          "base_proposer_reward": {
            "type": "string",
            "description": "Deprecated: The base_proposer_reward field is deprecated and is no longer used\nin the x/distribution module's reward mechanism."
          },
          "bonus_proposer_reward": {
            "type": "string",
            "description": "Deprecated: The bonus_proposer_reward field is deprecated and is no longer used\nin the x/distribution module's reward mechanism."
          },
          "withdraw_addr_enabled": {
            "type": "boolean"
          }
        },
        "description": "Params defines the set of params for the distribution module."
      },
      "cosmos.distribution.v1beta1.QueryCommunityPoolResponse": {
        "type": "object",
        "properties": {
          "pool": {
            "type": "array",
            "description": "pool defines community pool's coins.",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
            }
          }
        },
        "description": "QueryCommunityPoolResponse is the response type for the Query/CommunityPool\nRPC method."
      },
      "cosmos.distribution.v1beta1.QueryDelegationRewardsResponse": {
        "type": "object",
        "properties": {
          "rewards": {
            "type": "array",
            "description": "rewards defines the rewards accrued by a delegation.",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
            }
          }
        },
        "description": "QueryDelegationRewardsResponse is the response type for the\nQuery/DelegationRewards RPC method."
      },
      "cosmos.distribution.v1beta1.QueryDelegationTotalRewardsResponse": {
        "type": "object",
        "properties": {
          "rewards": {
            "type": "array",
            "description": "rewards defines all the rewards accrued by a delegator.",
            "items": {
              "type": "object",
              "properties": {
                "validator_address": {
                  "type": "string"
                },
                "reward": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                  }
                }
              },
              "description": "DelegationDelegatorReward represents the properties\nof a delegator's delegation reward."
            }
          },
          "total": {
            "type": "array",
            "description": "total defines the sum of all the rewards.",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
            }
          }
        },
        "description": "QueryDelegationTotalRewardsResponse is the response type for the\nQuery/DelegationTotalRewards RPC method."
      },
      "cosmos.distribution.v1beta1.QueryDelegatorValidatorsResponse": {
        "type": "object",
        "properties": {
          "validators": {
            "type": "array",
            "description": "validators defines the validators a delegator is delegating for.",
            "items": {
              "type": "string"
            }
          }
        },
        "description": "QueryDelegatorValidatorsResponse is the response type for the\nQuery/DelegatorValidators RPC method."
      },
      "cosmos.distribution.v1beta1.QueryDelegatorWithdrawAddressResponse": {
        "type": "object",
        "properties": {
          "withdraw_address": {
            "type": "string",
            "description": "withdraw_address defines the delegator address to query for."
          }
        },
        "description": "QueryDelegatorWithdrawAddressResponse is the response type for the\nQuery/DelegatorWithdrawAddress RPC method."
      },
      "cosmos.distribution.v1beta1.QueryParamsResponse": {
        "type": "object",
        "properties": {
          "params": {
            "type": "object",
            "properties": {
              "community_tax": {
                "type": "string"
              },
              "base_proposer_reward": {
                "type": "string",
                "description": "Deprecated: The base_proposer_reward field is deprecated and is no longer used\nin the x/distribution module's reward mechanism."
              },
              "bonus_proposer_reward": {
                "type": "string",
                "description": "Deprecated: The bonus_proposer_reward field is deprecated and is no longer used\nin the x/distribution module's reward mechanism."
              },
              "withdraw_addr_enabled": {
                "type": "boolean"
              }
            },
            "description": "params defines the parameters of the module."
          }
        },
        "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
      },
      "cosmos.distribution.v1beta1.QueryValidatorCommissionResponse": {
        "title": "QueryValidatorCommissionResponse is the response type for the\nQuery/ValidatorCommission RPC method",
        "type": "object",
        "properties": {
          "commission": {
            "type": "object",
            "properties": {
              "commission": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                }
              }
            },
            "description": "commission defines the commission the validator received."
          }
        }
      },
      "cosmos.distribution.v1beta1.QueryValidatorDistributionInfoResponse": {
        "type": "object",
        "properties": {
          "operator_address": {
            "type": "string",
            "description": "operator_address defines the validator operator address."
          },
          "self_bond_rewards": {
            "type": "array",
            "description": "self_bond_rewards defines the self delegations rewards.",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
            }
          },
          "commission": {
            "type": "array",
            "description": "commission defines the commission the validator received.",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
            }
          }
        },
        "description": "QueryValidatorDistributionInfoResponse is the response type for the Query/ValidatorDistributionInfo RPC method."
      },
      "cosmos.distribution.v1beta1.QueryValidatorOutstandingRewardsResponse": {
        "type": "object",
        "properties": {
          "rewards": {
            "type": "object",
            "properties": {
              "rewards": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
                }
              }
            },
            "description": "ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards\nfor a validator inexpensive to track, allows simple sanity checks."
          }
        },
        "description": "QueryValidatorOutstandingRewardsResponse is the response type for the\nQuery/ValidatorOutstandingRewards RPC method."
      },
      "cosmos.distribution.v1beta1.QueryValidatorSlashesResponse": {
        "type": "object",
        "properties": {
          "slashes": {
            "type": "array",
            "description": "slashes defines the slashes the validator received.",
            "items": {
              "type": "object",
              "properties": {
                "validator_period": {
                  "type": "string",
                  "format": "uint64"
                },
                "fraction": {
                  "type": "string"
                }
              },
              "description": "ValidatorSlashEvent represents a validator slash event.\nHeight is implicit within the store key.\nThis is needed to calculate appropriate amount of staking tokens\nfor delegations which are withdrawn after a slash has occurred."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryValidatorSlashesResponse is the response type for the\nQuery/ValidatorSlashes RPC method."
      },
      "cosmos.distribution.v1beta1.ValidatorAccumulatedCommission": {
        "type": "object",
        "properties": {
          "commission": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
            }
          }
        },
        "description": "ValidatorAccumulatedCommission represents accumulated commission\nfor a validator kept as a running counter, can be withdrawn at any time."
      },
      "cosmos.distribution.v1beta1.ValidatorOutstandingRewards": {
        "type": "object",
        "properties": {
          "rewards": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "DecCoin defines a token with a denomination and a decimal amount.\n\nNOTE: The amount field is an Dec which implements the custom method\nsignatures required by gogoproto."
            }
          }
        },
        "description": "ValidatorOutstandingRewards represents outstanding (un-withdrawn) rewards\nfor a validator inexpensive to track, allows simple sanity checks."
      },
      "cosmos.distribution.v1beta1.ValidatorSlashEvent": {
        "type": "object",
        "properties": {
          "validator_period": {
            "type": "string",
            "format": "uint64"
          },
          "fraction": {
            "type": "string"
          }
        },
        "description": "ValidatorSlashEvent represents a validator slash event.\nHeight is implicit within the store key.\nThis is needed to calculate appropriate amount of staking tokens\nfor delegations which are withdrawn after a slash has occurred."
      },
      "cosmos.feegrant.v1beta1.Grant": {
        "title": "Grant is stored in the KVStore to record a grant with full context",
        "type": "object",
        "properties": {
          "granter": {
            "type": "string",
            "description": "granter is the address of the user granting an allowance of their funds."
          },
          "grantee": {
            "type": "string",
            "description": "grantee is the address of the user being granted an allowance of another user's funds."
          },
          "allowance": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "allowance can be any of basic, periodic, allowed fee allowance."
          }
        }
      },
      "cosmos.feegrant.v1beta1.QueryAllowanceResponse": {
        "type": "object",
        "properties": {
          "allowance": {
            "title": "Grant is stored in the KVStore to record a grant with full context",
            "type": "object",
            "properties": {
              "granter": {
                "type": "string",
                "description": "granter is the address of the user granting an allowance of their funds."
              },
              "grantee": {
                "type": "string",
                "description": "grantee is the address of the user being granted an allowance of another user's funds."
              },
              "allowance": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                    "format": "byte"
                  }
                },
                "description": "allowance can be any of basic, periodic, allowed fee allowance."
              }
            },
            "description": "allowance is a allowance granted for grantee by granter."
          }
        },
        "description": "QueryAllowanceResponse is the response type for the Query/Allowance RPC method."
      },
      "cosmos.feegrant.v1beta1.QueryAllowancesByGranterResponse": {
        "type": "object",
        "properties": {
          "allowances": {
            "type": "array",
            "description": "allowances that have been issued by the granter.",
            "items": {
              "title": "Grant is stored in the KVStore to record a grant with full context",
              "type": "object",
              "properties": {
                "granter": {
                  "type": "string",
                  "description": "granter is the address of the user granting an allowance of their funds."
                },
                "grantee": {
                  "type": "string",
                  "description": "grantee is the address of the user being granted an allowance of another user's funds."
                },
                "allowance": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "byte"
                    }
                  },
                  "description": "allowance can be any of basic, periodic, allowed fee allowance."
                }
              }
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines an pagination for the response."
          }
        },
        "description": "QueryAllowancesByGranterResponse is the response type for the Query/AllowancesByGranter RPC method.\n\nSince: cosmos-sdk 0.46"
      },
      "cosmos.feegrant.v1beta1.QueryAllowancesResponse": {
        "type": "object",
        "properties": {
          "allowances": {
            "type": "array",
            "description": "allowances are allowance's granted for grantee by granter.",
            "items": {
              "title": "Grant is stored in the KVStore to record a grant with full context",
              "type": "object",
              "properties": {
                "granter": {
                  "type": "string",
                  "description": "granter is the address of the user granting an allowance of their funds."
                },
                "grantee": {
                  "type": "string",
                  "description": "grantee is the address of the user being granted an allowance of another user's funds."
                },
                "allowance": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "byte"
                    }
                  },
                  "description": "allowance can be any of basic, periodic, allowed fee allowance."
                }
              }
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines an pagination for the response."
          }
        },
        "description": "QueryAllowancesResponse is the response type for the Query/Allowances RPC method."
      },
      "cosmos.evidence.v1beta1.QueryAllEvidenceResponse": {
        "type": "object",
        "properties": {
          "evidence": {
            "type": "array",
            "description": "evidence returns all evidences.",
            "items": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "byte"
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryAllEvidenceResponse is the response type for the Query/AllEvidence RPC\nmethod."
      },
      "cosmos.evidence.v1beta1.QueryEvidenceResponse": {
        "type": "object",
        "properties": {
          "evidence": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          }
        },
        "description": "QueryEvidenceResponse is the response type for the Query/Evidence RPC method."
      },
      "cosmos.gov.v1beta1.Deposit": {
        "type": "object",
        "properties": {
          "proposal_id": {
            "type": "string",
            "description": "proposal_id defines the unique id of the proposal.",
            "format": "uint64"
          },
          "depositor": {
            "type": "string",
            "description": "depositor defines the deposit addresses from the proposals."
          },
          "amount": {
            "type": "array",
            "description": "amount to be deposited by depositor.",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            }
          }
        },
        "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
      },
      "cosmos.gov.v1beta1.DepositParams": {
        "type": "object",
        "properties": {
          "min_deposit": {
            "type": "array",
            "description": "Minimum deposit for a proposal to enter voting period.",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            }
          },
          "max_deposit_period": {
            "type": "string",
            "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
          }
        },
        "description": "DepositParams defines the params for deposits on governance proposals."
      },
      "cosmos.gov.v1beta1.Proposal": {
        "type": "object",
        "properties": {
          "proposal_id": {
            "type": "string",
            "description": "proposal_id defines the unique id of the proposal.",
            "format": "uint64"
          },
          "content": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "status": {
            "type": "string",
            "description": "status defines the proposal status.",
            "default": "PROPOSAL_STATUS_UNSPECIFIED",
            "enum": [
              "PROPOSAL_STATUS_UNSPECIFIED",
              "PROPOSAL_STATUS_DEPOSIT_PERIOD",
              "PROPOSAL_STATUS_VOTING_PERIOD",
              "PROPOSAL_STATUS_PASSED",
              "PROPOSAL_STATUS_REJECTED",
              "PROPOSAL_STATUS_FAILED"
            ]
          },
          "final_tally_result": {
            "type": "object",
            "properties": {
              "yes": {
                "type": "string",
                "description": "yes is the number of yes votes on a proposal."
              },
              "abstain": {
                "type": "string",
                "description": "abstain is the number of abstain votes on a proposal."
              },
              "no": {
                "type": "string",
                "description": "no is the number of no votes on a proposal."
              },
              "no_with_veto": {
                "type": "string",
                "description": "no_with_veto is the number of no with veto votes on a proposal."
              }
            },
            "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended."
          },
          "submit_time": {
            "type": "string",
            "description": "submit_time is the time of proposal submission.",
            "format": "date-time"
          },
          "deposit_end_time": {
            "type": "string",
            "description": "deposit_end_time is the end time for deposition.",
            "format": "date-time"
          },
          "total_deposit": {
            "type": "array",
            "description": "total_deposit is the total deposit on the proposal.",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            }
          },
          "voting_start_time": {
            "type": "string",
            "description": "voting_start_time is the starting time to vote on a proposal.",
            "format": "date-time"
          },
          "voting_end_time": {
            "type": "string",
            "description": "voting_end_time is the end time of voting on a proposal.",
            "format": "date-time"
          }
        },
        "description": "Proposal defines the core field members of a governance proposal."
      },
      "cosmos.gov.v1beta1.ProposalStatus": {
        "type": "string",
        "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed.",
        "default": "PROPOSAL_STATUS_UNSPECIFIED",
        "enum": [
          "PROPOSAL_STATUS_UNSPECIFIED",
          "PROPOSAL_STATUS_DEPOSIT_PERIOD",
          "PROPOSAL_STATUS_VOTING_PERIOD",
          "PROPOSAL_STATUS_PASSED",
          "PROPOSAL_STATUS_REJECTED",
          "PROPOSAL_STATUS_FAILED"
        ]
      },
      "cosmos.gov.v1beta1.QueryDepositResponse": {
        "type": "object",
        "properties": {
          "deposit": {
            "type": "object",
            "properties": {
              "proposal_id": {
                "type": "string",
                "description": "proposal_id defines the unique id of the proposal.",
                "format": "uint64"
              },
              "depositor": {
                "type": "string",
                "description": "depositor defines the deposit addresses from the proposals."
              },
              "amount": {
                "type": "array",
                "description": "amount to be deposited by depositor.",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              }
            },
            "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
          }
        },
        "description": "QueryDepositResponse is the response type for the Query/Deposit RPC method."
      },
      "cosmos.gov.v1beta1.QueryDepositsResponse": {
        "type": "object",
        "properties": {
          "deposits": {
            "type": "array",
            "description": "deposits defines the requested deposits.",
            "items": {
              "type": "object",
              "properties": {
                "proposal_id": {
                  "type": "string",
                  "description": "proposal_id defines the unique id of the proposal.",
                  "format": "uint64"
                },
                "depositor": {
                  "type": "string",
                  "description": "depositor defines the deposit addresses from the proposals."
                },
                "amount": {
                  "type": "array",
                  "description": "amount to be deposited by depositor.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                  }
                }
              },
              "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryDepositsResponse is the response type for the Query/Deposits RPC method."
      },
      "cosmos.gov.v1beta1.QueryParamsResponse": {
        "type": "object",
        "properties": {
          "voting_params": {
            "type": "object",
            "properties": {
              "voting_period": {
                "type": "string",
                "description": "Duration of the voting period."
              }
            },
            "description": "voting_params defines the parameters related to voting."
          },
          "deposit_params": {
            "type": "object",
            "properties": {
              "min_deposit": {
                "type": "array",
                "description": "Minimum deposit for a proposal to enter voting period.",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "max_deposit_period": {
                "type": "string",
                "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
              }
            },
            "description": "deposit_params defines the parameters related to deposit."
          },
          "tally_params": {
            "type": "object",
            "properties": {
              "quorum": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Minimum percentage of total stake needed to vote for a result to be\nconsidered valid.",
                "format": "byte"
              },
              "threshold": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.",
                "format": "byte"
              },
              "veto_threshold": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\nvetoed. Default value: 1/3.",
                "format": "byte"
              }
            },
            "description": "tally_params defines the parameters related to tally."
          }
        },
        "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
      },
      "cosmos.gov.v1beta1.QueryProposalResponse": {
        "type": "object",
        "properties": {
          "proposal": {
            "type": "object",
            "properties": {
              "proposal_id": {
                "type": "string",
                "description": "proposal_id defines the unique id of the proposal.",
                "format": "uint64"
              },
              "content": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                    "format": "byte"
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "status": {
                "type": "string",
                "description": "status defines the proposal status.",
                "default": "PROPOSAL_STATUS_UNSPECIFIED",
                "enum": [
                  "PROPOSAL_STATUS_UNSPECIFIED",
                  "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                  "PROPOSAL_STATUS_VOTING_PERIOD",
                  "PROPOSAL_STATUS_PASSED",
                  "PROPOSAL_STATUS_REJECTED",
                  "PROPOSAL_STATUS_FAILED"
                ]
              },
              "final_tally_result": {
                "type": "object",
                "properties": {
                  "yes": {
                    "type": "string",
                    "description": "yes is the number of yes votes on a proposal."
                  },
                  "abstain": {
                    "type": "string",
                    "description": "abstain is the number of abstain votes on a proposal."
                  },
                  "no": {
                    "type": "string",
                    "description": "no is the number of no votes on a proposal."
                  },
                  "no_with_veto": {
                    "type": "string",
                    "description": "no_with_veto is the number of no with veto votes on a proposal."
                  }
                },
                "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended."
              },
              "submit_time": {
                "type": "string",
                "description": "submit_time is the time of proposal submission.",
                "format": "date-time"
              },
              "deposit_end_time": {
                "type": "string",
                "description": "deposit_end_time is the end time for deposition.",
                "format": "date-time"
              },
              "total_deposit": {
                "type": "array",
                "description": "total_deposit is the total deposit on the proposal.",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "voting_start_time": {
                "type": "string",
                "description": "voting_start_time is the starting time to vote on a proposal.",
                "format": "date-time"
              },
              "voting_end_time": {
                "type": "string",
                "description": "voting_end_time is the end time of voting on a proposal.",
                "format": "date-time"
              }
            },
            "description": "Proposal defines the core field members of a governance proposal."
          }
        },
        "description": "QueryProposalResponse is the response type for the Query/Proposal RPC method."
      },
      "cosmos.gov.v1beta1.QueryProposalsResponse": {
        "type": "object",
        "properties": {
          "proposals": {
            "type": "array",
            "description": "proposals defines all the requested governance proposals.",
            "items": {
              "type": "object",
              "properties": {
                "proposal_id": {
                  "type": "string",
                  "description": "proposal_id defines the unique id of the proposal.",
                  "format": "uint64"
                },
                "content": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "byte"
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                },
                "status": {
                  "type": "string",
                  "description": "status defines the proposal status.",
                  "default": "PROPOSAL_STATUS_UNSPECIFIED",
                  "enum": [
                    "PROPOSAL_STATUS_UNSPECIFIED",
                    "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                    "PROPOSAL_STATUS_VOTING_PERIOD",
                    "PROPOSAL_STATUS_PASSED",
                    "PROPOSAL_STATUS_REJECTED",
                    "PROPOSAL_STATUS_FAILED"
                  ]
                },
                "final_tally_result": {
                  "type": "object",
                  "properties": {
                    "yes": {
                      "type": "string",
                      "description": "yes is the number of yes votes on a proposal."
                    },
                    "abstain": {
                      "type": "string",
                      "description": "abstain is the number of abstain votes on a proposal."
                    },
                    "no": {
                      "type": "string",
                      "description": "no is the number of no votes on a proposal."
                    },
                    "no_with_veto": {
                      "type": "string",
                      "description": "no_with_veto is the number of no with veto votes on a proposal."
                    }
                  },
                  "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended."
                },
                "submit_time": {
                  "type": "string",
                  "description": "submit_time is the time of proposal submission.",
                  "format": "date-time"
                },
                "deposit_end_time": {
                  "type": "string",
                  "description": "deposit_end_time is the end time for deposition.",
                  "format": "date-time"
                },
                "total_deposit": {
                  "type": "array",
                  "description": "total_deposit is the total deposit on the proposal.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                  }
                },
                "voting_start_time": {
                  "type": "string",
                  "description": "voting_start_time is the starting time to vote on a proposal.",
                  "format": "date-time"
                },
                "voting_end_time": {
                  "type": "string",
                  "description": "voting_end_time is the end time of voting on a proposal.",
                  "format": "date-time"
                }
              },
              "description": "Proposal defines the core field members of a governance proposal."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryProposalsResponse is the response type for the Query/Proposals RPC\nmethod."
      },
      "cosmos.gov.v1beta1.QueryTallyResultResponse": {
        "type": "object",
        "properties": {
          "tally": {
            "type": "object",
            "properties": {
              "yes": {
                "type": "string",
                "description": "yes is the number of yes votes on a proposal."
              },
              "abstain": {
                "type": "string",
                "description": "abstain is the number of abstain votes on a proposal."
              },
              "no": {
                "type": "string",
                "description": "no is the number of no votes on a proposal."
              },
              "no_with_veto": {
                "type": "string",
                "description": "no_with_veto is the number of no with veto votes on a proposal."
              }
            },
            "description": "tally defines the requested tally."
          }
        },
        "description": "QueryTallyResultResponse is the response type for the Query/Tally RPC method."
      },
      "cosmos.gov.v1beta1.QueryVoteResponse": {
        "type": "object",
        "properties": {
          "vote": {
            "type": "object",
            "properties": {
              "proposal_id": {
                "type": "string",
                "description": "proposal_id defines the unique id of the proposal.",
                "format": "uint64"
              },
              "voter": {
                "type": "string",
                "description": "voter is the voter address of the proposal."
              },
              "option": {
                "type": "string",
                "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
                "default": "VOTE_OPTION_UNSPECIFIED",
                "enum": [
                  "VOTE_OPTION_UNSPECIFIED",
                  "VOTE_OPTION_YES",
                  "VOTE_OPTION_ABSTAIN",
                  "VOTE_OPTION_NO",
                  "VOTE_OPTION_NO_WITH_VETO"
                ]
              },
              "options": {
                "type": "array",
                "description": "options is the weighted vote options.\n\nSince: cosmos-sdk 0.43",
                "items": {
                  "type": "object",
                  "properties": {
                    "option": {
                      "type": "string",
                      "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                      "default": "VOTE_OPTION_UNSPECIFIED",
                      "enum": [
                        "VOTE_OPTION_UNSPECIFIED",
                        "VOTE_OPTION_YES",
                        "VOTE_OPTION_ABSTAIN",
                        "VOTE_OPTION_NO",
                        "VOTE_OPTION_NO_WITH_VETO"
                      ]
                    },
                    "weight": {
                      "type": "string",
                      "description": "weight is the vote weight associated with the vote option."
                    }
                  },
                  "description": "WeightedVoteOption defines a unit of vote for vote split.\n\nSince: cosmos-sdk 0.43"
                }
              }
            },
            "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
          }
        },
        "description": "QueryVoteResponse is the response type for the Query/Vote RPC method."
      },
      "cosmos.gov.v1beta1.QueryVotesResponse": {
        "type": "object",
        "properties": {
          "votes": {
            "type": "array",
            "description": "votes defines the queried votes.",
            "items": {
              "type": "object",
              "properties": {
                "proposal_id": {
                  "type": "string",
                  "description": "proposal_id defines the unique id of the proposal.",
                  "format": "uint64"
                },
                "voter": {
                  "type": "string",
                  "description": "voter is the voter address of the proposal."
                },
                "option": {
                  "type": "string",
                  "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
                  "default": "VOTE_OPTION_UNSPECIFIED",
                  "enum": [
                    "VOTE_OPTION_UNSPECIFIED",
                    "VOTE_OPTION_YES",
                    "VOTE_OPTION_ABSTAIN",
                    "VOTE_OPTION_NO",
                    "VOTE_OPTION_NO_WITH_VETO"
                  ]
                },
                "options": {
                  "type": "array",
                  "description": "options is the weighted vote options.\n\nSince: cosmos-sdk 0.43",
                  "items": {
                    "type": "object",
                    "properties": {
                      "option": {
                        "type": "string",
                        "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                        "default": "VOTE_OPTION_UNSPECIFIED",
                        "enum": [
                          "VOTE_OPTION_UNSPECIFIED",
                          "VOTE_OPTION_YES",
                          "VOTE_OPTION_ABSTAIN",
                          "VOTE_OPTION_NO",
                          "VOTE_OPTION_NO_WITH_VETO"
                        ]
                      },
                      "weight": {
                        "type": "string",
                        "description": "weight is the vote weight associated with the vote option."
                      }
                    },
                    "description": "WeightedVoteOption defines a unit of vote for vote split.\n\nSince: cosmos-sdk 0.43"
                  }
                }
              },
              "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryVotesResponse is the response type for the Query/Votes RPC method."
      },
      "cosmos.gov.v1beta1.TallyParams": {
        "type": "object",
        "properties": {
          "quorum": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "Minimum percentage of total stake needed to vote for a result to be\nconsidered valid.",
            "format": "byte"
          },
          "threshold": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5.",
            "format": "byte"
          },
          "veto_threshold": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\nvetoed. Default value: 1/3.",
            "format": "byte"
          }
        },
        "description": "TallyParams defines the params for tallying votes on governance proposals."
      },
      "cosmos.gov.v1beta1.TallyResult": {
        "type": "object",
        "properties": {
          "yes": {
            "type": "string",
            "description": "yes is the number of yes votes on a proposal."
          },
          "abstain": {
            "type": "string",
            "description": "abstain is the number of abstain votes on a proposal."
          },
          "no": {
            "type": "string",
            "description": "no is the number of no votes on a proposal."
          },
          "no_with_veto": {
            "type": "string",
            "description": "no_with_veto is the number of no with veto votes on a proposal."
          }
        },
        "description": "TallyResult defines a standard tally for a governance proposal."
      },
      "cosmos.gov.v1beta1.Vote": {
        "type": "object",
        "properties": {
          "proposal_id": {
            "type": "string",
            "description": "proposal_id defines the unique id of the proposal.",
            "format": "uint64"
          },
          "voter": {
            "type": "string",
            "description": "voter is the voter address of the proposal."
          },
          "option": {
            "type": "string",
            "description": "Deprecated: Prefer to use `options` instead. This field is set in queries\nif and only if `len(options) == 1` and that option has weight 1. In all\nother cases, this field will default to VOTE_OPTION_UNSPECIFIED.",
            "default": "VOTE_OPTION_UNSPECIFIED",
            "enum": [
              "VOTE_OPTION_UNSPECIFIED",
              "VOTE_OPTION_YES",
              "VOTE_OPTION_ABSTAIN",
              "VOTE_OPTION_NO",
              "VOTE_OPTION_NO_WITH_VETO"
            ]
          },
          "options": {
            "type": "array",
            "description": "options is the weighted vote options.\n\nSince: cosmos-sdk 0.43",
            "items": {
              "type": "object",
              "properties": {
                "option": {
                  "type": "string",
                  "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                  "default": "VOTE_OPTION_UNSPECIFIED",
                  "enum": [
                    "VOTE_OPTION_UNSPECIFIED",
                    "VOTE_OPTION_YES",
                    "VOTE_OPTION_ABSTAIN",
                    "VOTE_OPTION_NO",
                    "VOTE_OPTION_NO_WITH_VETO"
                  ]
                },
                "weight": {
                  "type": "string",
                  "description": "weight is the vote weight associated with the vote option."
                }
              },
              "description": "WeightedVoteOption defines a unit of vote for vote split.\n\nSince: cosmos-sdk 0.43"
            }
          }
        },
        "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
      },
      "cosmos.gov.v1beta1.VoteOption": {
        "type": "string",
        "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.",
        "default": "VOTE_OPTION_UNSPECIFIED",
        "enum": [
          "VOTE_OPTION_UNSPECIFIED",
          "VOTE_OPTION_YES",
          "VOTE_OPTION_ABSTAIN",
          "VOTE_OPTION_NO",
          "VOTE_OPTION_NO_WITH_VETO"
        ]
      },
      "cosmos.gov.v1beta1.VotingParams": {
        "type": "object",
        "properties": {
          "voting_period": {
            "type": "string",
            "description": "Duration of the voting period."
          }
        },
        "description": "VotingParams defines the params for voting on governance proposals."
      },
      "cosmos.gov.v1beta1.WeightedVoteOption": {
        "type": "object",
        "properties": {
          "option": {
            "type": "string",
            "description": "option defines the valid vote options, it must not contain duplicate vote options.",
            "default": "VOTE_OPTION_UNSPECIFIED",
            "enum": [
              "VOTE_OPTION_UNSPECIFIED",
              "VOTE_OPTION_YES",
              "VOTE_OPTION_ABSTAIN",
              "VOTE_OPTION_NO",
              "VOTE_OPTION_NO_WITH_VETO"
            ]
          },
          "weight": {
            "type": "string",
            "description": "weight is the vote weight associated with the vote option."
          }
        },
        "description": "WeightedVoteOption defines a unit of vote for vote split.\n\nSince: cosmos-sdk 0.43"
      },
      "cosmos.gov.v1.Deposit": {
        "type": "object",
        "properties": {
          "proposal_id": {
            "type": "string",
            "description": "proposal_id defines the unique id of the proposal.",
            "format": "uint64"
          },
          "depositor": {
            "type": "string",
            "description": "depositor defines the deposit addresses from the proposals."
          },
          "amount": {
            "type": "array",
            "description": "amount to be deposited by depositor.",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            }
          }
        },
        "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
      },
      "cosmos.gov.v1.DepositParams": {
        "type": "object",
        "properties": {
          "min_deposit": {
            "type": "array",
            "description": "Minimum deposit for a proposal to enter voting period.",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            }
          },
          "max_deposit_period": {
            "type": "string",
            "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
          }
        },
        "description": "DepositParams defines the params for deposits on governance proposals."
      },
      "cosmos.gov.v1.Params": {
        "type": "object",
        "properties": {
          "min_deposit": {
            "type": "array",
            "description": "Minimum deposit for a proposal to enter voting period.",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            }
          },
          "max_deposit_period": {
            "type": "string",
            "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
          },
          "voting_period": {
            "type": "string",
            "description": "Duration of the voting period."
          },
          "quorum": {
            "type": "string",
            "description": "Minimum percentage of total stake needed to vote for a result to be\n considered valid."
          },
          "threshold": {
            "type": "string",
            "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
          },
          "veto_threshold": {
            "type": "string",
            "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\n vetoed. Default value: 1/3."
          },
          "min_initial_deposit_ratio": {
            "type": "string",
            "description": "The ratio representing the proportion of the deposit value that must be paid at proposal submission."
          },
          "proposal_cancel_ratio": {
            "type": "string",
            "description": "The cancel ratio which will not be returned back to the depositors when a proposal is cancelled.\n\nSince: cosmos-sdk 0.50"
          },
          "proposal_cancel_dest": {
            "type": "string",
            "description": "The address which will receive (proposal_cancel_ratio * deposit) proposal deposits.\nIf empty, the (proposal_cancel_ratio * deposit) proposal deposits will be burned.\n\nSince: cosmos-sdk 0.50"
          },
          "expedited_voting_period": {
            "type": "string",
            "description": "Duration of the voting period of an expedited proposal.\n\nSince: cosmos-sdk 0.50"
          },
          "expedited_threshold": {
            "type": "string",
            "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.67.\n\nSince: cosmos-sdk 0.50"
          },
          "expedited_min_deposit": {
            "type": "array",
            "description": "Minimum expedited deposit for a proposal to enter voting period.",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            }
          },
          "burn_vote_quorum": {
            "title": "burn deposits if a proposal does not meet quorum",
            "type": "boolean"
          },
          "burn_proposal_deposit_prevote": {
            "title": "burn deposits if the proposal does not enter voting period",
            "type": "boolean"
          },
          "burn_vote_veto": {
            "title": "burn deposits if quorum with vote type no_veto is met",
            "type": "boolean"
          }
        },
        "description": "Params defines the parameters for the x/gov module.\n\nSince: cosmos-sdk 0.47"
      },
      "cosmos.gov.v1.Proposal": {
        "type": "object",
        "properties": {
          "id": {
            "type": "string",
            "description": "id defines the unique id of the proposal.",
            "format": "uint64"
          },
          "messages": {
            "type": "array",
            "description": "messages are the arbitrary messages to be executed if the proposal passes.",
            "items": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "byte"
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            }
          },
          "status": {
            "type": "string",
            "description": "status defines the proposal status.",
            "default": "PROPOSAL_STATUS_UNSPECIFIED",
            "enum": [
              "PROPOSAL_STATUS_UNSPECIFIED",
              "PROPOSAL_STATUS_DEPOSIT_PERIOD",
              "PROPOSAL_STATUS_VOTING_PERIOD",
              "PROPOSAL_STATUS_PASSED",
              "PROPOSAL_STATUS_REJECTED",
              "PROPOSAL_STATUS_FAILED"
            ]
          },
          "final_tally_result": {
            "type": "object",
            "properties": {
              "yes_count": {
                "type": "string",
                "description": "yes_count is the number of yes votes on a proposal."
              },
              "abstain_count": {
                "type": "string",
                "description": "abstain_count is the number of abstain votes on a proposal."
              },
              "no_count": {
                "type": "string",
                "description": "no_count is the number of no votes on a proposal."
              },
              "no_with_veto_count": {
                "type": "string",
                "description": "no_with_veto_count is the number of no with veto votes on a proposal."
              }
            },
            "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended."
          },
          "submit_time": {
            "type": "string",
            "description": "submit_time is the time of proposal submission.",
            "format": "date-time"
          },
          "deposit_end_time": {
            "type": "string",
            "description": "deposit_end_time is the end time for deposition.",
            "format": "date-time"
          },
          "total_deposit": {
            "type": "array",
            "description": "total_deposit is the total deposit on the proposal.",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            }
          },
          "voting_start_time": {
            "type": "string",
            "description": "voting_start_time is the starting time to vote on a proposal.",
            "format": "date-time"
          },
          "voting_end_time": {
            "type": "string",
            "description": "voting_end_time is the end time of voting on a proposal.",
            "format": "date-time"
          },
          "metadata": {
            "title": "metadata is any arbitrary metadata attached to the proposal.\nthe recommended format of the metadata is to be found here:\nhttps://docs.cosmos.network/v0.47/modules/gov#proposal-3",
            "type": "string"
          },
          "title": {
            "title": "title is the title of the proposal",
            "type": "string",
            "description": "Since: cosmos-sdk 0.47"
          },
          "summary": {
            "title": "summary is a short summary of the proposal",
            "type": "string",
            "description": "Since: cosmos-sdk 0.47"
          },
          "proposer": {
            "title": "proposer is the address of the proposal sumbitter",
            "type": "string",
            "description": "Since: cosmos-sdk 0.47"
          },
          "expedited": {
            "title": "expedited defines if the proposal is expedited",
            "type": "boolean",
            "description": "Since: cosmos-sdk 0.50"
          },
          "failed_reason": {
            "title": "failed_reason defines the reason why the proposal failed",
            "type": "string",
            "description": "Since: cosmos-sdk 0.50"
          }
        },
        "description": "Proposal defines the core field members of a governance proposal."
      },
      "cosmos.gov.v1.ProposalStatus": {
        "type": "string",
        "description": "ProposalStatus enumerates the valid statuses of a proposal.\n\n - PROPOSAL_STATUS_UNSPECIFIED: PROPOSAL_STATUS_UNSPECIFIED defines the default proposal status.\n - PROPOSAL_STATUS_DEPOSIT_PERIOD: PROPOSAL_STATUS_DEPOSIT_PERIOD defines a proposal status during the deposit\nperiod.\n - PROPOSAL_STATUS_VOTING_PERIOD: PROPOSAL_STATUS_VOTING_PERIOD defines a proposal status during the voting\nperiod.\n - PROPOSAL_STATUS_PASSED: PROPOSAL_STATUS_PASSED defines a proposal status of a proposal that has\npassed.\n - PROPOSAL_STATUS_REJECTED: PROPOSAL_STATUS_REJECTED defines a proposal status of a proposal that has\nbeen rejected.\n - PROPOSAL_STATUS_FAILED: PROPOSAL_STATUS_FAILED defines a proposal status of a proposal that has\nfailed.",
        "default": "PROPOSAL_STATUS_UNSPECIFIED",
        "enum": [
          "PROPOSAL_STATUS_UNSPECIFIED",
          "PROPOSAL_STATUS_DEPOSIT_PERIOD",
          "PROPOSAL_STATUS_VOTING_PERIOD",
          "PROPOSAL_STATUS_PASSED",
          "PROPOSAL_STATUS_REJECTED",
          "PROPOSAL_STATUS_FAILED"
        ]
      },
      "cosmos.gov.v1.QueryConstitutionResponse": {
        "title": "QueryConstitutionResponse is the response type for the Query/Constitution RPC method",
        "type": "object",
        "properties": {
          "constitution": {
            "type": "string"
          }
        }
      },
      "cosmos.gov.v1.QueryDepositResponse": {
        "type": "object",
        "properties": {
          "deposit": {
            "type": "object",
            "properties": {
              "proposal_id": {
                "type": "string",
                "description": "proposal_id defines the unique id of the proposal.",
                "format": "uint64"
              },
              "depositor": {
                "type": "string",
                "description": "depositor defines the deposit addresses from the proposals."
              },
              "amount": {
                "type": "array",
                "description": "amount to be deposited by depositor.",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              }
            },
            "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
          }
        },
        "description": "QueryDepositResponse is the response type for the Query/Deposit RPC method."
      },
      "cosmos.gov.v1.QueryDepositsResponse": {
        "type": "object",
        "properties": {
          "deposits": {
            "type": "array",
            "description": "deposits defines the requested deposits.",
            "items": {
              "type": "object",
              "properties": {
                "proposal_id": {
                  "type": "string",
                  "description": "proposal_id defines the unique id of the proposal.",
                  "format": "uint64"
                },
                "depositor": {
                  "type": "string",
                  "description": "depositor defines the deposit addresses from the proposals."
                },
                "amount": {
                  "type": "array",
                  "description": "amount to be deposited by depositor.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                  }
                }
              },
              "description": "Deposit defines an amount deposited by an account address to an active\nproposal."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryDepositsResponse is the response type for the Query/Deposits RPC method."
      },
      "cosmos.gov.v1.QueryParamsResponse": {
        "type": "object",
        "properties": {
          "voting_params": {
            "type": "object",
            "properties": {
              "voting_period": {
                "type": "string",
                "description": "Duration of the voting period."
              }
            },
            "description": "Deprecated: Prefer to use `params` instead.\nvoting_params defines the parameters related to voting."
          },
          "deposit_params": {
            "type": "object",
            "properties": {
              "min_deposit": {
                "type": "array",
                "description": "Minimum deposit for a proposal to enter voting period.",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "max_deposit_period": {
                "type": "string",
                "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
              }
            },
            "description": "Deprecated: Prefer to use `params` instead.\ndeposit_params defines the parameters related to deposit."
          },
          "tally_params": {
            "type": "object",
            "properties": {
              "quorum": {
                "type": "string",
                "description": "Minimum percentage of total stake needed to vote for a result to be\nconsidered valid."
              },
              "threshold": {
                "type": "string",
                "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
              },
              "veto_threshold": {
                "type": "string",
                "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\nvetoed. Default value: 1/3."
              }
            },
            "description": "Deprecated: Prefer to use `params` instead.\ntally_params defines the parameters related to tally."
          },
          "params": {
            "type": "object",
            "properties": {
              "min_deposit": {
                "type": "array",
                "description": "Minimum deposit for a proposal to enter voting period.",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "max_deposit_period": {
                "type": "string",
                "description": "Maximum period for Atom holders to deposit on a proposal. Initial value: 2\nmonths."
              },
              "voting_period": {
                "type": "string",
                "description": "Duration of the voting period."
              },
              "quorum": {
                "type": "string",
                "description": "Minimum percentage of total stake needed to vote for a result to be\n considered valid."
              },
              "threshold": {
                "type": "string",
                "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
              },
              "veto_threshold": {
                "type": "string",
                "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\n vetoed. Default value: 1/3."
              },
              "min_initial_deposit_ratio": {
                "type": "string",
                "description": "The ratio representing the proportion of the deposit value that must be paid at proposal submission."
              },
              "proposal_cancel_ratio": {
                "type": "string",
                "description": "The cancel ratio which will not be returned back to the depositors when a proposal is cancelled.\n\nSince: cosmos-sdk 0.50"
              },
              "proposal_cancel_dest": {
                "type": "string",
                "description": "The address which will receive (proposal_cancel_ratio * deposit) proposal deposits.\nIf empty, the (proposal_cancel_ratio * deposit) proposal deposits will be burned.\n\nSince: cosmos-sdk 0.50"
              },
              "expedited_voting_period": {
                "type": "string",
                "description": "Duration of the voting period of an expedited proposal.\n\nSince: cosmos-sdk 0.50"
              },
              "expedited_threshold": {
                "type": "string",
                "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.67.\n\nSince: cosmos-sdk 0.50"
              },
              "expedited_min_deposit": {
                "type": "array",
                "description": "Minimum expedited deposit for a proposal to enter voting period.",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "burn_vote_quorum": {
                "title": "burn deposits if a proposal does not meet quorum",
                "type": "boolean"
              },
              "burn_proposal_deposit_prevote": {
                "title": "burn deposits if the proposal does not enter voting period",
                "type": "boolean"
              },
              "burn_vote_veto": {
                "title": "burn deposits if quorum with vote type no_veto is met",
                "type": "boolean"
              }
            },
            "description": "params defines all the paramaters of x/gov module.\n\nSince: cosmos-sdk 0.47"
          }
        },
        "description": "QueryParamsResponse is the response type for the Query/Params RPC method."
      },
      "cosmos.gov.v1.QueryProposalResponse": {
        "type": "object",
        "properties": {
          "proposal": {
            "type": "object",
            "properties": {
              "id": {
                "type": "string",
                "description": "id defines the unique id of the proposal.",
                "format": "uint64"
              },
              "messages": {
                "type": "array",
                "description": "messages are the arbitrary messages to be executed if the proposal passes.",
                "items": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "byte"
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                }
              },
              "status": {
                "type": "string",
                "description": "status defines the proposal status.",
                "default": "PROPOSAL_STATUS_UNSPECIFIED",
                "enum": [
                  "PROPOSAL_STATUS_UNSPECIFIED",
                  "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                  "PROPOSAL_STATUS_VOTING_PERIOD",
                  "PROPOSAL_STATUS_PASSED",
                  "PROPOSAL_STATUS_REJECTED",
                  "PROPOSAL_STATUS_FAILED"
                ]
              },
              "final_tally_result": {
                "type": "object",
                "properties": {
                  "yes_count": {
                    "type": "string",
                    "description": "yes_count is the number of yes votes on a proposal."
                  },
                  "abstain_count": {
                    "type": "string",
                    "description": "abstain_count is the number of abstain votes on a proposal."
                  },
                  "no_count": {
                    "type": "string",
                    "description": "no_count is the number of no votes on a proposal."
                  },
                  "no_with_veto_count": {
                    "type": "string",
                    "description": "no_with_veto_count is the number of no with veto votes on a proposal."
                  }
                },
                "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended."
              },
              "submit_time": {
                "type": "string",
                "description": "submit_time is the time of proposal submission.",
                "format": "date-time"
              },
              "deposit_end_time": {
                "type": "string",
                "description": "deposit_end_time is the end time for deposition.",
                "format": "date-time"
              },
              "total_deposit": {
                "type": "array",
                "description": "total_deposit is the total deposit on the proposal.",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "voting_start_time": {
                "type": "string",
                "description": "voting_start_time is the starting time to vote on a proposal.",
                "format": "date-time"
              },
              "voting_end_time": {
                "type": "string",
                "description": "voting_end_time is the end time of voting on a proposal.",
                "format": "date-time"
              },
              "metadata": {
                "title": "metadata is any arbitrary metadata attached to the proposal.\nthe recommended format of the metadata is to be found here:\nhttps://docs.cosmos.network/v0.47/modules/gov#proposal-3",
                "type": "string"
              },
              "title": {
                "title": "title is the title of the proposal",
                "type": "string",
                "description": "Since: cosmos-sdk 0.47"
              },
              "summary": {
                "title": "summary is a short summary of the proposal",
                "type": "string",
                "description": "Since: cosmos-sdk 0.47"
              },
              "proposer": {
                "title": "proposer is the address of the proposal sumbitter",
                "type": "string",
                "description": "Since: cosmos-sdk 0.47"
              },
              "expedited": {
                "title": "expedited defines if the proposal is expedited",
                "type": "boolean",
                "description": "Since: cosmos-sdk 0.50"
              },
              "failed_reason": {
                "title": "failed_reason defines the reason why the proposal failed",
                "type": "string",
                "description": "Since: cosmos-sdk 0.50"
              }
            },
            "description": "Proposal defines the core field members of a governance proposal."
          }
        },
        "description": "QueryProposalResponse is the response type for the Query/Proposal RPC method."
      },
      "cosmos.gov.v1.QueryProposalsResponse": {
        "type": "object",
        "properties": {
          "proposals": {
            "type": "array",
            "description": "proposals defines all the requested governance proposals.",
            "items": {
              "type": "object",
              "properties": {
                "id": {
                  "type": "string",
                  "description": "id defines the unique id of the proposal.",
                  "format": "uint64"
                },
                "messages": {
                  "type": "array",
                  "description": "messages are the arbitrary messages to be executed if the proposal passes.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type_url": {
                        "type": "string",
                        "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                      },
                      "value": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "description": "Must be a valid serialized protocol buffer of the above specified type.",
                        "format": "byte"
                      }
                    },
                    "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                  }
                },
                "status": {
                  "type": "string",
                  "description": "status defines the proposal status.",
                  "default": "PROPOSAL_STATUS_UNSPECIFIED",
                  "enum": [
                    "PROPOSAL_STATUS_UNSPECIFIED",
                    "PROPOSAL_STATUS_DEPOSIT_PERIOD",
                    "PROPOSAL_STATUS_VOTING_PERIOD",
                    "PROPOSAL_STATUS_PASSED",
                    "PROPOSAL_STATUS_REJECTED",
                    "PROPOSAL_STATUS_FAILED"
                  ]
                },
                "final_tally_result": {
                  "type": "object",
                  "properties": {
                    "yes_count": {
                      "type": "string",
                      "description": "yes_count is the number of yes votes on a proposal."
                    },
                    "abstain_count": {
                      "type": "string",
                      "description": "abstain_count is the number of abstain votes on a proposal."
                    },
                    "no_count": {
                      "type": "string",
                      "description": "no_count is the number of no votes on a proposal."
                    },
                    "no_with_veto_count": {
                      "type": "string",
                      "description": "no_with_veto_count is the number of no with veto votes on a proposal."
                    }
                  },
                  "description": "final_tally_result is the final tally result of the proposal. When\nquerying a proposal via gRPC, this field is not populated until the\nproposal's voting period has ended."
                },
                "submit_time": {
                  "type": "string",
                  "description": "submit_time is the time of proposal submission.",
                  "format": "date-time"
                },
                "deposit_end_time": {
                  "type": "string",
                  "description": "deposit_end_time is the end time for deposition.",
                  "format": "date-time"
                },
                "total_deposit": {
                  "type": "array",
                  "description": "total_deposit is the total deposit on the proposal.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "denom": {
                        "type": "string"
                      },
                      "amount": {
                        "type": "string"
                      }
                    },
                    "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                  }
                },
                "voting_start_time": {
                  "type": "string",
                  "description": "voting_start_time is the starting time to vote on a proposal.",
                  "format": "date-time"
                },
                "voting_end_time": {
                  "type": "string",
                  "description": "voting_end_time is the end time of voting on a proposal.",
                  "format": "date-time"
                },
                "metadata": {
                  "title": "metadata is any arbitrary metadata attached to the proposal.\nthe recommended format of the metadata is to be found here:\nhttps://docs.cosmos.network/v0.47/modules/gov#proposal-3",
                  "type": "string"
                },
                "title": {
                  "title": "title is the title of the proposal",
                  "type": "string",
                  "description": "Since: cosmos-sdk 0.47"
                },
                "summary": {
                  "title": "summary is a short summary of the proposal",
                  "type": "string",
                  "description": "Since: cosmos-sdk 0.47"
                },
                "proposer": {
                  "title": "proposer is the address of the proposal sumbitter",
                  "type": "string",
                  "description": "Since: cosmos-sdk 0.47"
                },
                "expedited": {
                  "title": "expedited defines if the proposal is expedited",
                  "type": "boolean",
                  "description": "Since: cosmos-sdk 0.50"
                },
                "failed_reason": {
                  "title": "failed_reason defines the reason why the proposal failed",
                  "type": "string",
                  "description": "Since: cosmos-sdk 0.50"
                }
              },
              "description": "Proposal defines the core field members of a governance proposal."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryProposalsResponse is the response type for the Query/Proposals RPC\nmethod."
      },
      "cosmos.gov.v1.QueryTallyResultResponse": {
        "type": "object",
        "properties": {
          "tally": {
            "type": "object",
            "properties": {
              "yes_count": {
                "type": "string",
                "description": "yes_count is the number of yes votes on a proposal."
              },
              "abstain_count": {
                "type": "string",
                "description": "abstain_count is the number of abstain votes on a proposal."
              },
              "no_count": {
                "type": "string",
                "description": "no_count is the number of no votes on a proposal."
              },
              "no_with_veto_count": {
                "type": "string",
                "description": "no_with_veto_count is the number of no with veto votes on a proposal."
              }
            },
            "description": "tally defines the requested tally."
          }
        },
        "description": "QueryTallyResultResponse is the response type for the Query/Tally RPC method."
      },
      "cosmos.gov.v1.QueryVoteResponse": {
        "type": "object",
        "properties": {
          "vote": {
            "type": "object",
            "properties": {
              "proposal_id": {
                "type": "string",
                "description": "proposal_id defines the unique id of the proposal.",
                "format": "uint64"
              },
              "voter": {
                "type": "string",
                "description": "voter is the voter address of the proposal."
              },
              "options": {
                "type": "array",
                "description": "options is the weighted vote options.",
                "items": {
                  "type": "object",
                  "properties": {
                    "option": {
                      "type": "string",
                      "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                      "default": "VOTE_OPTION_UNSPECIFIED",
                      "enum": [
                        "VOTE_OPTION_UNSPECIFIED",
                        "VOTE_OPTION_YES",
                        "VOTE_OPTION_ABSTAIN",
                        "VOTE_OPTION_NO",
                        "VOTE_OPTION_NO_WITH_VETO"
                      ]
                    },
                    "weight": {
                      "type": "string",
                      "description": "weight is the vote weight associated with the vote option."
                    }
                  },
                  "description": "WeightedVoteOption defines a unit of vote for vote split."
                }
              },
              "metadata": {
                "title": "metadata is any arbitrary metadata attached to the vote.\nthe recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/gov#vote-5",
                "type": "string"
              }
            },
            "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
          }
        },
        "description": "QueryVoteResponse is the response type for the Query/Vote RPC method."
      },
      "cosmos.gov.v1.QueryVotesResponse": {
        "type": "object",
        "properties": {
          "votes": {
            "type": "array",
            "description": "votes defines the queried votes.",
            "items": {
              "type": "object",
              "properties": {
                "proposal_id": {
                  "type": "string",
                  "description": "proposal_id defines the unique id of the proposal.",
                  "format": "uint64"
                },
                "voter": {
                  "type": "string",
                  "description": "voter is the voter address of the proposal."
                },
                "options": {
                  "type": "array",
                  "description": "options is the weighted vote options.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "option": {
                        "type": "string",
                        "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                        "default": "VOTE_OPTION_UNSPECIFIED",
                        "enum": [
                          "VOTE_OPTION_UNSPECIFIED",
                          "VOTE_OPTION_YES",
                          "VOTE_OPTION_ABSTAIN",
                          "VOTE_OPTION_NO",
                          "VOTE_OPTION_NO_WITH_VETO"
                        ]
                      },
                      "weight": {
                        "type": "string",
                        "description": "weight is the vote weight associated with the vote option."
                      }
                    },
                    "description": "WeightedVoteOption defines a unit of vote for vote split."
                  }
                },
                "metadata": {
                  "title": "metadata is any arbitrary metadata attached to the vote.\nthe recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/gov#vote-5",
                  "type": "string"
                }
              },
              "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryVotesResponse is the response type for the Query/Votes RPC method."
      },
      "cosmos.gov.v1.TallyParams": {
        "type": "object",
        "properties": {
          "quorum": {
            "type": "string",
            "description": "Minimum percentage of total stake needed to vote for a result to be\nconsidered valid."
          },
          "threshold": {
            "type": "string",
            "description": "Minimum proportion of Yes votes for proposal to pass. Default value: 0.5."
          },
          "veto_threshold": {
            "type": "string",
            "description": "Minimum value of Veto votes to Total votes ratio for proposal to be\nvetoed. Default value: 1/3."
          }
        },
        "description": "TallyParams defines the params for tallying votes on governance proposals."
      },
      "cosmos.gov.v1.TallyResult": {
        "type": "object",
        "properties": {
          "yes_count": {
            "type": "string",
            "description": "yes_count is the number of yes votes on a proposal."
          },
          "abstain_count": {
            "type": "string",
            "description": "abstain_count is the number of abstain votes on a proposal."
          },
          "no_count": {
            "type": "string",
            "description": "no_count is the number of no votes on a proposal."
          },
          "no_with_veto_count": {
            "type": "string",
            "description": "no_with_veto_count is the number of no with veto votes on a proposal."
          }
        },
        "description": "TallyResult defines a standard tally for a governance proposal."
      },
      "cosmos.gov.v1.Vote": {
        "type": "object",
        "properties": {
          "proposal_id": {
            "type": "string",
            "description": "proposal_id defines the unique id of the proposal.",
            "format": "uint64"
          },
          "voter": {
            "type": "string",
            "description": "voter is the voter address of the proposal."
          },
          "options": {
            "type": "array",
            "description": "options is the weighted vote options.",
            "items": {
              "type": "object",
              "properties": {
                "option": {
                  "type": "string",
                  "description": "option defines the valid vote options, it must not contain duplicate vote options.",
                  "default": "VOTE_OPTION_UNSPECIFIED",
                  "enum": [
                    "VOTE_OPTION_UNSPECIFIED",
                    "VOTE_OPTION_YES",
                    "VOTE_OPTION_ABSTAIN",
                    "VOTE_OPTION_NO",
                    "VOTE_OPTION_NO_WITH_VETO"
                  ]
                },
                "weight": {
                  "type": "string",
                  "description": "weight is the vote weight associated with the vote option."
                }
              },
              "description": "WeightedVoteOption defines a unit of vote for vote split."
            }
          },
          "metadata": {
            "title": "metadata is any arbitrary metadata attached to the vote.\nthe recommended format of the metadata is to be found here: https://docs.cosmos.network/v0.47/modules/gov#vote-5",
            "type": "string"
          }
        },
        "description": "Vote defines a vote on a governance proposal.\nA Vote consists of a proposal ID, the voter, and the vote option."
      },
      "cosmos.gov.v1.VoteOption": {
        "type": "string",
        "description": "VoteOption enumerates the valid vote options for a given governance proposal.\n\n - VOTE_OPTION_UNSPECIFIED: VOTE_OPTION_UNSPECIFIED defines a no-op vote option.\n - VOTE_OPTION_YES: VOTE_OPTION_YES defines a yes vote option.\n - VOTE_OPTION_ABSTAIN: VOTE_OPTION_ABSTAIN defines an abstain vote option.\n - VOTE_OPTION_NO: VOTE_OPTION_NO defines a no vote option.\n - VOTE_OPTION_NO_WITH_VETO: VOTE_OPTION_NO_WITH_VETO defines a no with veto vote option.",
        "default": "VOTE_OPTION_UNSPECIFIED",
        "enum": [
          "VOTE_OPTION_UNSPECIFIED",
          "VOTE_OPTION_YES",
          "VOTE_OPTION_ABSTAIN",
          "VOTE_OPTION_NO",
          "VOTE_OPTION_NO_WITH_VETO"
        ]
      },
      "cosmos.gov.v1.VotingParams": {
        "type": "object",
        "properties": {
          "voting_period": {
            "type": "string",
            "description": "Duration of the voting period."
          }
        },
        "description": "VotingParams defines the params for voting on governance proposals."
      },
      "cosmos.gov.v1.WeightedVoteOption": {
        "type": "object",
        "properties": {
          "option": {
            "type": "string",
            "description": "option defines the valid vote options, it must not contain duplicate vote options.",
            "default": "VOTE_OPTION_UNSPECIFIED",
            "enum": [
              "VOTE_OPTION_UNSPECIFIED",
              "VOTE_OPTION_YES",
              "VOTE_OPTION_ABSTAIN",
              "VOTE_OPTION_NO",
              "VOTE_OPTION_NO_WITH_VETO"
            ]
          },
          "weight": {
            "type": "string",
            "description": "weight is the vote weight associated with the vote option."
          }
        },
        "description": "WeightedVoteOption defines a unit of vote for vote split."
      },
      "cosmos.slashing.v1beta1.Params": {
        "type": "object",
        "properties": {
          "signed_blocks_window": {
            "type": "string",
            "format": "int64"
          },
          "min_signed_per_window": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "downtime_jail_duration": {
            "type": "string"
          },
          "slash_fraction_double_sign": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "slash_fraction_downtime": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          }
        },
        "description": "Params represents the parameters used for by the slashing module."
      },
      "cosmos.slashing.v1beta1.QueryParamsResponse": {
        "title": "QueryParamsResponse is the response type for the Query/Params RPC method",
        "type": "object",
        "properties": {
          "params": {
            "type": "object",
            "properties": {
              "signed_blocks_window": {
                "type": "string",
                "format": "int64"
              },
              "min_signed_per_window": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "downtime_jail_duration": {
                "type": "string"
              },
              "slash_fraction_double_sign": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "slash_fraction_downtime": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              }
            },
            "description": "Params represents the parameters used for by the slashing module."
          }
        }
      },
      "cosmos.slashing.v1beta1.QuerySigningInfoResponse": {
        "title": "QuerySigningInfoResponse is the response type for the Query/SigningInfo RPC\nmethod",
        "type": "object",
        "properties": {
          "val_signing_info": {
            "title": "val_signing_info is the signing info of requested val cons address",
            "type": "object",
            "properties": {
              "address": {
                "type": "string"
              },
              "start_height": {
                "title": "Height at which validator was first a candidate OR was un-jailed",
                "type": "string",
                "format": "int64"
              },
              "index_offset": {
                "type": "string",
                "description": "Index which is incremented every time a validator is bonded in a block and\n_may_ have signed a pre-commit or not. This in conjunction with the\nsigned_blocks_window param determines the index in the missed block bitmap.",
                "format": "int64"
              },
              "jailed_until": {
                "type": "string",
                "description": "Timestamp until which the validator is jailed due to liveness downtime.",
                "format": "date-time"
              },
              "tombstoned": {
                "type": "boolean",
                "description": "Whether or not a validator has been tombstoned (killed out of validator\nset). It is set once the validator commits an equivocation or for any other\nconfigured misbehavior."
              },
              "missed_blocks_counter": {
                "type": "string",
                "description": "A counter of missed (unsigned) blocks. It is used to avoid unnecessary\nreads in the missed block bitmap.",
                "format": "int64"
              }
            },
            "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity."
          }
        }
      },
      "cosmos.slashing.v1beta1.QuerySigningInfosResponse": {
        "title": "QuerySigningInfosResponse is the response type for the Query/SigningInfos RPC\nmethod",
        "type": "object",
        "properties": {
          "info": {
            "title": "info is the signing info of all validators",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string"
                },
                "start_height": {
                  "title": "Height at which validator was first a candidate OR was un-jailed",
                  "type": "string",
                  "format": "int64"
                },
                "index_offset": {
                  "type": "string",
                  "description": "Index which is incremented every time a validator is bonded in a block and\n_may_ have signed a pre-commit or not. This in conjunction with the\nsigned_blocks_window param determines the index in the missed block bitmap.",
                  "format": "int64"
                },
                "jailed_until": {
                  "type": "string",
                  "description": "Timestamp until which the validator is jailed due to liveness downtime.",
                  "format": "date-time"
                },
                "tombstoned": {
                  "type": "boolean",
                  "description": "Whether or not a validator has been tombstoned (killed out of validator\nset). It is set once the validator commits an equivocation or for any other\nconfigured misbehavior."
                },
                "missed_blocks_counter": {
                  "type": "string",
                  "description": "A counter of missed (unsigned) blocks. It is used to avoid unnecessary\nreads in the missed block bitmap.",
                  "format": "int64"
                }
              },
              "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "PageResponse is to be embedded in gRPC response messages where the\ncorresponding request message has used PageRequest.\n\n message SomeResponse {\n         repeated Bar results = 1;\n         PageResponse page = 2;\n }"
          }
        }
      },
      "cosmos.slashing.v1beta1.ValidatorSigningInfo": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string"
          },
          "start_height": {
            "title": "Height at which validator was first a candidate OR was un-jailed",
            "type": "string",
            "format": "int64"
          },
          "index_offset": {
            "type": "string",
            "description": "Index which is incremented every time a validator is bonded in a block and\n_may_ have signed a pre-commit or not. This in conjunction with the\nsigned_blocks_window param determines the index in the missed block bitmap.",
            "format": "int64"
          },
          "jailed_until": {
            "type": "string",
            "description": "Timestamp until which the validator is jailed due to liveness downtime.",
            "format": "date-time"
          },
          "tombstoned": {
            "type": "boolean",
            "description": "Whether or not a validator has been tombstoned (killed out of validator\nset). It is set once the validator commits an equivocation or for any other\nconfigured misbehavior."
          },
          "missed_blocks_counter": {
            "type": "string",
            "description": "A counter of missed (unsigned) blocks. It is used to avoid unnecessary\nreads in the missed block bitmap.",
            "format": "int64"
          }
        },
        "description": "ValidatorSigningInfo defines a validator's signing info for monitoring their\nliveness activity."
      },
      "cosmos.staking.v1beta1.BondStatus": {
        "type": "string",
        "description": "BondStatus is the status of a validator.\n\n - BOND_STATUS_UNSPECIFIED: UNSPECIFIED defines an invalid validator status.\n - BOND_STATUS_UNBONDED: UNBONDED defines a validator that is not bonded.\n - BOND_STATUS_UNBONDING: UNBONDING defines a validator that is unbonding.\n - BOND_STATUS_BONDED: BONDED defines a validator that is bonded.",
        "default": "BOND_STATUS_UNSPECIFIED",
        "enum": [
          "BOND_STATUS_UNSPECIFIED",
          "BOND_STATUS_UNBONDED",
          "BOND_STATUS_UNBONDING",
          "BOND_STATUS_BONDED"
        ]
      },
      "cosmos.staking.v1beta1.Commission": {
        "type": "object",
        "properties": {
          "commission_rates": {
            "type": "object",
            "properties": {
              "rate": {
                "type": "string",
                "description": "rate is the commission rate charged to delegators, as a fraction."
              },
              "max_rate": {
                "type": "string",
                "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
              },
              "max_change_rate": {
                "type": "string",
                "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
              }
            },
            "description": "commission_rates defines the initial commission rates to be used for creating a validator."
          },
          "update_time": {
            "type": "string",
            "description": "update_time is the last time the commission rate was changed.",
            "format": "date-time"
          }
        },
        "description": "Commission defines commission parameters for a given validator."
      },
      "cosmos.staking.v1beta1.CommissionRates": {
        "type": "object",
        "properties": {
          "rate": {
            "type": "string",
            "description": "rate is the commission rate charged to delegators, as a fraction."
          },
          "max_rate": {
            "type": "string",
            "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
          },
          "max_change_rate": {
            "type": "string",
            "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
          }
        },
        "description": "CommissionRates defines the initial commission rates to be used for creating\na validator."
      },
      "cosmos.staking.v1beta1.Delegation": {
        "type": "object",
        "properties": {
          "delegator_address": {
            "type": "string",
            "description": "delegator_address is the encoded address of the delegator."
          },
          "validator_address": {
            "type": "string",
            "description": "validator_address is the encoded address of the validator."
          },
          "shares": {
            "type": "string",
            "description": "shares define the delegation shares received."
          }
        },
        "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
      },
      "cosmos.staking.v1beta1.DelegationResponse": {
        "type": "object",
        "properties": {
          "delegation": {
            "type": "object",
            "properties": {
              "delegator_address": {
                "type": "string",
                "description": "delegator_address is the encoded address of the delegator."
              },
              "validator_address": {
                "type": "string",
                "description": "validator_address is the encoded address of the validator."
              },
              "shares": {
                "type": "string",
                "description": "shares define the delegation shares received."
              }
            },
            "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
          },
          "balance": {
            "type": "object",
            "properties": {
              "denom": {
                "type": "string"
              },
              "amount": {
                "type": "string"
              }
            },
            "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
          }
        },
        "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses."
      },
      "cosmos.staking.v1beta1.Description": {
        "type": "object",
        "properties": {
          "moniker": {
            "type": "string",
            "description": "moniker defines a human-readable name for the validator."
          },
          "identity": {
            "type": "string",
            "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
          },
          "website": {
            "type": "string",
            "description": "website defines an optional website link."
          },
          "security_contact": {
            "type": "string",
            "description": "security_contact defines an optional email for security contact."
          },
          "details": {
            "type": "string",
            "description": "details define other optional details."
          }
        },
        "description": "Description defines a validator description."
      },
      "cosmos.staking.v1beta1.HistoricalInfo": {
        "type": "object",
        "properties": {
          "header": {
            "type": "object",
            "properties": {
              "version": {
                "title": "basic block info",
                "type": "object",
                "properties": {
                  "block": {
                    "type": "string",
                    "format": "uint64"
                  },
                  "app": {
                    "type": "string",
                    "format": "uint64"
                  }
                },
                "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
              },
              "chain_id": {
                "type": "string"
              },
              "height": {
                "type": "string",
                "format": "int64"
              },
              "time": {
                "type": "string",
                "format": "date-time"
              },
              "last_block_id": {
                "title": "prev block info",
                "type": "object",
                "properties": {
                  "hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "part_set_header": {
                    "title": "PartsetHeader",
                    "type": "object",
                    "properties": {
                      "total": {
                        "type": "integer",
                        "format": "int64"
                      },
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              },
              "last_commit_hash": {
                "title": "hashes of block data",
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "data_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "validators_hash": {
                "title": "hashes from the app output from the prev block",
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "next_validators_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "consensus_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "app_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "last_results_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "evidence_hash": {
                "title": "consensus info",
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "proposer_address": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              }
            },
            "description": "Header defines the structure of a block header."
          },
          "valset": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "operator_address": {
                  "type": "string",
                  "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
                },
                "consensus_pubkey": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "byte"
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                },
                "jailed": {
                  "type": "boolean",
                  "description": "jailed defined whether the validator has been jailed from bonded status or not."
                },
                "status": {
                  "type": "string",
                  "description": "status is the validator status (bonded/unbonding/unbonded).",
                  "default": "BOND_STATUS_UNSPECIFIED",
                  "enum": [
                    "BOND_STATUS_UNSPECIFIED",
                    "BOND_STATUS_UNBONDED",
                    "BOND_STATUS_UNBONDING",
                    "BOND_STATUS_BONDED"
                  ]
                },
                "tokens": {
                  "type": "string",
                  "description": "tokens define the delegated tokens (incl. self-delegation)."
                },
                "delegator_shares": {
                  "type": "string",
                  "description": "delegator_shares defines total shares issued to a validator's delegators."
                },
                "description": {
                  "type": "object",
                  "properties": {
                    "moniker": {
                      "type": "string",
                      "description": "moniker defines a human-readable name for the validator."
                    },
                    "identity": {
                      "type": "string",
                      "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                    },
                    "website": {
                      "type": "string",
                      "description": "website defines an optional website link."
                    },
                    "security_contact": {
                      "type": "string",
                      "description": "security_contact defines an optional email for security contact."
                    },
                    "details": {
                      "type": "string",
                      "description": "details define other optional details."
                    }
                  },
                  "description": "description defines the description terms for the validator."
                },
                "unbonding_height": {
                  "type": "string",
                  "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                  "format": "int64"
                },
                "unbonding_time": {
                  "type": "string",
                  "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                  "format": "date-time"
                },
                "commission": {
                  "type": "object",
                  "properties": {
                    "commission_rates": {
                      "type": "object",
                      "properties": {
                        "rate": {
                          "type": "string",
                          "description": "rate is the commission rate charged to delegators, as a fraction."
                        },
                        "max_rate": {
                          "type": "string",
                          "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                        },
                        "max_change_rate": {
                          "type": "string",
                          "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                        }
                      },
                      "description": "commission_rates defines the initial commission rates to be used for creating a validator."
                    },
                    "update_time": {
                      "type": "string",
                      "description": "update_time is the last time the commission rate was changed.",
                      "format": "date-time"
                    }
                  },
                  "description": "commission defines the commission parameters."
                },
                "min_self_delegation": {
                  "type": "string",
                  "description": "min_self_delegation is the validator's self declared minimum self delegation.\n\nSince: cosmos-sdk 0.46"
                },
                "unbonding_on_hold_ref_count": {
                  "title": "strictly positive if this validator's unbonding has been stopped by external modules",
                  "type": "string",
                  "format": "int64"
                },
                "unbonding_ids": {
                  "title": "list of unbonding ids, each uniquely identifing an unbonding of this validator",
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uint64"
                  }
                }
              },
              "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
            }
          }
        },
        "description": "HistoricalInfo contains header and validator information for a given block.\nIt is stored as part of staking module's state, which persists the `n` most\nrecent HistoricalInfo\n(`n` is set by the staking module's `historical_entries` parameter)."
      },
      "cosmos.staking.v1beta1.Params": {
        "type": "object",
        "properties": {
          "unbonding_time": {
            "type": "string",
            "description": "unbonding_time is the time duration of unbonding."
          },
          "max_validators": {
            "type": "integer",
            "description": "max_validators is the maximum number of validators.",
            "format": "int64"
          },
          "max_entries": {
            "type": "integer",
            "description": "max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).",
            "format": "int64"
          },
          "historical_entries": {
            "type": "integer",
            "description": "historical_entries is the number of historical entries to persist.",
            "format": "int64"
          },
          "bond_denom": {
            "type": "string",
            "description": "bond_denom defines the bondable coin denomination."
          },
          "min_commission_rate": {
            "title": "min_commission_rate is the chain-wide minimum commission rate that a validator can charge their delegators",
            "type": "string"
          }
        },
        "description": "Params defines the parameters for the x/staking module."
      },
      "cosmos.staking.v1beta1.Pool": {
        "type": "object",
        "properties": {
          "not_bonded_tokens": {
            "type": "string"
          },
          "bonded_tokens": {
            "type": "string"
          }
        },
        "description": "Pool is used for tracking bonded and not-bonded token supply of the bond\ndenomination."
      },
      "cosmos.staking.v1beta1.QueryDelegationResponse": {
        "type": "object",
        "properties": {
          "delegation_response": {
            "type": "object",
            "properties": {
              "delegation": {
                "type": "object",
                "properties": {
                  "delegator_address": {
                    "type": "string",
                    "description": "delegator_address is the encoded address of the delegator."
                  },
                  "validator_address": {
                    "type": "string",
                    "description": "validator_address is the encoded address of the validator."
                  },
                  "shares": {
                    "type": "string",
                    "description": "shares define the delegation shares received."
                  }
                },
                "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
              },
              "balance": {
                "type": "object",
                "properties": {
                  "denom": {
                    "type": "string"
                  },
                  "amount": {
                    "type": "string"
                  }
                },
                "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
              }
            },
            "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses."
          }
        },
        "description": "QueryDelegationResponse is response type for the Query/Delegation RPC method."
      },
      "cosmos.staking.v1beta1.QueryDelegatorDelegationsResponse": {
        "type": "object",
        "properties": {
          "delegation_responses": {
            "type": "array",
            "description": "delegation_responses defines all the delegations' info of a delegator.",
            "items": {
              "type": "object",
              "properties": {
                "delegation": {
                  "type": "object",
                  "properties": {
                    "delegator_address": {
                      "type": "string",
                      "description": "delegator_address is the encoded address of the delegator."
                    },
                    "validator_address": {
                      "type": "string",
                      "description": "validator_address is the encoded address of the validator."
                    },
                    "shares": {
                      "type": "string",
                      "description": "shares define the delegation shares received."
                    }
                  },
                  "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
                },
                "balance": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryDelegatorDelegationsResponse is response type for the\nQuery/DelegatorDelegations RPC method."
      },
      "cosmos.staking.v1beta1.QueryDelegatorUnbondingDelegationsResponse": {
        "type": "object",
        "properties": {
          "unbonding_responses": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "delegator_address": {
                  "type": "string",
                  "description": "delegator_address is the encoded address of the delegator."
                },
                "validator_address": {
                  "type": "string",
                  "description": "validator_address is the encoded address of the validator."
                },
                "entries": {
                  "type": "array",
                  "description": "entries are the unbonding delegation entries.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "creation_height": {
                        "type": "string",
                        "description": "creation_height is the height which the unbonding took place.",
                        "format": "int64"
                      },
                      "completion_time": {
                        "type": "string",
                        "description": "completion_time is the unix time for unbonding completion.",
                        "format": "date-time"
                      },
                      "initial_balance": {
                        "type": "string",
                        "description": "initial_balance defines the tokens initially scheduled to receive at completion."
                      },
                      "balance": {
                        "type": "string",
                        "description": "balance defines the tokens to receive at completion."
                      },
                      "unbonding_id": {
                        "title": "Incrementing id that uniquely identifies this entry",
                        "type": "string",
                        "format": "uint64"
                      },
                      "unbonding_on_hold_ref_count": {
                        "title": "Strictly positive if this entry's unbonding has been stopped by external modules",
                        "type": "string",
                        "format": "int64"
                      }
                    },
                    "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
                  }
                }
              },
              "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryUnbondingDelegatorDelegationsResponse is response type for the\nQuery/UnbondingDelegatorDelegations RPC method."
      },
      "cosmos.staking.v1beta1.QueryDelegatorValidatorResponse": {
        "type": "object",
        "properties": {
          "validator": {
            "type": "object",
            "properties": {
              "operator_address": {
                "type": "string",
                "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
              },
              "consensus_pubkey": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                    "format": "byte"
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "jailed": {
                "type": "boolean",
                "description": "jailed defined whether the validator has been jailed from bonded status or not."
              },
              "status": {
                "type": "string",
                "description": "status is the validator status (bonded/unbonding/unbonded).",
                "default": "BOND_STATUS_UNSPECIFIED",
                "enum": [
                  "BOND_STATUS_UNSPECIFIED",
                  "BOND_STATUS_UNBONDED",
                  "BOND_STATUS_UNBONDING",
                  "BOND_STATUS_BONDED"
                ]
              },
              "tokens": {
                "type": "string",
                "description": "tokens define the delegated tokens (incl. self-delegation)."
              },
              "delegator_shares": {
                "type": "string",
                "description": "delegator_shares defines total shares issued to a validator's delegators."
              },
              "description": {
                "type": "object",
                "properties": {
                  "moniker": {
                    "type": "string",
                    "description": "moniker defines a human-readable name for the validator."
                  },
                  "identity": {
                    "type": "string",
                    "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                  },
                  "website": {
                    "type": "string",
                    "description": "website defines an optional website link."
                  },
                  "security_contact": {
                    "type": "string",
                    "description": "security_contact defines an optional email for security contact."
                  },
                  "details": {
                    "type": "string",
                    "description": "details define other optional details."
                  }
                },
                "description": "description defines the description terms for the validator."
              },
              "unbonding_height": {
                "type": "string",
                "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                "format": "int64"
              },
              "unbonding_time": {
                "type": "string",
                "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                "format": "date-time"
              },
              "commission": {
                "type": "object",
                "properties": {
                  "commission_rates": {
                    "type": "object",
                    "properties": {
                      "rate": {
                        "type": "string",
                        "description": "rate is the commission rate charged to delegators, as a fraction."
                      },
                      "max_rate": {
                        "type": "string",
                        "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                      },
                      "max_change_rate": {
                        "type": "string",
                        "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                      }
                    },
                    "description": "commission_rates defines the initial commission rates to be used for creating a validator."
                  },
                  "update_time": {
                    "type": "string",
                    "description": "update_time is the last time the commission rate was changed.",
                    "format": "date-time"
                  }
                },
                "description": "commission defines the commission parameters."
              },
              "min_self_delegation": {
                "type": "string",
                "description": "min_self_delegation is the validator's self declared minimum self delegation.\n\nSince: cosmos-sdk 0.46"
              },
              "unbonding_on_hold_ref_count": {
                "title": "strictly positive if this validator's unbonding has been stopped by external modules",
                "type": "string",
                "format": "int64"
              },
              "unbonding_ids": {
                "title": "list of unbonding ids, each uniquely identifing an unbonding of this validator",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uint64"
                }
              }
            },
            "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
          }
        },
        "description": "QueryDelegatorValidatorResponse response type for the\nQuery/DelegatorValidator RPC method."
      },
      "cosmos.staking.v1beta1.QueryDelegatorValidatorsResponse": {
        "type": "object",
        "properties": {
          "validators": {
            "type": "array",
            "description": "validators defines the validators' info of a delegator.",
            "items": {
              "type": "object",
              "properties": {
                "operator_address": {
                  "type": "string",
                  "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
                },
                "consensus_pubkey": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "byte"
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                },
                "jailed": {
                  "type": "boolean",
                  "description": "jailed defined whether the validator has been jailed from bonded status or not."
                },
                "status": {
                  "type": "string",
                  "description": "status is the validator status (bonded/unbonding/unbonded).",
                  "default": "BOND_STATUS_UNSPECIFIED",
                  "enum": [
                    "BOND_STATUS_UNSPECIFIED",
                    "BOND_STATUS_UNBONDED",
                    "BOND_STATUS_UNBONDING",
                    "BOND_STATUS_BONDED"
                  ]
                },
                "tokens": {
                  "type": "string",
                  "description": "tokens define the delegated tokens (incl. self-delegation)."
                },
                "delegator_shares": {
                  "type": "string",
                  "description": "delegator_shares defines total shares issued to a validator's delegators."
                },
                "description": {
                  "type": "object",
                  "properties": {
                    "moniker": {
                      "type": "string",
                      "description": "moniker defines a human-readable name for the validator."
                    },
                    "identity": {
                      "type": "string",
                      "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                    },
                    "website": {
                      "type": "string",
                      "description": "website defines an optional website link."
                    },
                    "security_contact": {
                      "type": "string",
                      "description": "security_contact defines an optional email for security contact."
                    },
                    "details": {
                      "type": "string",
                      "description": "details define other optional details."
                    }
                  },
                  "description": "description defines the description terms for the validator."
                },
                "unbonding_height": {
                  "type": "string",
                  "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                  "format": "int64"
                },
                "unbonding_time": {
                  "type": "string",
                  "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                  "format": "date-time"
                },
                "commission": {
                  "type": "object",
                  "properties": {
                    "commission_rates": {
                      "type": "object",
                      "properties": {
                        "rate": {
                          "type": "string",
                          "description": "rate is the commission rate charged to delegators, as a fraction."
                        },
                        "max_rate": {
                          "type": "string",
                          "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                        },
                        "max_change_rate": {
                          "type": "string",
                          "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                        }
                      },
                      "description": "commission_rates defines the initial commission rates to be used for creating a validator."
                    },
                    "update_time": {
                      "type": "string",
                      "description": "update_time is the last time the commission rate was changed.",
                      "format": "date-time"
                    }
                  },
                  "description": "commission defines the commission parameters."
                },
                "min_self_delegation": {
                  "type": "string",
                  "description": "min_self_delegation is the validator's self declared minimum self delegation.\n\nSince: cosmos-sdk 0.46"
                },
                "unbonding_on_hold_ref_count": {
                  "title": "strictly positive if this validator's unbonding has been stopped by external modules",
                  "type": "string",
                  "format": "int64"
                },
                "unbonding_ids": {
                  "title": "list of unbonding ids, each uniquely identifing an unbonding of this validator",
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uint64"
                  }
                }
              },
              "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryDelegatorValidatorsResponse is response type for the\nQuery/DelegatorValidators RPC method."
      },
      "cosmos.staking.v1beta1.QueryHistoricalInfoResponse": {
        "type": "object",
        "properties": {
          "hist": {
            "type": "object",
            "properties": {
              "header": {
                "type": "object",
                "properties": {
                  "version": {
                    "title": "basic block info",
                    "type": "object",
                    "properties": {
                      "block": {
                        "type": "string",
                        "format": "uint64"
                      },
                      "app": {
                        "type": "string",
                        "format": "uint64"
                      }
                    },
                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                  },
                  "chain_id": {
                    "type": "string"
                  },
                  "height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "time": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "last_block_id": {
                    "title": "prev block info",
                    "type": "object",
                    "properties": {
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "part_set_header": {
                        "title": "PartsetHeader",
                        "type": "object",
                        "properties": {
                          "total": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  },
                  "last_commit_hash": {
                    "title": "hashes of block data",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "data_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "validators_hash": {
                    "title": "hashes from the app output from the prev block",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "next_validators_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "consensus_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "app_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "last_results_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "evidence_hash": {
                    "title": "consensus info",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "proposer_address": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  }
                },
                "description": "Header defines the structure of a block header."
              },
              "valset": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "operator_address": {
                      "type": "string",
                      "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
                    },
                    "consensus_pubkey": {
                      "type": "object",
                      "properties": {
                        "type_url": {
                          "type": "string",
                          "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                        },
                        "value": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Must be a valid serialized protocol buffer of the above specified type.",
                          "format": "byte"
                        }
                      },
                      "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                    },
                    "jailed": {
                      "type": "boolean",
                      "description": "jailed defined whether the validator has been jailed from bonded status or not."
                    },
                    "status": {
                      "type": "string",
                      "description": "status is the validator status (bonded/unbonding/unbonded).",
                      "default": "BOND_STATUS_UNSPECIFIED",
                      "enum": [
                        "BOND_STATUS_UNSPECIFIED",
                        "BOND_STATUS_UNBONDED",
                        "BOND_STATUS_UNBONDING",
                        "BOND_STATUS_BONDED"
                      ]
                    },
                    "tokens": {
                      "type": "string",
                      "description": "tokens define the delegated tokens (incl. self-delegation)."
                    },
                    "delegator_shares": {
                      "type": "string",
                      "description": "delegator_shares defines total shares issued to a validator's delegators."
                    },
                    "description": {
                      "type": "object",
                      "properties": {
                        "moniker": {
                          "type": "string",
                          "description": "moniker defines a human-readable name for the validator."
                        },
                        "identity": {
                          "type": "string",
                          "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                        },
                        "website": {
                          "type": "string",
                          "description": "website defines an optional website link."
                        },
                        "security_contact": {
                          "type": "string",
                          "description": "security_contact defines an optional email for security contact."
                        },
                        "details": {
                          "type": "string",
                          "description": "details define other optional details."
                        }
                      },
                      "description": "description defines the description terms for the validator."
                    },
                    "unbonding_height": {
                      "type": "string",
                      "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                      "format": "int64"
                    },
                    "unbonding_time": {
                      "type": "string",
                      "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                      "format": "date-time"
                    },
                    "commission": {
                      "type": "object",
                      "properties": {
                        "commission_rates": {
                          "type": "object",
                          "properties": {
                            "rate": {
                              "type": "string",
                              "description": "rate is the commission rate charged to delegators, as a fraction."
                            },
                            "max_rate": {
                              "type": "string",
                              "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                            },
                            "max_change_rate": {
                              "type": "string",
                              "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                            }
                          },
                          "description": "commission_rates defines the initial commission rates to be used for creating a validator."
                        },
                        "update_time": {
                          "type": "string",
                          "description": "update_time is the last time the commission rate was changed.",
                          "format": "date-time"
                        }
                      },
                      "description": "commission defines the commission parameters."
                    },
                    "min_self_delegation": {
                      "type": "string",
                      "description": "min_self_delegation is the validator's self declared minimum self delegation.\n\nSince: cosmos-sdk 0.46"
                    },
                    "unbonding_on_hold_ref_count": {
                      "title": "strictly positive if this validator's unbonding has been stopped by external modules",
                      "type": "string",
                      "format": "int64"
                    },
                    "unbonding_ids": {
                      "title": "list of unbonding ids, each uniquely identifing an unbonding of this validator",
                      "type": "array",
                      "items": {
                        "type": "string",
                        "format": "uint64"
                      }
                    }
                  },
                  "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
                }
              }
            },
            "description": "hist defines the historical info at the given height."
          }
        },
        "description": "QueryHistoricalInfoResponse is response type for the Query/HistoricalInfo RPC\nmethod."
      },
      "cosmos.staking.v1beta1.QueryParamsResponse": {
        "type": "object",
        "properties": {
          "params": {
            "type": "object",
            "properties": {
              "unbonding_time": {
                "type": "string",
                "description": "unbonding_time is the time duration of unbonding."
              },
              "max_validators": {
                "type": "integer",
                "description": "max_validators is the maximum number of validators.",
                "format": "int64"
              },
              "max_entries": {
                "type": "integer",
                "description": "max_entries is the max entries for either unbonding delegation or redelegation (per pair/trio).",
                "format": "int64"
              },
              "historical_entries": {
                "type": "integer",
                "description": "historical_entries is the number of historical entries to persist.",
                "format": "int64"
              },
              "bond_denom": {
                "type": "string",
                "description": "bond_denom defines the bondable coin denomination."
              },
              "min_commission_rate": {
                "title": "min_commission_rate is the chain-wide minimum commission rate that a validator can charge their delegators",
                "type": "string"
              }
            },
            "description": "params holds all the parameters of this module."
          }
        },
        "description": "QueryParamsResponse is response type for the Query/Params RPC method."
      },
      "cosmos.staking.v1beta1.QueryPoolResponse": {
        "type": "object",
        "properties": {
          "pool": {
            "type": "object",
            "properties": {
              "not_bonded_tokens": {
                "type": "string"
              },
              "bonded_tokens": {
                "type": "string"
              }
            },
            "description": "pool defines the pool info."
          }
        },
        "description": "QueryPoolResponse is response type for the Query/Pool RPC method."
      },
      "cosmos.staking.v1beta1.QueryRedelegationsResponse": {
        "type": "object",
        "properties": {
          "redelegation_responses": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "redelegation": {
                  "type": "object",
                  "properties": {
                    "delegator_address": {
                      "type": "string",
                      "description": "delegator_address is the bech32-encoded address of the delegator."
                    },
                    "validator_src_address": {
                      "type": "string",
                      "description": "validator_src_address is the validator redelegation source operator address."
                    },
                    "validator_dst_address": {
                      "type": "string",
                      "description": "validator_dst_address is the validator redelegation destination operator address."
                    },
                    "entries": {
                      "type": "array",
                      "description": "entries are the redelegation entries.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "creation_height": {
                            "type": "string",
                            "description": "creation_height  defines the height which the redelegation took place.",
                            "format": "int64"
                          },
                          "completion_time": {
                            "type": "string",
                            "description": "completion_time defines the unix time for redelegation completion.",
                            "format": "date-time"
                          },
                          "initial_balance": {
                            "type": "string",
                            "description": "initial_balance defines the initial balance when redelegation started."
                          },
                          "shares_dst": {
                            "type": "string",
                            "description": "shares_dst is the amount of destination-validator shares created by redelegation."
                          },
                          "unbonding_id": {
                            "title": "Incrementing id that uniquely identifies this entry",
                            "type": "string",
                            "format": "uint64"
                          },
                          "unbonding_on_hold_ref_count": {
                            "title": "Strictly positive if this entry's unbonding has been stopped by external modules",
                            "type": "string",
                            "format": "int64"
                          }
                        },
                        "description": "RedelegationEntry defines a redelegation object with relevant metadata."
                      }
                    }
                  },
                  "description": "Redelegation contains the list of a particular delegator's redelegating bonds\nfrom a particular source validator to a particular destination validator."
                },
                "entries": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "redelegation_entry": {
                        "type": "object",
                        "properties": {
                          "creation_height": {
                            "type": "string",
                            "description": "creation_height  defines the height which the redelegation took place.",
                            "format": "int64"
                          },
                          "completion_time": {
                            "type": "string",
                            "description": "completion_time defines the unix time for redelegation completion.",
                            "format": "date-time"
                          },
                          "initial_balance": {
                            "type": "string",
                            "description": "initial_balance defines the initial balance when redelegation started."
                          },
                          "shares_dst": {
                            "type": "string",
                            "description": "shares_dst is the amount of destination-validator shares created by redelegation."
                          },
                          "unbonding_id": {
                            "title": "Incrementing id that uniquely identifies this entry",
                            "type": "string",
                            "format": "uint64"
                          },
                          "unbonding_on_hold_ref_count": {
                            "title": "Strictly positive if this entry's unbonding has been stopped by external modules",
                            "type": "string",
                            "format": "int64"
                          }
                        },
                        "description": "RedelegationEntry defines a redelegation object with relevant metadata."
                      },
                      "balance": {
                        "type": "string"
                      }
                    },
                    "description": "RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\ncontains a balance in addition to shares which is more suitable for client\nresponses."
                  }
                }
              },
              "description": "RedelegationResponse is equivalent to a Redelegation except that its entries\ncontain a balance in addition to shares which is more suitable for client\nresponses."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryRedelegationsResponse is response type for the Query/Redelegations RPC\nmethod."
      },
      "cosmos.staking.v1beta1.QueryUnbondingDelegationResponse": {
        "type": "object",
        "properties": {
          "unbond": {
            "type": "object",
            "properties": {
              "delegator_address": {
                "type": "string",
                "description": "delegator_address is the encoded address of the delegator."
              },
              "validator_address": {
                "type": "string",
                "description": "validator_address is the encoded address of the validator."
              },
              "entries": {
                "type": "array",
                "description": "entries are the unbonding delegation entries.",
                "items": {
                  "type": "object",
                  "properties": {
                    "creation_height": {
                      "type": "string",
                      "description": "creation_height is the height which the unbonding took place.",
                      "format": "int64"
                    },
                    "completion_time": {
                      "type": "string",
                      "description": "completion_time is the unix time for unbonding completion.",
                      "format": "date-time"
                    },
                    "initial_balance": {
                      "type": "string",
                      "description": "initial_balance defines the tokens initially scheduled to receive at completion."
                    },
                    "balance": {
                      "type": "string",
                      "description": "balance defines the tokens to receive at completion."
                    },
                    "unbonding_id": {
                      "title": "Incrementing id that uniquely identifies this entry",
                      "type": "string",
                      "format": "uint64"
                    },
                    "unbonding_on_hold_ref_count": {
                      "title": "Strictly positive if this entry's unbonding has been stopped by external modules",
                      "type": "string",
                      "format": "int64"
                    }
                  },
                  "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
                }
              }
            },
            "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
          }
        },
        "description": "QueryDelegationResponse is response type for the Query/UnbondingDelegation\nRPC method."
      },
      "cosmos.staking.v1beta1.QueryValidatorDelegationsResponse": {
        "title": "QueryValidatorDelegationsResponse is response type for the\nQuery/ValidatorDelegations RPC method",
        "type": "object",
        "properties": {
          "delegation_responses": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "delegation": {
                  "type": "object",
                  "properties": {
                    "delegator_address": {
                      "type": "string",
                      "description": "delegator_address is the encoded address of the delegator."
                    },
                    "validator_address": {
                      "type": "string",
                      "description": "validator_address is the encoded address of the validator."
                    },
                    "shares": {
                      "type": "string",
                      "description": "shares define the delegation shares received."
                    }
                  },
                  "description": "Delegation represents the bond with tokens held by an account. It is\nowned by one delegator, and is associated with the voting power of one\nvalidator."
                },
                "balance": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "description": "DelegationResponse is equivalent to Delegation except that it contains a\nbalance in addition to shares which is more suitable for client responses."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        }
      },
      "cosmos.staking.v1beta1.QueryValidatorResponse": {
        "title": "QueryValidatorResponse is response type for the Query/Validator RPC method",
        "type": "object",
        "properties": {
          "validator": {
            "type": "object",
            "properties": {
              "operator_address": {
                "type": "string",
                "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
              },
              "consensus_pubkey": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                    "format": "byte"
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "jailed": {
                "type": "boolean",
                "description": "jailed defined whether the validator has been jailed from bonded status or not."
              },
              "status": {
                "type": "string",
                "description": "status is the validator status (bonded/unbonding/unbonded).",
                "default": "BOND_STATUS_UNSPECIFIED",
                "enum": [
                  "BOND_STATUS_UNSPECIFIED",
                  "BOND_STATUS_UNBONDED",
                  "BOND_STATUS_UNBONDING",
                  "BOND_STATUS_BONDED"
                ]
              },
              "tokens": {
                "type": "string",
                "description": "tokens define the delegated tokens (incl. self-delegation)."
              },
              "delegator_shares": {
                "type": "string",
                "description": "delegator_shares defines total shares issued to a validator's delegators."
              },
              "description": {
                "type": "object",
                "properties": {
                  "moniker": {
                    "type": "string",
                    "description": "moniker defines a human-readable name for the validator."
                  },
                  "identity": {
                    "type": "string",
                    "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                  },
                  "website": {
                    "type": "string",
                    "description": "website defines an optional website link."
                  },
                  "security_contact": {
                    "type": "string",
                    "description": "security_contact defines an optional email for security contact."
                  },
                  "details": {
                    "type": "string",
                    "description": "details define other optional details."
                  }
                },
                "description": "description defines the description terms for the validator."
              },
              "unbonding_height": {
                "type": "string",
                "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                "format": "int64"
              },
              "unbonding_time": {
                "type": "string",
                "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                "format": "date-time"
              },
              "commission": {
                "type": "object",
                "properties": {
                  "commission_rates": {
                    "type": "object",
                    "properties": {
                      "rate": {
                        "type": "string",
                        "description": "rate is the commission rate charged to delegators, as a fraction."
                      },
                      "max_rate": {
                        "type": "string",
                        "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                      },
                      "max_change_rate": {
                        "type": "string",
                        "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                      }
                    },
                    "description": "commission_rates defines the initial commission rates to be used for creating a validator."
                  },
                  "update_time": {
                    "type": "string",
                    "description": "update_time is the last time the commission rate was changed.",
                    "format": "date-time"
                  }
                },
                "description": "commission defines the commission parameters."
              },
              "min_self_delegation": {
                "type": "string",
                "description": "min_self_delegation is the validator's self declared minimum self delegation.\n\nSince: cosmos-sdk 0.46"
              },
              "unbonding_on_hold_ref_count": {
                "title": "strictly positive if this validator's unbonding has been stopped by external modules",
                "type": "string",
                "format": "int64"
              },
              "unbonding_ids": {
                "title": "list of unbonding ids, each uniquely identifing an unbonding of this validator",
                "type": "array",
                "items": {
                  "type": "string",
                  "format": "uint64"
                }
              }
            },
            "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
          }
        }
      },
      "cosmos.staking.v1beta1.QueryValidatorUnbondingDelegationsResponse": {
        "type": "object",
        "properties": {
          "unbonding_responses": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "delegator_address": {
                  "type": "string",
                  "description": "delegator_address is the encoded address of the delegator."
                },
                "validator_address": {
                  "type": "string",
                  "description": "validator_address is the encoded address of the validator."
                },
                "entries": {
                  "type": "array",
                  "description": "entries are the unbonding delegation entries.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "creation_height": {
                        "type": "string",
                        "description": "creation_height is the height which the unbonding took place.",
                        "format": "int64"
                      },
                      "completion_time": {
                        "type": "string",
                        "description": "completion_time is the unix time for unbonding completion.",
                        "format": "date-time"
                      },
                      "initial_balance": {
                        "type": "string",
                        "description": "initial_balance defines the tokens initially scheduled to receive at completion."
                      },
                      "balance": {
                        "type": "string",
                        "description": "balance defines the tokens to receive at completion."
                      },
                      "unbonding_id": {
                        "title": "Incrementing id that uniquely identifies this entry",
                        "type": "string",
                        "format": "uint64"
                      },
                      "unbonding_on_hold_ref_count": {
                        "title": "Strictly positive if this entry's unbonding has been stopped by external modules",
                        "type": "string",
                        "format": "int64"
                      }
                    },
                    "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
                  }
                }
              },
              "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        },
        "description": "QueryValidatorUnbondingDelegationsResponse is response type for the\nQuery/ValidatorUnbondingDelegations RPC method."
      },
      "cosmos.staking.v1beta1.QueryValidatorsResponse": {
        "title": "QueryValidatorsResponse is response type for the Query/Validators RPC method",
        "type": "object",
        "properties": {
          "validators": {
            "type": "array",
            "description": "validators contains all the queried validators.",
            "items": {
              "type": "object",
              "properties": {
                "operator_address": {
                  "type": "string",
                  "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
                },
                "consensus_pubkey": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "byte"
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                },
                "jailed": {
                  "type": "boolean",
                  "description": "jailed defined whether the validator has been jailed from bonded status or not."
                },
                "status": {
                  "type": "string",
                  "description": "status is the validator status (bonded/unbonding/unbonded).",
                  "default": "BOND_STATUS_UNSPECIFIED",
                  "enum": [
                    "BOND_STATUS_UNSPECIFIED",
                    "BOND_STATUS_UNBONDED",
                    "BOND_STATUS_UNBONDING",
                    "BOND_STATUS_BONDED"
                  ]
                },
                "tokens": {
                  "type": "string",
                  "description": "tokens define the delegated tokens (incl. self-delegation)."
                },
                "delegator_shares": {
                  "type": "string",
                  "description": "delegator_shares defines total shares issued to a validator's delegators."
                },
                "description": {
                  "type": "object",
                  "properties": {
                    "moniker": {
                      "type": "string",
                      "description": "moniker defines a human-readable name for the validator."
                    },
                    "identity": {
                      "type": "string",
                      "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
                    },
                    "website": {
                      "type": "string",
                      "description": "website defines an optional website link."
                    },
                    "security_contact": {
                      "type": "string",
                      "description": "security_contact defines an optional email for security contact."
                    },
                    "details": {
                      "type": "string",
                      "description": "details define other optional details."
                    }
                  },
                  "description": "description defines the description terms for the validator."
                },
                "unbonding_height": {
                  "type": "string",
                  "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
                  "format": "int64"
                },
                "unbonding_time": {
                  "type": "string",
                  "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
                  "format": "date-time"
                },
                "commission": {
                  "type": "object",
                  "properties": {
                    "commission_rates": {
                      "type": "object",
                      "properties": {
                        "rate": {
                          "type": "string",
                          "description": "rate is the commission rate charged to delegators, as a fraction."
                        },
                        "max_rate": {
                          "type": "string",
                          "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                        },
                        "max_change_rate": {
                          "type": "string",
                          "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                        }
                      },
                      "description": "commission_rates defines the initial commission rates to be used for creating a validator."
                    },
                    "update_time": {
                      "type": "string",
                      "description": "update_time is the last time the commission rate was changed.",
                      "format": "date-time"
                    }
                  },
                  "description": "commission defines the commission parameters."
                },
                "min_self_delegation": {
                  "type": "string",
                  "description": "min_self_delegation is the validator's self declared minimum self delegation.\n\nSince: cosmos-sdk 0.46"
                },
                "unbonding_on_hold_ref_count": {
                  "title": "strictly positive if this validator's unbonding has been stopped by external modules",
                  "type": "string",
                  "format": "int64"
                },
                "unbonding_ids": {
                  "title": "list of unbonding ids, each uniquely identifing an unbonding of this validator",
                  "type": "array",
                  "items": {
                    "type": "string",
                    "format": "uint64"
                  }
                }
              },
              "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines the pagination in the response."
          }
        }
      },
      "cosmos.staking.v1beta1.Redelegation": {
        "type": "object",
        "properties": {
          "delegator_address": {
            "type": "string",
            "description": "delegator_address is the bech32-encoded address of the delegator."
          },
          "validator_src_address": {
            "type": "string",
            "description": "validator_src_address is the validator redelegation source operator address."
          },
          "validator_dst_address": {
            "type": "string",
            "description": "validator_dst_address is the validator redelegation destination operator address."
          },
          "entries": {
            "type": "array",
            "description": "entries are the redelegation entries.",
            "items": {
              "type": "object",
              "properties": {
                "creation_height": {
                  "type": "string",
                  "description": "creation_height  defines the height which the redelegation took place.",
                  "format": "int64"
                },
                "completion_time": {
                  "type": "string",
                  "description": "completion_time defines the unix time for redelegation completion.",
                  "format": "date-time"
                },
                "initial_balance": {
                  "type": "string",
                  "description": "initial_balance defines the initial balance when redelegation started."
                },
                "shares_dst": {
                  "type": "string",
                  "description": "shares_dst is the amount of destination-validator shares created by redelegation."
                },
                "unbonding_id": {
                  "title": "Incrementing id that uniquely identifies this entry",
                  "type": "string",
                  "format": "uint64"
                },
                "unbonding_on_hold_ref_count": {
                  "title": "Strictly positive if this entry's unbonding has been stopped by external modules",
                  "type": "string",
                  "format": "int64"
                }
              },
              "description": "RedelegationEntry defines a redelegation object with relevant metadata."
            }
          }
        },
        "description": "Redelegation contains the list of a particular delegator's redelegating bonds\nfrom a particular source validator to a particular destination validator."
      },
      "cosmos.staking.v1beta1.RedelegationEntry": {
        "type": "object",
        "properties": {
          "creation_height": {
            "type": "string",
            "description": "creation_height  defines the height which the redelegation took place.",
            "format": "int64"
          },
          "completion_time": {
            "type": "string",
            "description": "completion_time defines the unix time for redelegation completion.",
            "format": "date-time"
          },
          "initial_balance": {
            "type": "string",
            "description": "initial_balance defines the initial balance when redelegation started."
          },
          "shares_dst": {
            "type": "string",
            "description": "shares_dst is the amount of destination-validator shares created by redelegation."
          },
          "unbonding_id": {
            "title": "Incrementing id that uniquely identifies this entry",
            "type": "string",
            "format": "uint64"
          },
          "unbonding_on_hold_ref_count": {
            "title": "Strictly positive if this entry's unbonding has been stopped by external modules",
            "type": "string",
            "format": "int64"
          }
        },
        "description": "RedelegationEntry defines a redelegation object with relevant metadata."
      },
      "cosmos.staking.v1beta1.RedelegationEntryResponse": {
        "type": "object",
        "properties": {
          "redelegation_entry": {
            "type": "object",
            "properties": {
              "creation_height": {
                "type": "string",
                "description": "creation_height  defines the height which the redelegation took place.",
                "format": "int64"
              },
              "completion_time": {
                "type": "string",
                "description": "completion_time defines the unix time for redelegation completion.",
                "format": "date-time"
              },
              "initial_balance": {
                "type": "string",
                "description": "initial_balance defines the initial balance when redelegation started."
              },
              "shares_dst": {
                "type": "string",
                "description": "shares_dst is the amount of destination-validator shares created by redelegation."
              },
              "unbonding_id": {
                "title": "Incrementing id that uniquely identifies this entry",
                "type": "string",
                "format": "uint64"
              },
              "unbonding_on_hold_ref_count": {
                "title": "Strictly positive if this entry's unbonding has been stopped by external modules",
                "type": "string",
                "format": "int64"
              }
            },
            "description": "RedelegationEntry defines a redelegation object with relevant metadata."
          },
          "balance": {
            "type": "string"
          }
        },
        "description": "RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\ncontains a balance in addition to shares which is more suitable for client\nresponses."
      },
      "cosmos.staking.v1beta1.RedelegationResponse": {
        "type": "object",
        "properties": {
          "redelegation": {
            "type": "object",
            "properties": {
              "delegator_address": {
                "type": "string",
                "description": "delegator_address is the bech32-encoded address of the delegator."
              },
              "validator_src_address": {
                "type": "string",
                "description": "validator_src_address is the validator redelegation source operator address."
              },
              "validator_dst_address": {
                "type": "string",
                "description": "validator_dst_address is the validator redelegation destination operator address."
              },
              "entries": {
                "type": "array",
                "description": "entries are the redelegation entries.",
                "items": {
                  "type": "object",
                  "properties": {
                    "creation_height": {
                      "type": "string",
                      "description": "creation_height  defines the height which the redelegation took place.",
                      "format": "int64"
                    },
                    "completion_time": {
                      "type": "string",
                      "description": "completion_time defines the unix time for redelegation completion.",
                      "format": "date-time"
                    },
                    "initial_balance": {
                      "type": "string",
                      "description": "initial_balance defines the initial balance when redelegation started."
                    },
                    "shares_dst": {
                      "type": "string",
                      "description": "shares_dst is the amount of destination-validator shares created by redelegation."
                    },
                    "unbonding_id": {
                      "title": "Incrementing id that uniquely identifies this entry",
                      "type": "string",
                      "format": "uint64"
                    },
                    "unbonding_on_hold_ref_count": {
                      "title": "Strictly positive if this entry's unbonding has been stopped by external modules",
                      "type": "string",
                      "format": "int64"
                    }
                  },
                  "description": "RedelegationEntry defines a redelegation object with relevant metadata."
                }
              }
            },
            "description": "Redelegation contains the list of a particular delegator's redelegating bonds\nfrom a particular source validator to a particular destination validator."
          },
          "entries": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "redelegation_entry": {
                  "type": "object",
                  "properties": {
                    "creation_height": {
                      "type": "string",
                      "description": "creation_height  defines the height which the redelegation took place.",
                      "format": "int64"
                    },
                    "completion_time": {
                      "type": "string",
                      "description": "completion_time defines the unix time for redelegation completion.",
                      "format": "date-time"
                    },
                    "initial_balance": {
                      "type": "string",
                      "description": "initial_balance defines the initial balance when redelegation started."
                    },
                    "shares_dst": {
                      "type": "string",
                      "description": "shares_dst is the amount of destination-validator shares created by redelegation."
                    },
                    "unbonding_id": {
                      "title": "Incrementing id that uniquely identifies this entry",
                      "type": "string",
                      "format": "uint64"
                    },
                    "unbonding_on_hold_ref_count": {
                      "title": "Strictly positive if this entry's unbonding has been stopped by external modules",
                      "type": "string",
                      "format": "int64"
                    }
                  },
                  "description": "RedelegationEntry defines a redelegation object with relevant metadata."
                },
                "balance": {
                  "type": "string"
                }
              },
              "description": "RedelegationEntryResponse is equivalent to a RedelegationEntry except that it\ncontains a balance in addition to shares which is more suitable for client\nresponses."
            }
          }
        },
        "description": "RedelegationResponse is equivalent to a Redelegation except that its entries\ncontain a balance in addition to shares which is more suitable for client\nresponses."
      },
      "cosmos.staking.v1beta1.UnbondingDelegation": {
        "type": "object",
        "properties": {
          "delegator_address": {
            "type": "string",
            "description": "delegator_address is the encoded address of the delegator."
          },
          "validator_address": {
            "type": "string",
            "description": "validator_address is the encoded address of the validator."
          },
          "entries": {
            "type": "array",
            "description": "entries are the unbonding delegation entries.",
            "items": {
              "type": "object",
              "properties": {
                "creation_height": {
                  "type": "string",
                  "description": "creation_height is the height which the unbonding took place.",
                  "format": "int64"
                },
                "completion_time": {
                  "type": "string",
                  "description": "completion_time is the unix time for unbonding completion.",
                  "format": "date-time"
                },
                "initial_balance": {
                  "type": "string",
                  "description": "initial_balance defines the tokens initially scheduled to receive at completion."
                },
                "balance": {
                  "type": "string",
                  "description": "balance defines the tokens to receive at completion."
                },
                "unbonding_id": {
                  "title": "Incrementing id that uniquely identifies this entry",
                  "type": "string",
                  "format": "uint64"
                },
                "unbonding_on_hold_ref_count": {
                  "title": "Strictly positive if this entry's unbonding has been stopped by external modules",
                  "type": "string",
                  "format": "int64"
                }
              },
              "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
            }
          }
        },
        "description": "UnbondingDelegation stores all of a single delegator's unbonding bonds\nfor a single validator in an time-ordered list."
      },
      "cosmos.staking.v1beta1.UnbondingDelegationEntry": {
        "type": "object",
        "properties": {
          "creation_height": {
            "type": "string",
            "description": "creation_height is the height which the unbonding took place.",
            "format": "int64"
          },
          "completion_time": {
            "type": "string",
            "description": "completion_time is the unix time for unbonding completion.",
            "format": "date-time"
          },
          "initial_balance": {
            "type": "string",
            "description": "initial_balance defines the tokens initially scheduled to receive at completion."
          },
          "balance": {
            "type": "string",
            "description": "balance defines the tokens to receive at completion."
          },
          "unbonding_id": {
            "title": "Incrementing id that uniquely identifies this entry",
            "type": "string",
            "format": "uint64"
          },
          "unbonding_on_hold_ref_count": {
            "title": "Strictly positive if this entry's unbonding has been stopped by external modules",
            "type": "string",
            "format": "int64"
          }
        },
        "description": "UnbondingDelegationEntry defines an unbonding object with relevant metadata."
      },
      "cosmos.staking.v1beta1.Validator": {
        "type": "object",
        "properties": {
          "operator_address": {
            "type": "string",
            "description": "operator_address defines the address of the validator's operator; bech encoded in JSON."
          },
          "consensus_pubkey": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "jailed": {
            "type": "boolean",
            "description": "jailed defined whether the validator has been jailed from bonded status or not."
          },
          "status": {
            "type": "string",
            "description": "status is the validator status (bonded/unbonding/unbonded).",
            "default": "BOND_STATUS_UNSPECIFIED",
            "enum": [
              "BOND_STATUS_UNSPECIFIED",
              "BOND_STATUS_UNBONDED",
              "BOND_STATUS_UNBONDING",
              "BOND_STATUS_BONDED"
            ]
          },
          "tokens": {
            "type": "string",
            "description": "tokens define the delegated tokens (incl. self-delegation)."
          },
          "delegator_shares": {
            "type": "string",
            "description": "delegator_shares defines total shares issued to a validator's delegators."
          },
          "description": {
            "type": "object",
            "properties": {
              "moniker": {
                "type": "string",
                "description": "moniker defines a human-readable name for the validator."
              },
              "identity": {
                "type": "string",
                "description": "identity defines an optional identity signature (ex. UPort or Keybase)."
              },
              "website": {
                "type": "string",
                "description": "website defines an optional website link."
              },
              "security_contact": {
                "type": "string",
                "description": "security_contact defines an optional email for security contact."
              },
              "details": {
                "type": "string",
                "description": "details define other optional details."
              }
            },
            "description": "description defines the description terms for the validator."
          },
          "unbonding_height": {
            "type": "string",
            "description": "unbonding_height defines, if unbonding, the height at which this validator has begun unbonding.",
            "format": "int64"
          },
          "unbonding_time": {
            "type": "string",
            "description": "unbonding_time defines, if unbonding, the min time for the validator to complete unbonding.",
            "format": "date-time"
          },
          "commission": {
            "type": "object",
            "properties": {
              "commission_rates": {
                "type": "object",
                "properties": {
                  "rate": {
                    "type": "string",
                    "description": "rate is the commission rate charged to delegators, as a fraction."
                  },
                  "max_rate": {
                    "type": "string",
                    "description": "max_rate defines the maximum commission rate which validator can ever charge, as a fraction."
                  },
                  "max_change_rate": {
                    "type": "string",
                    "description": "max_change_rate defines the maximum daily increase of the validator commission, as a fraction."
                  }
                },
                "description": "commission_rates defines the initial commission rates to be used for creating a validator."
              },
              "update_time": {
                "type": "string",
                "description": "update_time is the last time the commission rate was changed.",
                "format": "date-time"
              }
            },
            "description": "commission defines the commission parameters."
          },
          "min_self_delegation": {
            "type": "string",
            "description": "min_self_delegation is the validator's self declared minimum self delegation.\n\nSince: cosmos-sdk 0.46"
          },
          "unbonding_on_hold_ref_count": {
            "title": "strictly positive if this validator's unbonding has been stopped by external modules",
            "type": "string",
            "format": "int64"
          },
          "unbonding_ids": {
            "title": "list of unbonding ids, each uniquely identifing an unbonding of this validator",
            "type": "array",
            "items": {
              "type": "string",
              "format": "uint64"
            }
          }
        },
        "description": "Validator defines a validator, together with the total amount of the\nValidator's bond shares and their exchange rate to coins. Slashing results in\na decrease in the exchange rate, allowing correct calculation of future\nundelegations without iterating over delegators. When coins are delegated to\nthis validator, the validator is credited with a delegation whose number of\nbond shares is based on the amount of coins delegated divided by the current\nexchange rate. Voting power can be calculated as total bonded shares\nmultiplied by exchange rate."
      },
      "tendermint.types.BlockID": {
        "title": "BlockID",
        "type": "object",
        "properties": {
          "hash": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "part_set_header": {
            "title": "PartsetHeader",
            "type": "object",
            "properties": {
              "total": {
                "type": "integer",
                "format": "int64"
              },
              "hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              }
            }
          }
        }
      },
      "tendermint.types.Header": {
        "type": "object",
        "properties": {
          "version": {
            "title": "basic block info",
            "type": "object",
            "properties": {
              "block": {
                "type": "string",
                "format": "uint64"
              },
              "app": {
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
          },
          "chain_id": {
            "type": "string"
          },
          "height": {
            "type": "string",
            "format": "int64"
          },
          "time": {
            "type": "string",
            "format": "date-time"
          },
          "last_block_id": {
            "title": "prev block info",
            "type": "object",
            "properties": {
              "hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "part_set_header": {
                "title": "PartsetHeader",
                "type": "object",
                "properties": {
                  "total": {
                    "type": "integer",
                    "format": "int64"
                  },
                  "hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  }
                }
              }
            }
          },
          "last_commit_hash": {
            "title": "hashes of block data",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "data_hash": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "validators_hash": {
            "title": "hashes from the app output from the prev block",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "next_validators_hash": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "consensus_hash": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "app_hash": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "last_results_hash": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "evidence_hash": {
            "title": "consensus info",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "proposer_address": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          }
        },
        "description": "Header defines the structure of a block header."
      },
      "tendermint.types.PartSetHeader": {
        "title": "PartsetHeader",
        "type": "object",
        "properties": {
          "total": {
            "type": "integer",
            "format": "int64"
          },
          "hash": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          }
        }
      },
      "tendermint.version.Consensus": {
        "type": "object",
        "properties": {
          "block": {
            "type": "string",
            "format": "uint64"
          },
          "app": {
            "type": "string",
            "format": "uint64"
          }
        },
        "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
      },
      "cosmos.base.abci.v1beta1.ABCIMessageLog": {
        "type": "object",
        "properties": {
          "msg_index": {
            "type": "integer",
            "format": "int64"
          },
          "log": {
            "type": "string"
          },
          "events": {
            "type": "array",
            "description": "Events contains a slice of Event objects that were emitted during some\nexecution.",
            "items": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string"
                },
                "attributes": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "key": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string"
                      }
                    },
                    "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
                  }
                }
              },
              "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
            }
          }
        },
        "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log."
      },
      "cosmos.base.abci.v1beta1.Attribute": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string"
          }
        },
        "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
      },
      "cosmos.base.abci.v1beta1.GasInfo": {
        "type": "object",
        "properties": {
          "gas_wanted": {
            "type": "string",
            "description": "GasWanted is the maximum units of work we allow this tx to perform.",
            "format": "uint64"
          },
          "gas_used": {
            "type": "string",
            "description": "GasUsed is the amount of gas actually consumed.",
            "format": "uint64"
          }
        },
        "description": "GasInfo defines tx execution gas context."
      },
      "cosmos.base.abci.v1beta1.Result": {
        "type": "object",
        "properties": {
          "data": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "Data is any data returned from message or handler execution. It MUST be\nlength prefixed in order to separate data from multiple message executions.\nDeprecated. This field is still populated, but prefer msg_response instead\nbecause it also contains the Msg response typeURL.",
            "format": "byte"
          },
          "log": {
            "type": "string",
            "description": "Log contains the log information from message or handler execution."
          },
          "events": {
            "type": "array",
            "description": "Events contains a slice of Event objects that were emitted during message\nor handler execution.",
            "items": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string"
                },
                "attributes": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "key": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string"
                      },
                      "index": {
                        "type": "boolean"
                      }
                    },
                    "description": "EventAttribute is a single key-value pair, associated with an event."
                  }
                }
              },
              "description": "Event allows application developers to attach additional information to\nResponseFinalizeBlock and ResponseCheckTx.\nLater, transactions may be queried using these events."
            }
          },
          "msg_responses": {
            "type": "array",
            "description": "msg_responses contains the Msg handler responses type packed in Anys.\n\nSince: cosmos-sdk 0.46",
            "items": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "byte"
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            }
          }
        },
        "description": "Result is the union of ResponseFormat and ResponseCheckTx."
      },
      "cosmos.base.abci.v1beta1.StringEvent": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          },
          "attributes": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "key": {
                  "type": "string"
                },
                "value": {
                  "type": "string"
                }
              },
              "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
            }
          }
        },
        "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
      },
      "cosmos.base.abci.v1beta1.TxResponse": {
        "type": "object",
        "properties": {
          "height": {
            "title": "The block height",
            "type": "string",
            "format": "int64"
          },
          "txhash": {
            "type": "string",
            "description": "The transaction hash."
          },
          "codespace": {
            "title": "Namespace for the Code",
            "type": "string"
          },
          "code": {
            "type": "integer",
            "description": "Response code.",
            "format": "int64"
          },
          "data": {
            "type": "string",
            "description": "Result bytes, if any."
          },
          "raw_log": {
            "type": "string",
            "description": "The output of the application's logger (raw string). May be\nnon-deterministic."
          },
          "logs": {
            "type": "array",
            "description": "The output of the application's logger (typed). May be non-deterministic.",
            "items": {
              "type": "object",
              "properties": {
                "msg_index": {
                  "type": "integer",
                  "format": "int64"
                },
                "log": {
                  "type": "string"
                },
                "events": {
                  "type": "array",
                  "description": "Events contains a slice of Event objects that were emitted during some\nexecution.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type": {
                        "type": "string"
                      },
                      "attributes": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "key": {
                              "type": "string"
                            },
                            "value": {
                              "type": "string"
                            }
                          },
                          "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
                        }
                      }
                    },
                    "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
                  }
                }
              },
              "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log."
            }
          },
          "info": {
            "type": "string",
            "description": "Additional information. May be non-deterministic."
          },
          "gas_wanted": {
            "type": "string",
            "description": "Amount of gas requested for transaction.",
            "format": "int64"
          },
          "gas_used": {
            "type": "string",
            "description": "Amount of gas consumed by transaction.",
            "format": "int64"
          },
          "tx": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "timestamp": {
            "type": "string",
            "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time."
          },
          "events": {
            "type": "array",
            "description": "Events defines all the events emitted by processing a transaction. Note,\nthese events include those emitted by processing all the messages and those\nemitted from the ante. Whereas Logs contains the events, with\nadditional metadata, emitted only by processing the messages.\n\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45",
            "items": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string"
                },
                "attributes": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "properties": {
                      "key": {
                        "type": "string"
                      },
                      "value": {
                        "type": "string"
                      },
                      "index": {
                        "type": "boolean"
                      }
                    },
                    "description": "EventAttribute is a single key-value pair, associated with an event."
                  }
                }
              },
              "description": "Event allows application developers to attach additional information to\nResponseFinalizeBlock and ResponseCheckTx.\nLater, transactions may be queried using these events."
            }
          }
        },
        "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded."
      },
      "cosmos.crypto.multisig.v1beta1.CompactBitArray": {
        "type": "object",
        "properties": {
          "extra_bits_stored": {
            "type": "integer",
            "format": "int64"
          },
          "elems": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          }
        },
        "description": "CompactBitArray is an implementation of a space efficient bit array.\nThis is used to ensure that the encoded data takes up a minimal amount of\nspace after proto encoding.\nThis is not thread safe, and is not intended for concurrent usage."
      },
      "cosmos.tx.signing.v1beta1.SignMode": {
        "type": "string",
        "description": "SignMode represents a signing mode with its own security guarantees.\n\nThis enum should be considered a registry of all known sign modes\nin the Cosmos ecosystem. Apps are not expected to support all known\nsign modes. Apps that would like to support custom  sign modes are\nencouraged to open a small PR against this file to add a new case\nto this SignMode enum describing their sign mode so that different\napps have a consistent version of this enum.\n\n - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\nrejected.\n - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\nverified with raw bytes from Tx.\n - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some\nhuman-readable textual representation on top of the binary representation\nfrom SIGN_MODE_DIRECT. It is currently experimental, and should be used\nfor testing purposes only, until Textual is fully released. Please follow\nthe tracking issue https://github.com/cosmos/cosmos-sdk/issues/11970.\n - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses\nSignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not\nrequire signers signing over other signers' `signer_info`. It also allows\nfor adding Tips in transactions.\n\nSince: cosmos-sdk 0.46\n - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\nAmino JSON and will be removed in the future.\n - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos\nSDK. Ref: https://eips.ethereum.org/EIPS/eip-191\n\nCurrently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,\nbut is not implemented on the SDK by default. To enable EIP-191, you need\nto pass a custom `TxConfig` that has an implementation of\n`SignModeHandler` for EIP-191. The SDK may decide to fully support\nEIP-191 in the future.\n\nSince: cosmos-sdk 0.45.2",
        "default": "SIGN_MODE_UNSPECIFIED",
        "enum": [
          "SIGN_MODE_UNSPECIFIED",
          "SIGN_MODE_DIRECT",
          "SIGN_MODE_TEXTUAL",
          "SIGN_MODE_DIRECT_AUX",
          "SIGN_MODE_LEGACY_AMINO_JSON",
          "SIGN_MODE_EIP_191"
        ]
      },
      "cosmos.tx.v1beta1.AuthInfo": {
        "type": "object",
        "properties": {
          "signer_infos": {
            "type": "array",
            "description": "signer_infos defines the signing modes for the required signers. The number\nand order of elements must match the required signers from TxBody's\nmessages. The first element is the primary signer and the one which pays\nthe fee.",
            "items": {
              "$ref": "#/components/schemas/cosmos.tx.v1beta1.SignerInfo"
            }
          },
          "fee": {
            "type": "object",
            "properties": {
              "amount": {
                "title": "amount is the amount of coins to be paid as a fee",
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "gas_limit": {
                "title": "gas_limit is the maximum gas that can be used in transaction processing\nbefore an out of gas error occurs",
                "type": "string",
                "format": "uint64"
              },
              "payer": {
                "type": "string",
                "description": "if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.\nthe payer must be a tx signer (and thus have signed this field in AuthInfo).\nsetting this field does *not* change the ordering of required signers for the transaction."
              },
              "granter": {
                "title": "if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used\nto pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does\nnot support fee grants, this will fail",
                "type": "string"
              }
            },
            "description": "Fee is the fee and gas limit for the transaction. The first signer is the\nprimary signer and the one which pays the fee. The fee can be calculated\nbased on the cost of evaluating the body and doing signature verification\nof the signers. This can be estimated via simulation."
          },
          "tip": {
            "type": "object",
            "properties": {
              "amount": {
                "title": "amount is the amount of the tip",
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "denom": {
                      "type": "string"
                    },
                    "amount": {
                      "type": "string"
                    }
                  },
                  "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
                }
              },
              "tipper": {
                "title": "tipper is the address of the account paying for the tip",
                "type": "string"
              }
            },
            "description": "Tip is the optional tip used for transactions fees paid in another denom.\n\nThis field is ignored if the chain didn't enable tips, i.e. didn't add the\n`TipDecorator` in its posthandler.\n\nSince: cosmos-sdk 0.46"
          }
        },
        "description": "AuthInfo describes the fee and signer modes that are used to sign a\ntransaction."
      },
      "cosmos.tx.v1beta1.BroadcastMode": {
        "type": "string",
        "description": "BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC\nmethod.\n\n - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering\n - BROADCAST_MODE_BLOCK: DEPRECATED: use BROADCAST_MODE_SYNC instead,\nBROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.\n - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits\nfor a CheckTx execution response only.\n - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client\nreturns immediately.",
        "default": "BROADCAST_MODE_UNSPECIFIED",
        "enum": [
          "BROADCAST_MODE_UNSPECIFIED",
          "BROADCAST_MODE_BLOCK",
          "BROADCAST_MODE_SYNC",
          "BROADCAST_MODE_ASYNC"
        ]
      },
      "cosmos.tx.v1beta1.BroadcastTxRequest": {
        "type": "object",
        "properties": {
          "tx_bytes": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "tx_bytes is the raw transaction.",
            "format": "byte"
          },
          "mode": {
            "type": "string",
            "description": "BroadcastMode specifies the broadcast mode for the TxService.Broadcast RPC\nmethod.\n\n - BROADCAST_MODE_UNSPECIFIED: zero-value for mode ordering\n - BROADCAST_MODE_BLOCK: DEPRECATED: use BROADCAST_MODE_SYNC instead,\nBROADCAST_MODE_BLOCK is not supported by the SDK from v0.47.x onwards.\n - BROADCAST_MODE_SYNC: BROADCAST_MODE_SYNC defines a tx broadcasting mode where the client waits\nfor a CheckTx execution response only.\n - BROADCAST_MODE_ASYNC: BROADCAST_MODE_ASYNC defines a tx broadcasting mode where the client\nreturns immediately.",
            "default": "BROADCAST_MODE_UNSPECIFIED",
            "enum": [
              "BROADCAST_MODE_UNSPECIFIED",
              "BROADCAST_MODE_BLOCK",
              "BROADCAST_MODE_SYNC",
              "BROADCAST_MODE_ASYNC"
            ]
          }
        },
        "description": "BroadcastTxRequest is the request type for the Service.BroadcastTxRequest\nRPC method."
      },
      "cosmos.tx.v1beta1.BroadcastTxResponse": {
        "type": "object",
        "properties": {
          "tx_response": {
            "type": "object",
            "properties": {
              "height": {
                "title": "The block height",
                "type": "string",
                "format": "int64"
              },
              "txhash": {
                "type": "string",
                "description": "The transaction hash."
              },
              "codespace": {
                "title": "Namespace for the Code",
                "type": "string"
              },
              "code": {
                "type": "integer",
                "description": "Response code.",
                "format": "int64"
              },
              "data": {
                "type": "string",
                "description": "Result bytes, if any."
              },
              "raw_log": {
                "type": "string",
                "description": "The output of the application's logger (raw string). May be\nnon-deterministic."
              },
              "logs": {
                "type": "array",
                "description": "The output of the application's logger (typed). May be non-deterministic.",
                "items": {
                  "type": "object",
                  "properties": {
                    "msg_index": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "log": {
                      "type": "string"
                    },
                    "events": {
                      "type": "array",
                      "description": "Events contains a slice of Event objects that were emitted during some\nexecution.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string"
                          },
                          "attributes": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "key": {
                                  "type": "string"
                                },
                                "value": {
                                  "type": "string"
                                }
                              },
                              "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
                            }
                          }
                        },
                        "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
                      }
                    }
                  },
                  "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log."
                }
              },
              "info": {
                "type": "string",
                "description": "Additional information. May be non-deterministic."
              },
              "gas_wanted": {
                "type": "string",
                "description": "Amount of gas requested for transaction.",
                "format": "int64"
              },
              "gas_used": {
                "type": "string",
                "description": "Amount of gas consumed by transaction.",
                "format": "int64"
              },
              "tx": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                    "format": "byte"
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "timestamp": {
                "type": "string",
                "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time."
              },
              "events": {
                "type": "array",
                "description": "Events defines all the events emitted by processing a transaction. Note,\nthese events include those emitted by processing all the messages and those\nemitted from the ante. Whereas Logs contains the events, with\nadditional metadata, emitted only by processing the messages.\n\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45",
                "items": {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string"
                    },
                    "attributes": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "key": {
                            "type": "string"
                          },
                          "value": {
                            "type": "string"
                          },
                          "index": {
                            "type": "boolean"
                          }
                        },
                        "description": "EventAttribute is a single key-value pair, associated with an event."
                      }
                    }
                  },
                  "description": "Event allows application developers to attach additional information to\nResponseFinalizeBlock and ResponseCheckTx.\nLater, transactions may be queried using these events."
                }
              }
            },
            "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded."
          }
        },
        "description": "BroadcastTxResponse is the response type for the\nService.BroadcastTx method."
      },
      "cosmos.tx.v1beta1.Fee": {
        "type": "object",
        "properties": {
          "amount": {
            "title": "amount is the amount of coins to be paid as a fee",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            }
          },
          "gas_limit": {
            "title": "gas_limit is the maximum gas that can be used in transaction processing\nbefore an out of gas error occurs",
            "type": "string",
            "format": "uint64"
          },
          "payer": {
            "type": "string",
            "description": "if unset, the first signer is responsible for paying the fees. If set, the specified account must pay the fees.\nthe payer must be a tx signer (and thus have signed this field in AuthInfo).\nsetting this field does *not* change the ordering of required signers for the transaction."
          },
          "granter": {
            "title": "if set, the fee payer (either the first signer or the value of the payer field) requests that a fee grant be used\nto pay fees instead of the fee payer's own balance. If an appropriate fee grant does not exist or the chain does\nnot support fee grants, this will fail",
            "type": "string"
          }
        },
        "description": "Fee includes the amount of coins paid in fees and the maximum\ngas to be used by the transaction. The ratio yields an effective \"gasprice\",\nwhich must be above some miminum to be accepted into the mempool."
      },
      "cosmos.tx.v1beta1.GetBlockWithTxsResponse": {
        "type": "object",
        "properties": {
          "txs": {
            "type": "array",
            "description": "txs are the transactions in the block.",
            "items": {
              "$ref": "#/components/schemas/cosmos.tx.v1beta1.Tx"
            }
          },
          "block_id": {
            "title": "BlockID",
            "type": "object",
            "properties": {
              "hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "part_set_header": {
                "title": "PartsetHeader",
                "type": "object",
                "properties": {
                  "total": {
                    "type": "integer",
                    "format": "int64"
                  },
                  "hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  }
                }
              }
            }
          },
          "block": {
            "type": "object",
            "properties": {
              "header": {
                "type": "object",
                "properties": {
                  "version": {
                    "title": "basic block info",
                    "type": "object",
                    "properties": {
                      "block": {
                        "type": "string",
                        "format": "uint64"
                      },
                      "app": {
                        "type": "string",
                        "format": "uint64"
                      }
                    },
                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                  },
                  "chain_id": {
                    "type": "string"
                  },
                  "height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "time": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "last_block_id": {
                    "title": "BlockID",
                    "type": "object",
                    "properties": {
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "part_set_header": {
                        "title": "PartsetHeader",
                        "type": "object",
                        "properties": {
                          "total": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  },
                  "last_commit_hash": {
                    "title": "hashes of block data",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "data_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "validators_hash": {
                    "title": "hashes from the app output from the prev block",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "next_validators_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "consensus_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "app_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "last_results_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "evidence_hash": {
                    "title": "consensus info",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "proposer_address": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  }
                },
                "description": "Header defines the structure of a block header."
              },
              "data": {
                "title": "Data contains the set of transactions included in the block",
                "type": "object",
                "properties": {
                  "txs": {
                    "type": "array",
                    "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs.",
                    "items": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    }
                  }
                }
              },
              "evidence": {
                "type": "object",
                "properties": {
                  "evidence": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "duplicate_vote_evidence": {
                          "type": "object",
                          "properties": {
                            "vote_a": {
                              "type": "object",
                              "properties": {
                                "type": {
                                  "type": "string",
                                  "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                  "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                  "enum": [
                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                    "SIGNED_MSG_TYPE_PREVOTE",
                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                  ]
                                },
                                "height": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "round": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "block_id": {
                                  "title": "BlockID",
                                  "type": "object",
                                  "properties": {
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "part_set_header": {
                                      "title": "PartsetHeader",
                                      "type": "object",
                                      "properties": {
                                        "total": {
                                          "type": "integer",
                                          "format": "int64"
                                        },
                                        "hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      }
                                    }
                                  }
                                },
                                "timestamp": {
                                  "type": "string",
                                  "format": "date-time"
                                },
                                "validator_address": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "validator_index": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                                  "format": "byte"
                                },
                                "extension": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                                  "format": "byte"
                                },
                                "extension_signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                                  "format": "byte"
                                }
                              },
                              "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                            },
                            "vote_b": {
                              "type": "object",
                              "properties": {
                                "type": {
                                  "type": "string",
                                  "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                  "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                  "enum": [
                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                    "SIGNED_MSG_TYPE_PREVOTE",
                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                  ]
                                },
                                "height": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "round": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "block_id": {
                                  "title": "BlockID",
                                  "type": "object",
                                  "properties": {
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "part_set_header": {
                                      "title": "PartsetHeader",
                                      "type": "object",
                                      "properties": {
                                        "total": {
                                          "type": "integer",
                                          "format": "int64"
                                        },
                                        "hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      }
                                    }
                                  }
                                },
                                "timestamp": {
                                  "type": "string",
                                  "format": "date-time"
                                },
                                "validator_address": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "validator_index": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                                  "format": "byte"
                                },
                                "extension": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                                  "format": "byte"
                                },
                                "extension_signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                                  "format": "byte"
                                }
                              },
                              "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                            },
                            "total_voting_power": {
                              "type": "string",
                              "format": "int64"
                            },
                            "validator_power": {
                              "type": "string",
                              "format": "int64"
                            },
                            "timestamp": {
                              "type": "string",
                              "format": "date-time"
                            }
                          },
                          "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                        },
                        "light_client_attack_evidence": {
                          "type": "object",
                          "properties": {
                            "conflicting_block": {
                              "type": "object",
                              "properties": {
                                "signed_header": {
                                  "type": "object",
                                  "properties": {
                                    "header": {
                                      "type": "object",
                                      "properties": {
                                        "version": {
                                          "title": "basic block info",
                                          "type": "object",
                                          "properties": {
                                            "block": {
                                              "type": "string",
                                              "format": "uint64"
                                            },
                                            "app": {
                                              "type": "string",
                                              "format": "uint64"
                                            }
                                          },
                                          "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                        },
                                        "chain_id": {
                                          "type": "string"
                                        },
                                        "height": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "time": {
                                          "type": "string",
                                          "format": "date-time"
                                        },
                                        "last_block_id": {
                                          "title": "BlockID",
                                          "type": "object",
                                          "properties": {
                                            "hash": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "part_set_header": {
                                              "title": "PartsetHeader",
                                              "type": "object",
                                              "properties": {
                                                "total": {
                                                  "type": "integer",
                                                  "format": "int64"
                                                },
                                                "hash": {
                                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                  "type": "string",
                                                  "format": "byte"
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "last_commit_hash": {
                                          "title": "hashes of block data",
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "data_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "validators_hash": {
                                          "title": "hashes from the app output from the prev block",
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "next_validators_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "consensus_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "app_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "last_results_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "evidence_hash": {
                                          "title": "consensus info",
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "proposer_address": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      },
                                      "description": "Header defines the structure of a block header."
                                    },
                                    "commit": {
                                      "type": "object",
                                      "properties": {
                                        "height": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "round": {
                                          "type": "integer",
                                          "format": "int32"
                                        },
                                        "block_id": {
                                          "title": "BlockID",
                                          "type": "object",
                                          "properties": {
                                            "hash": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "part_set_header": {
                                              "title": "PartsetHeader",
                                              "type": "object",
                                              "properties": {
                                                "total": {
                                                  "type": "integer",
                                                  "format": "int64"
                                                },
                                                "hash": {
                                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                  "type": "string",
                                                  "format": "byte"
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "signatures": {
                                          "type": "array",
                                          "items": {
                                            "type": "object",
                                            "properties": {
                                              "block_id_flag": {
                                                "title": "BlockIdFlag indicates which BlockID the signature is for",
                                                "type": "string",
                                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                "enum": [
                                                  "BLOCK_ID_FLAG_UNKNOWN",
                                                  "BLOCK_ID_FLAG_ABSENT",
                                                  "BLOCK_ID_FLAG_COMMIT",
                                                  "BLOCK_ID_FLAG_NIL"
                                                ]
                                              },
                                              "validator_address": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "timestamp": {
                                                "type": "string",
                                                "format": "date-time"
                                              },
                                              "signature": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "description": "CommitSig is a part of the Vote included in a Commit."
                                          }
                                        }
                                      },
                                      "description": "Commit contains the evidence that a block was committed by a set of validators."
                                    }
                                  }
                                },
                                "validator_set": {
                                  "type": "object",
                                  "properties": {
                                    "validators": {
                                      "type": "array",
                                      "items": {
                                        "type": "object",
                                        "properties": {
                                          "address": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "pub_key": {
                                            "title": "PublicKey defines the keys available for use with Validators",
                                            "type": "object",
                                            "properties": {
                                              "ed25519": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "secp256k1": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            }
                                          },
                                          "voting_power": {
                                            "type": "string",
                                            "format": "int64"
                                          },
                                          "proposer_priority": {
                                            "type": "string",
                                            "format": "int64"
                                          }
                                        }
                                      }
                                    },
                                    "proposer": {
                                      "type": "object",
                                      "properties": {
                                        "address": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "pub_key": {
                                          "title": "PublicKey defines the keys available for use with Validators",
                                          "type": "object",
                                          "properties": {
                                            "ed25519": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "secp256k1": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          }
                                        },
                                        "voting_power": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "proposer_priority": {
                                          "type": "string",
                                          "format": "int64"
                                        }
                                      }
                                    },
                                    "total_voting_power": {
                                      "type": "string",
                                      "format": "int64"
                                    }
                                  }
                                }
                              }
                            },
                            "common_height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "byzantine_validators": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "address": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "pub_key": {
                                    "title": "PublicKey defines the keys available for use with Validators",
                                    "type": "object",
                                    "properties": {
                                      "ed25519": {
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "secp256k1": {
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    }
                                  },
                                  "voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "proposer_priority": {
                                    "type": "string",
                                    "format": "int64"
                                  }
                                }
                              }
                            },
                            "total_voting_power": {
                              "type": "string",
                              "format": "int64"
                            },
                            "timestamp": {
                              "type": "string",
                              "format": "date-time"
                            }
                          },
                          "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                        }
                      }
                    }
                  }
                }
              },
              "last_commit": {
                "type": "object",
                "properties": {
                  "height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "round": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "block_id": {
                    "title": "BlockID",
                    "type": "object",
                    "properties": {
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "part_set_header": {
                        "title": "PartsetHeader",
                        "type": "object",
                        "properties": {
                          "total": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  },
                  "signatures": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "block_id_flag": {
                          "title": "BlockIdFlag indicates which BlockID the signature is for",
                          "type": "string",
                          "default": "BLOCK_ID_FLAG_UNKNOWN",
                          "enum": [
                            "BLOCK_ID_FLAG_UNKNOWN",
                            "BLOCK_ID_FLAG_ABSENT",
                            "BLOCK_ID_FLAG_COMMIT",
                            "BLOCK_ID_FLAG_NIL"
                          ]
                        },
                        "validator_address": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        },
                        "timestamp": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "signature": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "description": "CommitSig is a part of the Vote included in a Commit."
                    }
                  }
                },
                "description": "Commit contains the evidence that a block was committed by a set of validators."
              }
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines a pagination for the response."
          }
        },
        "description": "GetBlockWithTxsResponse is the response type for the Service.GetBlockWithTxs\nmethod.\n\nSince: cosmos-sdk 0.45.2"
      },
      "cosmos.tx.v1beta1.GetTxResponse": {
        "type": "object",
        "properties": {
          "tx": {
            "$ref": "#/components/schemas/cosmos.tx.v1beta1.Tx"
          },
          "tx_response": {
            "type": "object",
            "properties": {
              "height": {
                "title": "The block height",
                "type": "string",
                "format": "int64"
              },
              "txhash": {
                "type": "string",
                "description": "The transaction hash."
              },
              "codespace": {
                "title": "Namespace for the Code",
                "type": "string"
              },
              "code": {
                "type": "integer",
                "description": "Response code.",
                "format": "int64"
              },
              "data": {
                "type": "string",
                "description": "Result bytes, if any."
              },
              "raw_log": {
                "type": "string",
                "description": "The output of the application's logger (raw string). May be\nnon-deterministic."
              },
              "logs": {
                "type": "array",
                "description": "The output of the application's logger (typed). May be non-deterministic.",
                "items": {
                  "type": "object",
                  "properties": {
                    "msg_index": {
                      "type": "integer",
                      "format": "int64"
                    },
                    "log": {
                      "type": "string"
                    },
                    "events": {
                      "type": "array",
                      "description": "Events contains a slice of Event objects that were emitted during some\nexecution.",
                      "items": {
                        "type": "object",
                        "properties": {
                          "type": {
                            "type": "string"
                          },
                          "attributes": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "key": {
                                  "type": "string"
                                },
                                "value": {
                                  "type": "string"
                                }
                              },
                              "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
                            }
                          }
                        },
                        "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
                      }
                    }
                  },
                  "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log."
                }
              },
              "info": {
                "type": "string",
                "description": "Additional information. May be non-deterministic."
              },
              "gas_wanted": {
                "type": "string",
                "description": "Amount of gas requested for transaction.",
                "format": "int64"
              },
              "gas_used": {
                "type": "string",
                "description": "Amount of gas consumed by transaction.",
                "format": "int64"
              },
              "tx": {
                "type": "object",
                "properties": {
                  "type_url": {
                    "type": "string",
                    "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                  },
                  "value": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "description": "Must be a valid serialized protocol buffer of the above specified type.",
                    "format": "byte"
                  }
                },
                "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
              },
              "timestamp": {
                "type": "string",
                "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time."
              },
              "events": {
                "type": "array",
                "description": "Events defines all the events emitted by processing a transaction. Note,\nthese events include those emitted by processing all the messages and those\nemitted from the ante. Whereas Logs contains the events, with\nadditional metadata, emitted only by processing the messages.\n\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45",
                "items": {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string"
                    },
                    "attributes": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "key": {
                            "type": "string"
                          },
                          "value": {
                            "type": "string"
                          },
                          "index": {
                            "type": "boolean"
                          }
                        },
                        "description": "EventAttribute is a single key-value pair, associated with an event."
                      }
                    }
                  },
                  "description": "Event allows application developers to attach additional information to\nResponseFinalizeBlock and ResponseCheckTx.\nLater, transactions may be queried using these events."
                }
              }
            },
            "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded."
          }
        },
        "description": "GetTxResponse is the response type for the Service.GetTx method."
      },
      "cosmos.tx.v1beta1.GetTxsEventResponse": {
        "type": "object",
        "properties": {
          "txs": {
            "type": "array",
            "description": "txs is the list of queried transactions.",
            "items": {
              "$ref": "#/components/schemas/cosmos.tx.v1beta1.Tx"
            }
          },
          "tx_responses": {
            "type": "array",
            "description": "tx_responses is the list of queried TxResponses.",
            "items": {
              "type": "object",
              "properties": {
                "height": {
                  "title": "The block height",
                  "type": "string",
                  "format": "int64"
                },
                "txhash": {
                  "type": "string",
                  "description": "The transaction hash."
                },
                "codespace": {
                  "title": "Namespace for the Code",
                  "type": "string"
                },
                "code": {
                  "type": "integer",
                  "description": "Response code.",
                  "format": "int64"
                },
                "data": {
                  "type": "string",
                  "description": "Result bytes, if any."
                },
                "raw_log": {
                  "type": "string",
                  "description": "The output of the application's logger (raw string). May be\nnon-deterministic."
                },
                "logs": {
                  "type": "array",
                  "description": "The output of the application's logger (typed). May be non-deterministic.",
                  "items": {
                    "type": "object",
                    "properties": {
                      "msg_index": {
                        "type": "integer",
                        "format": "int64"
                      },
                      "log": {
                        "type": "string"
                      },
                      "events": {
                        "type": "array",
                        "description": "Events contains a slice of Event objects that were emitted during some\nexecution.",
                        "items": {
                          "type": "object",
                          "properties": {
                            "type": {
                              "type": "string"
                            },
                            "attributes": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "key": {
                                    "type": "string"
                                  },
                                  "value": {
                                    "type": "string"
                                  }
                                },
                                "description": "Attribute defines an attribute wrapper where the key and value are\nstrings instead of raw bytes."
                              }
                            }
                          },
                          "description": "StringEvent defines en Event object wrapper where all the attributes\ncontain key/value pairs that are strings instead of raw bytes."
                        }
                      }
                    },
                    "description": "ABCIMessageLog defines a structure containing an indexed tx ABCI message log."
                  }
                },
                "info": {
                  "type": "string",
                  "description": "Additional information. May be non-deterministic."
                },
                "gas_wanted": {
                  "type": "string",
                  "description": "Amount of gas requested for transaction.",
                  "format": "int64"
                },
                "gas_used": {
                  "type": "string",
                  "description": "Amount of gas consumed by transaction.",
                  "format": "int64"
                },
                "tx": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "byte"
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                },
                "timestamp": {
                  "type": "string",
                  "description": "Time of the previous block. For heights > 1, it's the weighted median of\nthe timestamps of the valid votes in the block.LastCommit. For height == 1,\nit's genesis time."
                },
                "events": {
                  "type": "array",
                  "description": "Events defines all the events emitted by processing a transaction. Note,\nthese events include those emitted by processing all the messages and those\nemitted from the ante. Whereas Logs contains the events, with\nadditional metadata, emitted only by processing the messages.\n\nSince: cosmos-sdk 0.42.11, 0.44.5, 0.45",
                  "items": {
                    "type": "object",
                    "properties": {
                      "type": {
                        "type": "string"
                      },
                      "attributes": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "key": {
                              "type": "string"
                            },
                            "value": {
                              "type": "string"
                            },
                            "index": {
                              "type": "boolean"
                            }
                          },
                          "description": "EventAttribute is a single key-value pair, associated with an event."
                        }
                      }
                    },
                    "description": "Event allows application developers to attach additional information to\nResponseFinalizeBlock and ResponseCheckTx.\nLater, transactions may be queried using these events."
                  }
                }
              },
              "description": "TxResponse defines a structure containing relevant tx data and metadata. The\ntags are stringified and the log is JSON decoded."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines a pagination for the response.\nDeprecated post v0.46.x: use total instead."
          },
          "total": {
            "title": "total is total number of results available",
            "type": "string",
            "format": "uint64"
          }
        },
        "description": "GetTxsEventResponse is the response type for the Service.TxsByEvents\nRPC method."
      },
      "cosmos.tx.v1beta1.ModeInfo": {
        "type": "object",
        "properties": {
          "single": {
            "title": "single represents a single signer",
            "type": "object",
            "properties": {
              "mode": {
                "title": "mode is the signing mode of the single signer",
                "type": "string",
                "description": "SignMode represents a signing mode with its own security guarantees.\n\nThis enum should be considered a registry of all known sign modes\nin the Cosmos ecosystem. Apps are not expected to support all known\nsign modes. Apps that would like to support custom  sign modes are\nencouraged to open a small PR against this file to add a new case\nto this SignMode enum describing their sign mode so that different\napps have a consistent version of this enum.\n\n - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\nrejected.\n - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\nverified with raw bytes from Tx.\n - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some\nhuman-readable textual representation on top of the binary representation\nfrom SIGN_MODE_DIRECT. It is currently experimental, and should be used\nfor testing purposes only, until Textual is fully released. Please follow\nthe tracking issue https://github.com/cosmos/cosmos-sdk/issues/11970.\n - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses\nSignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not\nrequire signers signing over other signers' `signer_info`. It also allows\nfor adding Tips in transactions.\n\nSince: cosmos-sdk 0.46\n - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\nAmino JSON and will be removed in the future.\n - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos\nSDK. Ref: https://eips.ethereum.org/EIPS/eip-191\n\nCurrently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,\nbut is not implemented on the SDK by default. To enable EIP-191, you need\nto pass a custom `TxConfig` that has an implementation of\n`SignModeHandler` for EIP-191. The SDK may decide to fully support\nEIP-191 in the future.\n\nSince: cosmos-sdk 0.45.2",
                "default": "SIGN_MODE_UNSPECIFIED",
                "enum": [
                  "SIGN_MODE_UNSPECIFIED",
                  "SIGN_MODE_DIRECT",
                  "SIGN_MODE_TEXTUAL",
                  "SIGN_MODE_DIRECT_AUX",
                  "SIGN_MODE_LEGACY_AMINO_JSON",
                  "SIGN_MODE_EIP_191"
                ]
              }
            }
          },
          "multi": {
            "$ref": "#/components/schemas/cosmos.tx.v1beta1.ModeInfo.Multi"
          }
        },
        "description": "ModeInfo describes the signing mode of a single or nested multisig signer."
      },
      "cosmos.tx.v1beta1.ModeInfo.Multi": {
        "title": "Multi is the mode info for a multisig public key",
        "type": "object",
        "properties": {
          "bitarray": {
            "title": "bitarray specifies which keys within the multisig are signing",
            "type": "object",
            "properties": {
              "extra_bits_stored": {
                "type": "integer",
                "format": "int64"
              },
              "elems": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              }
            },
            "description": "CompactBitArray is an implementation of a space efficient bit array.\nThis is used to ensure that the encoded data takes up a minimal amount of\nspace after proto encoding.\nThis is not thread safe, and is not intended for concurrent usage."
          },
          "mode_infos": {
            "title": "mode_infos is the corresponding modes of the signers of the multisig\nwhich could include nested multisig public keys",
            "type": "array",
            "items": {
              "$ref": "#/components/schemas/cosmos.tx.v1beta1.ModeInfo"
            }
          }
        }
      },
      "cosmos.tx.v1beta1.ModeInfo.Single": {
        "title": "Single is the mode info for a single signer. It is structured as a message\nto allow for additional fields such as locale for SIGN_MODE_TEXTUAL in the\nfuture",
        "type": "object",
        "properties": {
          "mode": {
            "title": "mode is the signing mode of the single signer",
            "type": "string",
            "description": "SignMode represents a signing mode with its own security guarantees.\n\nThis enum should be considered a registry of all known sign modes\nin the Cosmos ecosystem. Apps are not expected to support all known\nsign modes. Apps that would like to support custom  sign modes are\nencouraged to open a small PR against this file to add a new case\nto this SignMode enum describing their sign mode so that different\napps have a consistent version of this enum.\n\n - SIGN_MODE_UNSPECIFIED: SIGN_MODE_UNSPECIFIED specifies an unknown signing mode and will be\nrejected.\n - SIGN_MODE_DIRECT: SIGN_MODE_DIRECT specifies a signing mode which uses SignDoc and is\nverified with raw bytes from Tx.\n - SIGN_MODE_TEXTUAL: SIGN_MODE_TEXTUAL is a future signing mode that will verify some\nhuman-readable textual representation on top of the binary representation\nfrom SIGN_MODE_DIRECT. It is currently experimental, and should be used\nfor testing purposes only, until Textual is fully released. Please follow\nthe tracking issue https://github.com/cosmos/cosmos-sdk/issues/11970.\n - SIGN_MODE_DIRECT_AUX: SIGN_MODE_DIRECT_AUX specifies a signing mode which uses\nSignDocDirectAux. As opposed to SIGN_MODE_DIRECT, this sign mode does not\nrequire signers signing over other signers' `signer_info`. It also allows\nfor adding Tips in transactions.\n\nSince: cosmos-sdk 0.46\n - SIGN_MODE_LEGACY_AMINO_JSON: SIGN_MODE_LEGACY_AMINO_JSON is a backwards compatibility mode which uses\nAmino JSON and will be removed in the future.\n - SIGN_MODE_EIP_191: SIGN_MODE_EIP_191 specifies the sign mode for EIP 191 signing on the Cosmos\nSDK. Ref: https://eips.ethereum.org/EIPS/eip-191\n\nCurrently, SIGN_MODE_EIP_191 is registered as a SignMode enum variant,\nbut is not implemented on the SDK by default. To enable EIP-191, you need\nto pass a custom `TxConfig` that has an implementation of\n`SignModeHandler` for EIP-191. The SDK may decide to fully support\nEIP-191 in the future.\n\nSince: cosmos-sdk 0.45.2",
            "default": "SIGN_MODE_UNSPECIFIED",
            "enum": [
              "SIGN_MODE_UNSPECIFIED",
              "SIGN_MODE_DIRECT",
              "SIGN_MODE_TEXTUAL",
              "SIGN_MODE_DIRECT_AUX",
              "SIGN_MODE_LEGACY_AMINO_JSON",
              "SIGN_MODE_EIP_191"
            ]
          }
        }
      },
      "cosmos.tx.v1beta1.OrderBy": {
        "title": "OrderBy defines the sorting order",
        "type": "string",
        "description": "- ORDER_BY_UNSPECIFIED: ORDER_BY_UNSPECIFIED specifies an unknown sorting order. OrderBy defaults\nto ASC in this case.\n - ORDER_BY_ASC: ORDER_BY_ASC defines ascending order\n - ORDER_BY_DESC: ORDER_BY_DESC defines descending order",
        "default": "ORDER_BY_UNSPECIFIED",
        "enum": [
          "ORDER_BY_UNSPECIFIED",
          "ORDER_BY_ASC",
          "ORDER_BY_DESC"
        ]
      },
      "cosmos.tx.v1beta1.SignerInfo": {
        "type": "object",
        "properties": {
          "public_key": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "mode_info": {
            "$ref": "#/components/schemas/cosmos.tx.v1beta1.ModeInfo"
          },
          "sequence": {
            "type": "string",
            "description": "sequence is the sequence of the account, which describes the\nnumber of committed transactions signed by a given address. It is used to\nprevent replay attacks.",
            "format": "uint64"
          }
        },
        "description": "SignerInfo describes the public key and signing mode of a single top-level\nsigner."
      },
      "cosmos.tx.v1beta1.SimulateRequest": {
        "type": "object",
        "properties": {
          "tx": {
            "$ref": "#/components/schemas/cosmos.tx.v1beta1.Tx"
          },
          "tx_bytes": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "tx_bytes is the raw transaction.\n\nSince: cosmos-sdk 0.43",
            "format": "byte"
          }
        },
        "description": "SimulateRequest is the request type for the Service.Simulate\nRPC method."
      },
      "cosmos.tx.v1beta1.SimulateResponse": {
        "type": "object",
        "properties": {
          "gas_info": {
            "type": "object",
            "properties": {
              "gas_wanted": {
                "type": "string",
                "description": "GasWanted is the maximum units of work we allow this tx to perform.",
                "format": "uint64"
              },
              "gas_used": {
                "type": "string",
                "description": "GasUsed is the amount of gas actually consumed.",
                "format": "uint64"
              }
            },
            "description": "gas_info is the information about gas used in the simulation."
          },
          "result": {
            "type": "object",
            "properties": {
              "data": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Data is any data returned from message or handler execution. It MUST be\nlength prefixed in order to separate data from multiple message executions.\nDeprecated. This field is still populated, but prefer msg_response instead\nbecause it also contains the Msg response typeURL.",
                "format": "byte"
              },
              "log": {
                "type": "string",
                "description": "Log contains the log information from message or handler execution."
              },
              "events": {
                "type": "array",
                "description": "Events contains a slice of Event objects that were emitted during message\nor handler execution.",
                "items": {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string"
                    },
                    "attributes": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "key": {
                            "type": "string"
                          },
                          "value": {
                            "type": "string"
                          },
                          "index": {
                            "type": "boolean"
                          }
                        },
                        "description": "EventAttribute is a single key-value pair, associated with an event."
                      }
                    }
                  },
                  "description": "Event allows application developers to attach additional information to\nResponseFinalizeBlock and ResponseCheckTx.\nLater, transactions may be queried using these events."
                }
              },
              "msg_responses": {
                "type": "array",
                "description": "msg_responses contains the Msg handler responses type packed in Anys.\n\nSince: cosmos-sdk 0.46",
                "items": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "byte"
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                }
              }
            },
            "description": "result is the result of the simulation."
          }
        },
        "description": "SimulateResponse is the response type for the\nService.SimulateRPC method."
      },
      "cosmos.tx.v1beta1.Tip": {
        "type": "object",
        "properties": {
          "amount": {
            "title": "amount is the amount of the tip",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "denom": {
                  "type": "string"
                },
                "amount": {
                  "type": "string"
                }
              },
              "description": "Coin defines a token with a denomination and an amount.\n\nNOTE: The amount field is an Int which implements the custom method\nsignatures required by gogoproto."
            }
          },
          "tipper": {
            "title": "tipper is the address of the account paying for the tip",
            "type": "string"
          }
        },
        "description": "Tip is the tip used for meta-transactions.\n\nSince: cosmos-sdk 0.46"
      },
      "cosmos.tx.v1beta1.Tx": {
        "type": "object",
        "properties": {
          "body": {
            "title": "body is the processable content of the transaction",
            "type": "object",
            "properties": {
              "messages": {
                "type": "array",
                "description": "messages is a list of messages to be executed. The required signers of\nthose messages define the number and order of elements in AuthInfo's\nsigner_infos and Tx's signatures. Each required signer address is added to\nthe list only the first time it occurs.\nBy convention, the first required signer (usually from the first message)\nis referred to as the primary signer and pays the fee for the whole\ntransaction.",
                "items": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "byte"
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                }
              },
              "memo": {
                "type": "string",
                "description": "memo is any arbitrary note/comment to be added to the transaction.\nWARNING: in clients, any publicly exposed text should not be called memo,\nbut should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122)."
              },
              "timeout_height": {
                "title": "timeout is the block height after which this transaction will not\nbe processed by the chain",
                "type": "string",
                "format": "uint64"
              },
              "extension_options": {
                "title": "extension_options are arbitrary options that can be added by chains\nwhen the default options are not sufficient. If any of these are present\nand can't be handled, the transaction will be rejected",
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "byte"
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                }
              },
              "non_critical_extension_options": {
                "title": "extension_options are arbitrary options that can be added by chains\nwhen the default options are not sufficient. If any of these are present\nand can't be handled, they will be ignored",
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "byte"
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                }
              }
            },
            "description": "TxBody is the body of a transaction that all signers sign over."
          },
          "auth_info": {
            "$ref": "#/components/schemas/cosmos.tx.v1beta1.AuthInfo"
          },
          "signatures": {
            "type": "array",
            "description": "signatures is a list of signatures that matches the length and order of\nAuthInfo's signer_infos to allow connecting signature meta information like\npublic key and signing mode by position.",
            "items": {
              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
              "type": "string",
              "format": "byte"
            }
          }
        },
        "description": "Tx is the standard type used for broadcasting transactions."
      },
      "cosmos.tx.v1beta1.TxBody": {
        "type": "object",
        "properties": {
          "messages": {
            "type": "array",
            "description": "messages is a list of messages to be executed. The required signers of\nthose messages define the number and order of elements in AuthInfo's\nsigner_infos and Tx's signatures. Each required signer address is added to\nthe list only the first time it occurs.\nBy convention, the first required signer (usually from the first message)\nis referred to as the primary signer and pays the fee for the whole\ntransaction.",
            "items": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "byte"
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            }
          },
          "memo": {
            "type": "string",
            "description": "memo is any arbitrary note/comment to be added to the transaction.\nWARNING: in clients, any publicly exposed text should not be called memo,\nbut should be called `note` instead (see https://github.com/cosmos/cosmos-sdk/issues/9122)."
          },
          "timeout_height": {
            "title": "timeout is the block height after which this transaction will not\nbe processed by the chain",
            "type": "string",
            "format": "uint64"
          },
          "extension_options": {
            "title": "extension_options are arbitrary options that can be added by chains\nwhen the default options are not sufficient. If any of these are present\nand can't be handled, the transaction will be rejected",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "byte"
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            }
          },
          "non_critical_extension_options": {
            "title": "extension_options are arbitrary options that can be added by chains\nwhen the default options are not sufficient. If any of these are present\nand can't be handled, they will be ignored",
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "type_url": {
                  "type": "string",
                  "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                },
                "value": {
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "description": "Must be a valid serialized protocol buffer of the above specified type.",
                  "format": "byte"
                }
              },
              "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
            }
          }
        },
        "description": "TxBody is the body of a transaction that all signers sign over."
      },
      "cosmos.tx.v1beta1.TxDecodeAminoRequest": {
        "type": "object",
        "properties": {
          "amino_binary": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          }
        },
        "description": "TxDecodeAminoRequest is the request type for the Service.TxDecodeAmino\nRPC method.\n\nSince: cosmos-sdk 0.47"
      },
      "cosmos.tx.v1beta1.TxDecodeAminoResponse": {
        "type": "object",
        "properties": {
          "amino_json": {
            "type": "string"
          }
        },
        "description": "TxDecodeAminoResponse is the response type for the Service.TxDecodeAmino\nRPC method.\n\nSince: cosmos-sdk 0.47"
      },
      "cosmos.tx.v1beta1.TxDecodeRequest": {
        "type": "object",
        "properties": {
          "tx_bytes": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "tx_bytes is the raw transaction.",
            "format": "byte"
          }
        },
        "description": "TxDecodeRequest is the request type for the Service.TxDecode\nRPC method.\n\nSince: cosmos-sdk 0.47"
      },
      "cosmos.tx.v1beta1.TxDecodeResponse": {
        "type": "object",
        "properties": {
          "tx": {
            "$ref": "#/components/schemas/cosmos.tx.v1beta1.Tx"
          }
        },
        "description": "TxDecodeResponse is the response type for the\nService.TxDecode method.\n\nSince: cosmos-sdk 0.47"
      },
      "cosmos.tx.v1beta1.TxEncodeAminoRequest": {
        "type": "object",
        "properties": {
          "amino_json": {
            "type": "string"
          }
        },
        "description": "TxEncodeAminoRequest is the request type for the Service.TxEncodeAmino\nRPC method.\n\nSince: cosmos-sdk 0.47"
      },
      "cosmos.tx.v1beta1.TxEncodeAminoResponse": {
        "type": "object",
        "properties": {
          "amino_binary": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          }
        },
        "description": "TxEncodeAminoResponse is the response type for the Service.TxEncodeAmino\nRPC method.\n\nSince: cosmos-sdk 0.47"
      },
      "cosmos.tx.v1beta1.TxEncodeRequest": {
        "type": "object",
        "properties": {
          "tx": {
            "$ref": "#/components/schemas/cosmos.tx.v1beta1.Tx"
          }
        },
        "description": "TxEncodeRequest is the request type for the Service.TxEncode\nRPC method.\n\nSince: cosmos-sdk 0.47"
      },
      "cosmos.tx.v1beta1.TxEncodeResponse": {
        "type": "object",
        "properties": {
          "tx_bytes": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "tx_bytes is the encoded transaction bytes.",
            "format": "byte"
          }
        },
        "description": "TxEncodeResponse is the response type for the\nService.TxEncode method.\n\nSince: cosmos-sdk 0.47"
      },
      "tendermint.abci.Event": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          },
          "attributes": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "key": {
                  "type": "string"
                },
                "value": {
                  "type": "string"
                },
                "index": {
                  "type": "boolean"
                }
              },
              "description": "EventAttribute is a single key-value pair, associated with an event."
            }
          }
        },
        "description": "Event allows application developers to attach additional information to\nResponseFinalizeBlock and ResponseCheckTx.\nLater, transactions may be queried using these events."
      },
      "tendermint.abci.EventAttribute": {
        "type": "object",
        "properties": {
          "key": {
            "type": "string"
          },
          "value": {
            "type": "string"
          },
          "index": {
            "type": "boolean"
          }
        },
        "description": "EventAttribute is a single key-value pair, associated with an event."
      },
      "tendermint.crypto.PublicKey": {
        "title": "PublicKey defines the keys available for use with Validators",
        "type": "object",
        "properties": {
          "ed25519": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "secp256k1": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          }
        }
      },
      "tendermint.types.Block": {
        "type": "object",
        "properties": {
          "header": {
            "type": "object",
            "properties": {
              "version": {
                "title": "basic block info",
                "type": "object",
                "properties": {
                  "block": {
                    "type": "string",
                    "format": "uint64"
                  },
                  "app": {
                    "type": "string",
                    "format": "uint64"
                  }
                },
                "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
              },
              "chain_id": {
                "type": "string"
              },
              "height": {
                "type": "string",
                "format": "int64"
              },
              "time": {
                "type": "string",
                "format": "date-time"
              },
              "last_block_id": {
                "title": "BlockID",
                "type": "object",
                "properties": {
                  "hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "part_set_header": {
                    "title": "PartsetHeader",
                    "type": "object",
                    "properties": {
                      "total": {
                        "type": "integer",
                        "format": "int64"
                      },
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              },
              "last_commit_hash": {
                "title": "hashes of block data",
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "data_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "validators_hash": {
                "title": "hashes from the app output from the prev block",
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "next_validators_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "consensus_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "app_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "last_results_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "evidence_hash": {
                "title": "consensus info",
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "proposer_address": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              }
            },
            "description": "Header defines the structure of a block header."
          },
          "data": {
            "title": "Data contains the set of transactions included in the block",
            "type": "object",
            "properties": {
              "txs": {
                "type": "array",
                "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs.",
                "items": {
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "format": "byte"
                }
              }
            }
          },
          "evidence": {
            "type": "object",
            "properties": {
              "evidence": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "duplicate_vote_evidence": {
                      "type": "object",
                      "properties": {
                        "vote_a": {
                          "type": "object",
                          "properties": {
                            "type": {
                              "type": "string",
                              "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                              "default": "SIGNED_MSG_TYPE_UNKNOWN",
                              "enum": [
                                "SIGNED_MSG_TYPE_UNKNOWN",
                                "SIGNED_MSG_TYPE_PREVOTE",
                                "SIGNED_MSG_TYPE_PRECOMMIT",
                                "SIGNED_MSG_TYPE_PROPOSAL"
                              ]
                            },
                            "height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "round": {
                              "type": "integer",
                              "format": "int32"
                            },
                            "block_id": {
                              "title": "BlockID",
                              "type": "object",
                              "properties": {
                                "hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "part_set_header": {
                                  "title": "PartsetHeader",
                                  "type": "object",
                                  "properties": {
                                    "total": {
                                      "type": "integer",
                                      "format": "int64"
                                    },
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  }
                                }
                              }
                            },
                            "timestamp": {
                              "type": "string",
                              "format": "date-time"
                            },
                            "validator_address": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "validator_index": {
                              "type": "integer",
                              "format": "int32"
                            },
                            "signature": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                              "format": "byte"
                            },
                            "extension": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                              "format": "byte"
                            },
                            "extension_signature": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                              "format": "byte"
                            }
                          },
                          "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                        },
                        "vote_b": {
                          "type": "object",
                          "properties": {
                            "type": {
                              "type": "string",
                              "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                              "default": "SIGNED_MSG_TYPE_UNKNOWN",
                              "enum": [
                                "SIGNED_MSG_TYPE_UNKNOWN",
                                "SIGNED_MSG_TYPE_PREVOTE",
                                "SIGNED_MSG_TYPE_PRECOMMIT",
                                "SIGNED_MSG_TYPE_PROPOSAL"
                              ]
                            },
                            "height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "round": {
                              "type": "integer",
                              "format": "int32"
                            },
                            "block_id": {
                              "title": "BlockID",
                              "type": "object",
                              "properties": {
                                "hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "part_set_header": {
                                  "title": "PartsetHeader",
                                  "type": "object",
                                  "properties": {
                                    "total": {
                                      "type": "integer",
                                      "format": "int64"
                                    },
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  }
                                }
                              }
                            },
                            "timestamp": {
                              "type": "string",
                              "format": "date-time"
                            },
                            "validator_address": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "validator_index": {
                              "type": "integer",
                              "format": "int32"
                            },
                            "signature": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                              "format": "byte"
                            },
                            "extension": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                              "format": "byte"
                            },
                            "extension_signature": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                              "format": "byte"
                            }
                          },
                          "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                        },
                        "total_voting_power": {
                          "type": "string",
                          "format": "int64"
                        },
                        "validator_power": {
                          "type": "string",
                          "format": "int64"
                        },
                        "timestamp": {
                          "type": "string",
                          "format": "date-time"
                        }
                      },
                      "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                    },
                    "light_client_attack_evidence": {
                      "type": "object",
                      "properties": {
                        "conflicting_block": {
                          "type": "object",
                          "properties": {
                            "signed_header": {
                              "type": "object",
                              "properties": {
                                "header": {
                                  "type": "object",
                                  "properties": {
                                    "version": {
                                      "title": "basic block info",
                                      "type": "object",
                                      "properties": {
                                        "block": {
                                          "type": "string",
                                          "format": "uint64"
                                        },
                                        "app": {
                                          "type": "string",
                                          "format": "uint64"
                                        }
                                      },
                                      "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                    },
                                    "chain_id": {
                                      "type": "string"
                                    },
                                    "height": {
                                      "type": "string",
                                      "format": "int64"
                                    },
                                    "time": {
                                      "type": "string",
                                      "format": "date-time"
                                    },
                                    "last_block_id": {
                                      "title": "BlockID",
                                      "type": "object",
                                      "properties": {
                                        "hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "part_set_header": {
                                          "title": "PartsetHeader",
                                          "type": "object",
                                          "properties": {
                                            "total": {
                                              "type": "integer",
                                              "format": "int64"
                                            },
                                            "hash": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "last_commit_hash": {
                                      "title": "hashes of block data",
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "data_hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "validators_hash": {
                                      "title": "hashes from the app output from the prev block",
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "next_validators_hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "consensus_hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "app_hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "last_results_hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "evidence_hash": {
                                      "title": "consensus info",
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "proposer_address": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  },
                                  "description": "Header defines the structure of a block header."
                                },
                                "commit": {
                                  "type": "object",
                                  "properties": {
                                    "height": {
                                      "type": "string",
                                      "format": "int64"
                                    },
                                    "round": {
                                      "type": "integer",
                                      "format": "int32"
                                    },
                                    "block_id": {
                                      "title": "BlockID",
                                      "type": "object",
                                      "properties": {
                                        "hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "part_set_header": {
                                          "title": "PartsetHeader",
                                          "type": "object",
                                          "properties": {
                                            "total": {
                                              "type": "integer",
                                              "format": "int64"
                                            },
                                            "hash": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "signatures": {
                                      "type": "array",
                                      "items": {
                                        "type": "object",
                                        "properties": {
                                          "block_id_flag": {
                                            "title": "BlockIdFlag indicates which BlockID the signature is for",
                                            "type": "string",
                                            "default": "BLOCK_ID_FLAG_UNKNOWN",
                                            "enum": [
                                              "BLOCK_ID_FLAG_UNKNOWN",
                                              "BLOCK_ID_FLAG_ABSENT",
                                              "BLOCK_ID_FLAG_COMMIT",
                                              "BLOCK_ID_FLAG_NIL"
                                            ]
                                          },
                                          "validator_address": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "timestamp": {
                                            "type": "string",
                                            "format": "date-time"
                                          },
                                          "signature": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          }
                                        },
                                        "description": "CommitSig is a part of the Vote included in a Commit."
                                      }
                                    }
                                  },
                                  "description": "Commit contains the evidence that a block was committed by a set of validators."
                                }
                              }
                            },
                            "validator_set": {
                              "type": "object",
                              "properties": {
                                "validators": {
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "address": {
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "pub_key": {
                                        "title": "PublicKey defines the keys available for use with Validators",
                                        "type": "object",
                                        "properties": {
                                          "ed25519": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "secp256k1": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          }
                                        }
                                      },
                                      "voting_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "proposer_priority": {
                                        "type": "string",
                                        "format": "int64"
                                      }
                                    }
                                  }
                                },
                                "proposer": {
                                  "type": "object",
                                  "properties": {
                                    "address": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "pub_key": {
                                      "title": "PublicKey defines the keys available for use with Validators",
                                      "type": "object",
                                      "properties": {
                                        "ed25519": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "secp256k1": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      }
                                    },
                                    "voting_power": {
                                      "type": "string",
                                      "format": "int64"
                                    },
                                    "proposer_priority": {
                                      "type": "string",
                                      "format": "int64"
                                    }
                                  }
                                },
                                "total_voting_power": {
                                  "type": "string",
                                  "format": "int64"
                                }
                              }
                            }
                          }
                        },
                        "common_height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "byzantine_validators": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "address": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "format": "byte"
                              },
                              "pub_key": {
                                "title": "PublicKey defines the keys available for use with Validators",
                                "type": "object",
                                "properties": {
                                  "ed25519": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "secp256k1": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  }
                                }
                              },
                              "voting_power": {
                                "type": "string",
                                "format": "int64"
                              },
                              "proposer_priority": {
                                "type": "string",
                                "format": "int64"
                              }
                            }
                          }
                        },
                        "total_voting_power": {
                          "type": "string",
                          "format": "int64"
                        },
                        "timestamp": {
                          "type": "string",
                          "format": "date-time"
                        }
                      },
                      "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                    }
                  }
                }
              }
            }
          },
          "last_commit": {
            "type": "object",
            "properties": {
              "height": {
                "type": "string",
                "format": "int64"
              },
              "round": {
                "type": "integer",
                "format": "int32"
              },
              "block_id": {
                "title": "BlockID",
                "type": "object",
                "properties": {
                  "hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "part_set_header": {
                    "title": "PartsetHeader",
                    "type": "object",
                    "properties": {
                      "total": {
                        "type": "integer",
                        "format": "int64"
                      },
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              },
              "signatures": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "block_id_flag": {
                      "title": "BlockIdFlag indicates which BlockID the signature is for",
                      "type": "string",
                      "default": "BLOCK_ID_FLAG_UNKNOWN",
                      "enum": [
                        "BLOCK_ID_FLAG_UNKNOWN",
                        "BLOCK_ID_FLAG_ABSENT",
                        "BLOCK_ID_FLAG_COMMIT",
                        "BLOCK_ID_FLAG_NIL"
                      ]
                    },
                    "validator_address": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "timestamp": {
                      "type": "string",
                      "format": "date-time"
                    },
                    "signature": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "description": "CommitSig is a part of the Vote included in a Commit."
                }
              }
            },
            "description": "Commit contains the evidence that a block was committed by a set of validators."
          }
        }
      },
      "tendermint.types.BlockIDFlag": {
        "title": "BlockIdFlag indicates which BlockID the signature is for",
        "type": "string",
        "default": "BLOCK_ID_FLAG_UNKNOWN",
        "enum": [
          "BLOCK_ID_FLAG_UNKNOWN",
          "BLOCK_ID_FLAG_ABSENT",
          "BLOCK_ID_FLAG_COMMIT",
          "BLOCK_ID_FLAG_NIL"
        ]
      },
      "tendermint.types.Commit": {
        "type": "object",
        "properties": {
          "height": {
            "type": "string",
            "format": "int64"
          },
          "round": {
            "type": "integer",
            "format": "int32"
          },
          "block_id": {
            "title": "BlockID",
            "type": "object",
            "properties": {
              "hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "part_set_header": {
                "title": "PartsetHeader",
                "type": "object",
                "properties": {
                  "total": {
                    "type": "integer",
                    "format": "int64"
                  },
                  "hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  }
                }
              }
            }
          },
          "signatures": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "block_id_flag": {
                  "title": "BlockIdFlag indicates which BlockID the signature is for",
                  "type": "string",
                  "default": "BLOCK_ID_FLAG_UNKNOWN",
                  "enum": [
                    "BLOCK_ID_FLAG_UNKNOWN",
                    "BLOCK_ID_FLAG_ABSENT",
                    "BLOCK_ID_FLAG_COMMIT",
                    "BLOCK_ID_FLAG_NIL"
                  ]
                },
                "validator_address": {
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "format": "byte"
                },
                "timestamp": {
                  "type": "string",
                  "format": "date-time"
                },
                "signature": {
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "CommitSig is a part of the Vote included in a Commit."
            }
          }
        },
        "description": "Commit contains the evidence that a block was committed by a set of validators."
      },
      "tendermint.types.CommitSig": {
        "type": "object",
        "properties": {
          "block_id_flag": {
            "title": "BlockIdFlag indicates which BlockID the signature is for",
            "type": "string",
            "default": "BLOCK_ID_FLAG_UNKNOWN",
            "enum": [
              "BLOCK_ID_FLAG_UNKNOWN",
              "BLOCK_ID_FLAG_ABSENT",
              "BLOCK_ID_FLAG_COMMIT",
              "BLOCK_ID_FLAG_NIL"
            ]
          },
          "validator_address": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time"
          },
          "signature": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          }
        },
        "description": "CommitSig is a part of the Vote included in a Commit."
      },
      "tendermint.types.Data": {
        "title": "Data contains the set of transactions included in the block",
        "type": "object",
        "properties": {
          "txs": {
            "type": "array",
            "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs.",
            "items": {
              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
              "type": "string",
              "format": "byte"
            }
          }
        }
      },
      "tendermint.types.DuplicateVoteEvidence": {
        "type": "object",
        "properties": {
          "vote_a": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                "enum": [
                  "SIGNED_MSG_TYPE_UNKNOWN",
                  "SIGNED_MSG_TYPE_PREVOTE",
                  "SIGNED_MSG_TYPE_PRECOMMIT",
                  "SIGNED_MSG_TYPE_PROPOSAL"
                ]
              },
              "height": {
                "type": "string",
                "format": "int64"
              },
              "round": {
                "type": "integer",
                "format": "int32"
              },
              "block_id": {
                "title": "BlockID",
                "type": "object",
                "properties": {
                  "hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "part_set_header": {
                    "title": "PartsetHeader",
                    "type": "object",
                    "properties": {
                      "total": {
                        "type": "integer",
                        "format": "int64"
                      },
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              },
              "timestamp": {
                "type": "string",
                "format": "date-time"
              },
              "validator_address": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "validator_index": {
                "type": "integer",
                "format": "int32"
              },
              "signature": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                "format": "byte"
              },
              "extension": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                "format": "byte"
              },
              "extension_signature": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                "format": "byte"
              }
            },
            "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
          },
          "vote_b": {
            "type": "object",
            "properties": {
              "type": {
                "type": "string",
                "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                "default": "SIGNED_MSG_TYPE_UNKNOWN",
                "enum": [
                  "SIGNED_MSG_TYPE_UNKNOWN",
                  "SIGNED_MSG_TYPE_PREVOTE",
                  "SIGNED_MSG_TYPE_PRECOMMIT",
                  "SIGNED_MSG_TYPE_PROPOSAL"
                ]
              },
              "height": {
                "type": "string",
                "format": "int64"
              },
              "round": {
                "type": "integer",
                "format": "int32"
              },
              "block_id": {
                "title": "BlockID",
                "type": "object",
                "properties": {
                  "hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "part_set_header": {
                    "title": "PartsetHeader",
                    "type": "object",
                    "properties": {
                      "total": {
                        "type": "integer",
                        "format": "int64"
                      },
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              },
              "timestamp": {
                "type": "string",
                "format": "date-time"
              },
              "validator_address": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "validator_index": {
                "type": "integer",
                "format": "int32"
              },
              "signature": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                "format": "byte"
              },
              "extension": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                "format": "byte"
              },
              "extension_signature": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                "format": "byte"
              }
            },
            "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
          },
          "total_voting_power": {
            "type": "string",
            "format": "int64"
          },
          "validator_power": {
            "type": "string",
            "format": "int64"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time"
          }
        },
        "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
      },
      "tendermint.types.Evidence": {
        "type": "object",
        "properties": {
          "duplicate_vote_evidence": {
            "type": "object",
            "properties": {
              "vote_a": {
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string",
                    "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                    "default": "SIGNED_MSG_TYPE_UNKNOWN",
                    "enum": [
                      "SIGNED_MSG_TYPE_UNKNOWN",
                      "SIGNED_MSG_TYPE_PREVOTE",
                      "SIGNED_MSG_TYPE_PRECOMMIT",
                      "SIGNED_MSG_TYPE_PROPOSAL"
                    ]
                  },
                  "height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "round": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "block_id": {
                    "title": "BlockID",
                    "type": "object",
                    "properties": {
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "part_set_header": {
                        "title": "PartsetHeader",
                        "type": "object",
                        "properties": {
                          "total": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  },
                  "timestamp": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "validator_address": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "validator_index": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "signature": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                    "format": "byte"
                  },
                  "extension": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                    "format": "byte"
                  },
                  "extension_signature": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                    "format": "byte"
                  }
                },
                "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
              },
              "vote_b": {
                "type": "object",
                "properties": {
                  "type": {
                    "type": "string",
                    "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                    "default": "SIGNED_MSG_TYPE_UNKNOWN",
                    "enum": [
                      "SIGNED_MSG_TYPE_UNKNOWN",
                      "SIGNED_MSG_TYPE_PREVOTE",
                      "SIGNED_MSG_TYPE_PRECOMMIT",
                      "SIGNED_MSG_TYPE_PROPOSAL"
                    ]
                  },
                  "height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "round": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "block_id": {
                    "title": "BlockID",
                    "type": "object",
                    "properties": {
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "part_set_header": {
                        "title": "PartsetHeader",
                        "type": "object",
                        "properties": {
                          "total": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  },
                  "timestamp": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "validator_address": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "validator_index": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "signature": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                    "format": "byte"
                  },
                  "extension": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                    "format": "byte"
                  },
                  "extension_signature": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                    "format": "byte"
                  }
                },
                "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
              },
              "total_voting_power": {
                "type": "string",
                "format": "int64"
              },
              "validator_power": {
                "type": "string",
                "format": "int64"
              },
              "timestamp": {
                "type": "string",
                "format": "date-time"
              }
            },
            "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
          },
          "light_client_attack_evidence": {
            "type": "object",
            "properties": {
              "conflicting_block": {
                "type": "object",
                "properties": {
                  "signed_header": {
                    "type": "object",
                    "properties": {
                      "header": {
                        "type": "object",
                        "properties": {
                          "version": {
                            "title": "basic block info",
                            "type": "object",
                            "properties": {
                              "block": {
                                "type": "string",
                                "format": "uint64"
                              },
                              "app": {
                                "type": "string",
                                "format": "uint64"
                              }
                            },
                            "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                          },
                          "chain_id": {
                            "type": "string"
                          },
                          "height": {
                            "type": "string",
                            "format": "int64"
                          },
                          "time": {
                            "type": "string",
                            "format": "date-time"
                          },
                          "last_block_id": {
                            "title": "BlockID",
                            "type": "object",
                            "properties": {
                              "hash": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "format": "byte"
                              },
                              "part_set_header": {
                                "title": "PartsetHeader",
                                "type": "object",
                                "properties": {
                                  "total": {
                                    "type": "integer",
                                    "format": "int64"
                                  },
                                  "hash": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  }
                                }
                              }
                            }
                          },
                          "last_commit_hash": {
                            "title": "hashes of block data",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          },
                          "data_hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          },
                          "validators_hash": {
                            "title": "hashes from the app output from the prev block",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          },
                          "next_validators_hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          },
                          "consensus_hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          },
                          "app_hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          },
                          "last_results_hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          },
                          "evidence_hash": {
                            "title": "consensus info",
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          },
                          "proposer_address": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        },
                        "description": "Header defines the structure of a block header."
                      },
                      "commit": {
                        "type": "object",
                        "properties": {
                          "height": {
                            "type": "string",
                            "format": "int64"
                          },
                          "round": {
                            "type": "integer",
                            "format": "int32"
                          },
                          "block_id": {
                            "title": "BlockID",
                            "type": "object",
                            "properties": {
                              "hash": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "format": "byte"
                              },
                              "part_set_header": {
                                "title": "PartsetHeader",
                                "type": "object",
                                "properties": {
                                  "total": {
                                    "type": "integer",
                                    "format": "int64"
                                  },
                                  "hash": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  }
                                }
                              }
                            }
                          },
                          "signatures": {
                            "type": "array",
                            "items": {
                              "type": "object",
                              "properties": {
                                "block_id_flag": {
                                  "title": "BlockIdFlag indicates which BlockID the signature is for",
                                  "type": "string",
                                  "default": "BLOCK_ID_FLAG_UNKNOWN",
                                  "enum": [
                                    "BLOCK_ID_FLAG_UNKNOWN",
                                    "BLOCK_ID_FLAG_ABSENT",
                                    "BLOCK_ID_FLAG_COMMIT",
                                    "BLOCK_ID_FLAG_NIL"
                                  ]
                                },
                                "validator_address": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "timestamp": {
                                  "type": "string",
                                  "format": "date-time"
                                },
                                "signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "description": "CommitSig is a part of the Vote included in a Commit."
                            }
                          }
                        },
                        "description": "Commit contains the evidence that a block was committed by a set of validators."
                      }
                    }
                  },
                  "validator_set": {
                    "type": "object",
                    "properties": {
                      "validators": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "address": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "pub_key": {
                              "title": "PublicKey defines the keys available for use with Validators",
                              "type": "object",
                              "properties": {
                                "ed25519": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "secp256k1": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                }
                              }
                            },
                            "voting_power": {
                              "type": "string",
                              "format": "int64"
                            },
                            "proposer_priority": {
                              "type": "string",
                              "format": "int64"
                            }
                          }
                        }
                      },
                      "proposer": {
                        "type": "object",
                        "properties": {
                          "address": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          },
                          "pub_key": {
                            "title": "PublicKey defines the keys available for use with Validators",
                            "type": "object",
                            "properties": {
                              "ed25519": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "format": "byte"
                              },
                              "secp256k1": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "format": "byte"
                              }
                            }
                          },
                          "voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "proposer_priority": {
                            "type": "string",
                            "format": "int64"
                          }
                        }
                      },
                      "total_voting_power": {
                        "type": "string",
                        "format": "int64"
                      }
                    }
                  }
                }
              },
              "common_height": {
                "type": "string",
                "format": "int64"
              },
              "byzantine_validators": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "pub_key": {
                      "title": "PublicKey defines the keys available for use with Validators",
                      "type": "object",
                      "properties": {
                        "ed25519": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        },
                        "secp256k1": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        }
                      }
                    },
                    "voting_power": {
                      "type": "string",
                      "format": "int64"
                    },
                    "proposer_priority": {
                      "type": "string",
                      "format": "int64"
                    }
                  }
                }
              },
              "total_voting_power": {
                "type": "string",
                "format": "int64"
              },
              "timestamp": {
                "type": "string",
                "format": "date-time"
              }
            },
            "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
          }
        }
      },
      "tendermint.types.EvidenceList": {
        "type": "object",
        "properties": {
          "evidence": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "duplicate_vote_evidence": {
                  "type": "object",
                  "properties": {
                    "vote_a": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                          "default": "SIGNED_MSG_TYPE_UNKNOWN",
                          "enum": [
                            "SIGNED_MSG_TYPE_UNKNOWN",
                            "SIGNED_MSG_TYPE_PREVOTE",
                            "SIGNED_MSG_TYPE_PRECOMMIT",
                            "SIGNED_MSG_TYPE_PROPOSAL"
                          ]
                        },
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "round": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "block_id": {
                          "title": "BlockID",
                          "type": "object",
                          "properties": {
                            "hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "title": "PartsetHeader",
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                }
                              }
                            }
                          }
                        },
                        "timestamp": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "validator_address": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        },
                        "validator_index": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "signature": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                          "format": "byte"
                        },
                        "extension": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                          "format": "byte"
                        },
                        "extension_signature": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                          "format": "byte"
                        }
                      },
                      "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                    },
                    "vote_b": {
                      "type": "object",
                      "properties": {
                        "type": {
                          "type": "string",
                          "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                          "default": "SIGNED_MSG_TYPE_UNKNOWN",
                          "enum": [
                            "SIGNED_MSG_TYPE_UNKNOWN",
                            "SIGNED_MSG_TYPE_PREVOTE",
                            "SIGNED_MSG_TYPE_PRECOMMIT",
                            "SIGNED_MSG_TYPE_PROPOSAL"
                          ]
                        },
                        "height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "round": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "block_id": {
                          "title": "BlockID",
                          "type": "object",
                          "properties": {
                            "hash": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "part_set_header": {
                              "title": "PartsetHeader",
                              "type": "object",
                              "properties": {
                                "total": {
                                  "type": "integer",
                                  "format": "int64"
                                },
                                "hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                }
                              }
                            }
                          }
                        },
                        "timestamp": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "validator_address": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        },
                        "validator_index": {
                          "type": "integer",
                          "format": "int32"
                        },
                        "signature": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                          "format": "byte"
                        },
                        "extension": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                          "format": "byte"
                        },
                        "extension_signature": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                          "format": "byte"
                        }
                      },
                      "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                    },
                    "total_voting_power": {
                      "type": "string",
                      "format": "int64"
                    },
                    "validator_power": {
                      "type": "string",
                      "format": "int64"
                    },
                    "timestamp": {
                      "type": "string",
                      "format": "date-time"
                    }
                  },
                  "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                },
                "light_client_attack_evidence": {
                  "type": "object",
                  "properties": {
                    "conflicting_block": {
                      "type": "object",
                      "properties": {
                        "signed_header": {
                          "type": "object",
                          "properties": {
                            "header": {
                              "type": "object",
                              "properties": {
                                "version": {
                                  "title": "basic block info",
                                  "type": "object",
                                  "properties": {
                                    "block": {
                                      "type": "string",
                                      "format": "uint64"
                                    },
                                    "app": {
                                      "type": "string",
                                      "format": "uint64"
                                    }
                                  },
                                  "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                },
                                "chain_id": {
                                  "type": "string"
                                },
                                "height": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "time": {
                                  "type": "string",
                                  "format": "date-time"
                                },
                                "last_block_id": {
                                  "title": "BlockID",
                                  "type": "object",
                                  "properties": {
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "part_set_header": {
                                      "title": "PartsetHeader",
                                      "type": "object",
                                      "properties": {
                                        "total": {
                                          "type": "integer",
                                          "format": "int64"
                                        },
                                        "hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      }
                                    }
                                  }
                                },
                                "last_commit_hash": {
                                  "title": "hashes of block data",
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "data_hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "validators_hash": {
                                  "title": "hashes from the app output from the prev block",
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "next_validators_hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "consensus_hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "app_hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "last_results_hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "evidence_hash": {
                                  "title": "consensus info",
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "proposer_address": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                }
                              },
                              "description": "Header defines the structure of a block header."
                            },
                            "commit": {
                              "type": "object",
                              "properties": {
                                "height": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "round": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "block_id": {
                                  "title": "BlockID",
                                  "type": "object",
                                  "properties": {
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "part_set_header": {
                                      "title": "PartsetHeader",
                                      "type": "object",
                                      "properties": {
                                        "total": {
                                          "type": "integer",
                                          "format": "int64"
                                        },
                                        "hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      }
                                    }
                                  }
                                },
                                "signatures": {
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "block_id_flag": {
                                        "title": "BlockIdFlag indicates which BlockID the signature is for",
                                        "type": "string",
                                        "default": "BLOCK_ID_FLAG_UNKNOWN",
                                        "enum": [
                                          "BLOCK_ID_FLAG_UNKNOWN",
                                          "BLOCK_ID_FLAG_ABSENT",
                                          "BLOCK_ID_FLAG_COMMIT",
                                          "BLOCK_ID_FLAG_NIL"
                                        ]
                                      },
                                      "validator_address": {
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "timestamp": {
                                        "type": "string",
                                        "format": "date-time"
                                      },
                                      "signature": {
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    },
                                    "description": "CommitSig is a part of the Vote included in a Commit."
                                  }
                                }
                              },
                              "description": "Commit contains the evidence that a block was committed by a set of validators."
                            }
                          }
                        },
                        "validator_set": {
                          "type": "object",
                          "properties": {
                            "validators": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "address": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "pub_key": {
                                    "title": "PublicKey defines the keys available for use with Validators",
                                    "type": "object",
                                    "properties": {
                                      "ed25519": {
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "secp256k1": {
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    }
                                  },
                                  "voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "proposer_priority": {
                                    "type": "string",
                                    "format": "int64"
                                  }
                                }
                              }
                            },
                            "proposer": {
                              "type": "object",
                              "properties": {
                                "address": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "pub_key": {
                                  "title": "PublicKey defines the keys available for use with Validators",
                                  "type": "object",
                                  "properties": {
                                    "ed25519": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "secp256k1": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  }
                                },
                                "voting_power": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "proposer_priority": {
                                  "type": "string",
                                  "format": "int64"
                                }
                              }
                            },
                            "total_voting_power": {
                              "type": "string",
                              "format": "int64"
                            }
                          }
                        }
                      }
                    },
                    "common_height": {
                      "type": "string",
                      "format": "int64"
                    },
                    "byzantine_validators": {
                      "type": "array",
                      "items": {
                        "type": "object",
                        "properties": {
                          "address": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          },
                          "pub_key": {
                            "title": "PublicKey defines the keys available for use with Validators",
                            "type": "object",
                            "properties": {
                              "ed25519": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "format": "byte"
                              },
                              "secp256k1": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "format": "byte"
                              }
                            }
                          },
                          "voting_power": {
                            "type": "string",
                            "format": "int64"
                          },
                          "proposer_priority": {
                            "type": "string",
                            "format": "int64"
                          }
                        }
                      }
                    },
                    "total_voting_power": {
                      "type": "string",
                      "format": "int64"
                    },
                    "timestamp": {
                      "type": "string",
                      "format": "date-time"
                    }
                  },
                  "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                }
              }
            }
          }
        }
      },
      "tendermint.types.LightBlock": {
        "type": "object",
        "properties": {
          "signed_header": {
            "type": "object",
            "properties": {
              "header": {
                "type": "object",
                "properties": {
                  "version": {
                    "title": "basic block info",
                    "type": "object",
                    "properties": {
                      "block": {
                        "type": "string",
                        "format": "uint64"
                      },
                      "app": {
                        "type": "string",
                        "format": "uint64"
                      }
                    },
                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                  },
                  "chain_id": {
                    "type": "string"
                  },
                  "height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "time": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "last_block_id": {
                    "title": "BlockID",
                    "type": "object",
                    "properties": {
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "part_set_header": {
                        "title": "PartsetHeader",
                        "type": "object",
                        "properties": {
                          "total": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  },
                  "last_commit_hash": {
                    "title": "hashes of block data",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "data_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "validators_hash": {
                    "title": "hashes from the app output from the prev block",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "next_validators_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "consensus_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "app_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "last_results_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "evidence_hash": {
                    "title": "consensus info",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "proposer_address": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  }
                },
                "description": "Header defines the structure of a block header."
              },
              "commit": {
                "type": "object",
                "properties": {
                  "height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "round": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "block_id": {
                    "title": "BlockID",
                    "type": "object",
                    "properties": {
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "part_set_header": {
                        "title": "PartsetHeader",
                        "type": "object",
                        "properties": {
                          "total": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  },
                  "signatures": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "block_id_flag": {
                          "title": "BlockIdFlag indicates which BlockID the signature is for",
                          "type": "string",
                          "default": "BLOCK_ID_FLAG_UNKNOWN",
                          "enum": [
                            "BLOCK_ID_FLAG_UNKNOWN",
                            "BLOCK_ID_FLAG_ABSENT",
                            "BLOCK_ID_FLAG_COMMIT",
                            "BLOCK_ID_FLAG_NIL"
                          ]
                        },
                        "validator_address": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        },
                        "timestamp": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "signature": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "description": "CommitSig is a part of the Vote included in a Commit."
                    }
                  }
                },
                "description": "Commit contains the evidence that a block was committed by a set of validators."
              }
            }
          },
          "validator_set": {
            "type": "object",
            "properties": {
              "validators": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "address": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "pub_key": {
                      "title": "PublicKey defines the keys available for use with Validators",
                      "type": "object",
                      "properties": {
                        "ed25519": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        },
                        "secp256k1": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        }
                      }
                    },
                    "voting_power": {
                      "type": "string",
                      "format": "int64"
                    },
                    "proposer_priority": {
                      "type": "string",
                      "format": "int64"
                    }
                  }
                }
              },
              "proposer": {
                "type": "object",
                "properties": {
                  "address": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "pub_key": {
                    "title": "PublicKey defines the keys available for use with Validators",
                    "type": "object",
                    "properties": {
                      "ed25519": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "secp256k1": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  },
                  "voting_power": {
                    "type": "string",
                    "format": "int64"
                  },
                  "proposer_priority": {
                    "type": "string",
                    "format": "int64"
                  }
                }
              },
              "total_voting_power": {
                "type": "string",
                "format": "int64"
              }
            }
          }
        }
      },
      "tendermint.types.LightClientAttackEvidence": {
        "type": "object",
        "properties": {
          "conflicting_block": {
            "type": "object",
            "properties": {
              "signed_header": {
                "type": "object",
                "properties": {
                  "header": {
                    "type": "object",
                    "properties": {
                      "version": {
                        "title": "basic block info",
                        "type": "object",
                        "properties": {
                          "block": {
                            "type": "string",
                            "format": "uint64"
                          },
                          "app": {
                            "type": "string",
                            "format": "uint64"
                          }
                        },
                        "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                      },
                      "chain_id": {
                        "type": "string"
                      },
                      "height": {
                        "type": "string",
                        "format": "int64"
                      },
                      "time": {
                        "type": "string",
                        "format": "date-time"
                      },
                      "last_block_id": {
                        "title": "BlockID",
                        "type": "object",
                        "properties": {
                          "hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          },
                          "part_set_header": {
                            "title": "PartsetHeader",
                            "type": "object",
                            "properties": {
                              "total": {
                                "type": "integer",
                                "format": "int64"
                              },
                              "hash": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "format": "byte"
                              }
                            }
                          }
                        }
                      },
                      "last_commit_hash": {
                        "title": "hashes of block data",
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "data_hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "validators_hash": {
                        "title": "hashes from the app output from the prev block",
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "next_validators_hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "consensus_hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "app_hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "last_results_hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "evidence_hash": {
                        "title": "consensus info",
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "proposer_address": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      }
                    },
                    "description": "Header defines the structure of a block header."
                  },
                  "commit": {
                    "type": "object",
                    "properties": {
                      "height": {
                        "type": "string",
                        "format": "int64"
                      },
                      "round": {
                        "type": "integer",
                        "format": "int32"
                      },
                      "block_id": {
                        "title": "BlockID",
                        "type": "object",
                        "properties": {
                          "hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          },
                          "part_set_header": {
                            "title": "PartsetHeader",
                            "type": "object",
                            "properties": {
                              "total": {
                                "type": "integer",
                                "format": "int64"
                              },
                              "hash": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "format": "byte"
                              }
                            }
                          }
                        }
                      },
                      "signatures": {
                        "type": "array",
                        "items": {
                          "type": "object",
                          "properties": {
                            "block_id_flag": {
                              "title": "BlockIdFlag indicates which BlockID the signature is for",
                              "type": "string",
                              "default": "BLOCK_ID_FLAG_UNKNOWN",
                              "enum": [
                                "BLOCK_ID_FLAG_UNKNOWN",
                                "BLOCK_ID_FLAG_ABSENT",
                                "BLOCK_ID_FLAG_COMMIT",
                                "BLOCK_ID_FLAG_NIL"
                              ]
                            },
                            "validator_address": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "timestamp": {
                              "type": "string",
                              "format": "date-time"
                            },
                            "signature": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            }
                          },
                          "description": "CommitSig is a part of the Vote included in a Commit."
                        }
                      }
                    },
                    "description": "Commit contains the evidence that a block was committed by a set of validators."
                  }
                }
              },
              "validator_set": {
                "type": "object",
                "properties": {
                  "validators": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "address": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        },
                        "pub_key": {
                          "title": "PublicKey defines the keys available for use with Validators",
                          "type": "object",
                          "properties": {
                            "ed25519": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "secp256k1": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            }
                          }
                        },
                        "voting_power": {
                          "type": "string",
                          "format": "int64"
                        },
                        "proposer_priority": {
                          "type": "string",
                          "format": "int64"
                        }
                      }
                    }
                  },
                  "proposer": {
                    "type": "object",
                    "properties": {
                      "address": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "pub_key": {
                        "title": "PublicKey defines the keys available for use with Validators",
                        "type": "object",
                        "properties": {
                          "ed25519": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          },
                          "secp256k1": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      },
                      "voting_power": {
                        "type": "string",
                        "format": "int64"
                      },
                      "proposer_priority": {
                        "type": "string",
                        "format": "int64"
                      }
                    }
                  },
                  "total_voting_power": {
                    "type": "string",
                    "format": "int64"
                  }
                }
              }
            }
          },
          "common_height": {
            "type": "string",
            "format": "int64"
          },
          "byzantine_validators": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "format": "byte"
                },
                "pub_key": {
                  "title": "PublicKey defines the keys available for use with Validators",
                  "type": "object",
                  "properties": {
                    "ed25519": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "secp256k1": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    }
                  }
                },
                "voting_power": {
                  "type": "string",
                  "format": "int64"
                },
                "proposer_priority": {
                  "type": "string",
                  "format": "int64"
                }
              }
            }
          },
          "total_voting_power": {
            "type": "string",
            "format": "int64"
          },
          "timestamp": {
            "type": "string",
            "format": "date-time"
          }
        },
        "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
      },
      "tendermint.types.SignedHeader": {
        "type": "object",
        "properties": {
          "header": {
            "type": "object",
            "properties": {
              "version": {
                "title": "basic block info",
                "type": "object",
                "properties": {
                  "block": {
                    "type": "string",
                    "format": "uint64"
                  },
                  "app": {
                    "type": "string",
                    "format": "uint64"
                  }
                },
                "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
              },
              "chain_id": {
                "type": "string"
              },
              "height": {
                "type": "string",
                "format": "int64"
              },
              "time": {
                "type": "string",
                "format": "date-time"
              },
              "last_block_id": {
                "title": "BlockID",
                "type": "object",
                "properties": {
                  "hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "part_set_header": {
                    "title": "PartsetHeader",
                    "type": "object",
                    "properties": {
                      "total": {
                        "type": "integer",
                        "format": "int64"
                      },
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              },
              "last_commit_hash": {
                "title": "hashes of block data",
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "data_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "validators_hash": {
                "title": "hashes from the app output from the prev block",
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "next_validators_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "consensus_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "app_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "last_results_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "evidence_hash": {
                "title": "consensus info",
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "proposer_address": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              }
            },
            "description": "Header defines the structure of a block header."
          },
          "commit": {
            "type": "object",
            "properties": {
              "height": {
                "type": "string",
                "format": "int64"
              },
              "round": {
                "type": "integer",
                "format": "int32"
              },
              "block_id": {
                "title": "BlockID",
                "type": "object",
                "properties": {
                  "hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "part_set_header": {
                    "title": "PartsetHeader",
                    "type": "object",
                    "properties": {
                      "total": {
                        "type": "integer",
                        "format": "int64"
                      },
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              },
              "signatures": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "block_id_flag": {
                      "title": "BlockIdFlag indicates which BlockID the signature is for",
                      "type": "string",
                      "default": "BLOCK_ID_FLAG_UNKNOWN",
                      "enum": [
                        "BLOCK_ID_FLAG_UNKNOWN",
                        "BLOCK_ID_FLAG_ABSENT",
                        "BLOCK_ID_FLAG_COMMIT",
                        "BLOCK_ID_FLAG_NIL"
                      ]
                    },
                    "validator_address": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "timestamp": {
                      "type": "string",
                      "format": "date-time"
                    },
                    "signature": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "description": "CommitSig is a part of the Vote included in a Commit."
                }
              }
            },
            "description": "Commit contains the evidence that a block was committed by a set of validators."
          }
        }
      },
      "tendermint.types.SignedMsgType": {
        "type": "string",
        "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
        "default": "SIGNED_MSG_TYPE_UNKNOWN",
        "enum": [
          "SIGNED_MSG_TYPE_UNKNOWN",
          "SIGNED_MSG_TYPE_PREVOTE",
          "SIGNED_MSG_TYPE_PRECOMMIT",
          "SIGNED_MSG_TYPE_PROPOSAL"
        ]
      },
      "tendermint.types.Validator": {
        "type": "object",
        "properties": {
          "address": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "pub_key": {
            "title": "PublicKey defines the keys available for use with Validators",
            "type": "object",
            "properties": {
              "ed25519": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "secp256k1": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              }
            }
          },
          "voting_power": {
            "type": "string",
            "format": "int64"
          },
          "proposer_priority": {
            "type": "string",
            "format": "int64"
          }
        }
      },
      "tendermint.types.ValidatorSet": {
        "type": "object",
        "properties": {
          "validators": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "format": "byte"
                },
                "pub_key": {
                  "title": "PublicKey defines the keys available for use with Validators",
                  "type": "object",
                  "properties": {
                    "ed25519": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "secp256k1": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    }
                  }
                },
                "voting_power": {
                  "type": "string",
                  "format": "int64"
                },
                "proposer_priority": {
                  "type": "string",
                  "format": "int64"
                }
              }
            }
          },
          "proposer": {
            "type": "object",
            "properties": {
              "address": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "pub_key": {
                "title": "PublicKey defines the keys available for use with Validators",
                "type": "object",
                "properties": {
                  "ed25519": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "secp256k1": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  }
                }
              },
              "voting_power": {
                "type": "string",
                "format": "int64"
              },
              "proposer_priority": {
                "type": "string",
                "format": "int64"
              }
            }
          },
          "total_voting_power": {
            "type": "string",
            "format": "int64"
          }
        }
      },
      "tendermint.types.Vote": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string",
            "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
            "default": "SIGNED_MSG_TYPE_UNKNOWN",
            "enum": [
              "SIGNED_MSG_TYPE_UNKNOWN",
              "SIGNED_MSG_TYPE_PREVOTE",
              "SIGNED_MSG_TYPE_PRECOMMIT",
              "SIGNED_MSG_TYPE_PROPOSAL"
            ]
          },
          "height": {
            "type": "string",
            "format": "int64"
          },
          "round": {
            "type": "integer",
            "format": "int32"
          },
          "block_id": {
            "title": "BlockID",
            "type": "object",
            "properties": {
              "hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "part_set_header": {
                "title": "PartsetHeader",
                "type": "object",
                "properties": {
                  "total": {
                    "type": "integer",
                    "format": "int64"
                  },
                  "hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  }
                }
              }
            }
          },
          "timestamp": {
            "type": "string",
            "format": "date-time"
          },
          "validator_address": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "validator_index": {
            "type": "integer",
            "format": "int32"
          },
          "signature": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
            "format": "byte"
          },
          "extension": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
            "format": "byte"
          },
          "extension_signature": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
            "format": "byte"
          }
        },
        "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
      },
      "cosmos.base.tendermint.v1beta1.ABCIQueryResponse": {
        "type": "object",
        "properties": {
          "code": {
            "type": "integer",
            "format": "int64"
          },
          "log": {
            "type": "string"
          },
          "info": {
            "type": "string"
          },
          "index": {
            "type": "string",
            "format": "int64"
          },
          "key": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "value": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "proof_ops": {
            "type": "object",
            "properties": {
              "ops": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "type": {
                      "type": "string"
                    },
                    "key": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "data": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "description": "ProofOp defines an operation used for calculating Merkle root. The data could\nbe arbitrary format, providing necessary data for example neighbouring node\nhash.\n\nNote: This type is a duplicate of the ProofOp proto type defined in Tendermint."
                }
              }
            },
            "description": "ProofOps is Merkle proof defined by the list of ProofOps.\n\nNote: This type is a duplicate of the ProofOps proto type defined in Tendermint."
          },
          "height": {
            "type": "string",
            "format": "int64"
          },
          "codespace": {
            "type": "string"
          }
        },
        "description": "ABCIQueryResponse defines the response structure for the ABCIQuery gRPC query.\n\nNote: This type is a duplicate of the ResponseQuery proto type defined in\nTendermint."
      },
      "cosmos.base.tendermint.v1beta1.Block": {
        "type": "object",
        "properties": {
          "header": {
            "type": "object",
            "properties": {
              "version": {
                "title": "basic block info",
                "type": "object",
                "properties": {
                  "block": {
                    "type": "string",
                    "format": "uint64"
                  },
                  "app": {
                    "type": "string",
                    "format": "uint64"
                  }
                },
                "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
              },
              "chain_id": {
                "type": "string"
              },
              "height": {
                "type": "string",
                "format": "int64"
              },
              "time": {
                "type": "string",
                "format": "date-time"
              },
              "last_block_id": {
                "title": "BlockID",
                "type": "object",
                "properties": {
                  "hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "part_set_header": {
                    "title": "PartsetHeader",
                    "type": "object",
                    "properties": {
                      "total": {
                        "type": "integer",
                        "format": "int64"
                      },
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              },
              "last_commit_hash": {
                "title": "hashes of block data",
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "data_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "validators_hash": {
                "title": "hashes from the app output from the prev block",
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "next_validators_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "consensus_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "app_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "last_results_hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "evidence_hash": {
                "title": "consensus info",
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "proposer_address": {
                "type": "string",
                "description": "proposer_address is the original block proposer address, formatted as a Bech32 string.\nIn Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string\nfor better UX."
              }
            },
            "description": "Header defines the structure of a Tendermint block header."
          },
          "data": {
            "title": "Data contains the set of transactions included in the block",
            "type": "object",
            "properties": {
              "txs": {
                "type": "array",
                "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs.",
                "items": {
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "format": "byte"
                }
              }
            }
          },
          "evidence": {
            "type": "object",
            "properties": {
              "evidence": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "duplicate_vote_evidence": {
                      "type": "object",
                      "properties": {
                        "vote_a": {
                          "type": "object",
                          "properties": {
                            "type": {
                              "type": "string",
                              "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                              "default": "SIGNED_MSG_TYPE_UNKNOWN",
                              "enum": [
                                "SIGNED_MSG_TYPE_UNKNOWN",
                                "SIGNED_MSG_TYPE_PREVOTE",
                                "SIGNED_MSG_TYPE_PRECOMMIT",
                                "SIGNED_MSG_TYPE_PROPOSAL"
                              ]
                            },
                            "height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "round": {
                              "type": "integer",
                              "format": "int32"
                            },
                            "block_id": {
                              "title": "BlockID",
                              "type": "object",
                              "properties": {
                                "hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "part_set_header": {
                                  "title": "PartsetHeader",
                                  "type": "object",
                                  "properties": {
                                    "total": {
                                      "type": "integer",
                                      "format": "int64"
                                    },
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  }
                                }
                              }
                            },
                            "timestamp": {
                              "type": "string",
                              "format": "date-time"
                            },
                            "validator_address": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "validator_index": {
                              "type": "integer",
                              "format": "int32"
                            },
                            "signature": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                              "format": "byte"
                            },
                            "extension": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                              "format": "byte"
                            },
                            "extension_signature": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                              "format": "byte"
                            }
                          },
                          "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                        },
                        "vote_b": {
                          "type": "object",
                          "properties": {
                            "type": {
                              "type": "string",
                              "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                              "default": "SIGNED_MSG_TYPE_UNKNOWN",
                              "enum": [
                                "SIGNED_MSG_TYPE_UNKNOWN",
                                "SIGNED_MSG_TYPE_PREVOTE",
                                "SIGNED_MSG_TYPE_PRECOMMIT",
                                "SIGNED_MSG_TYPE_PROPOSAL"
                              ]
                            },
                            "height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "round": {
                              "type": "integer",
                              "format": "int32"
                            },
                            "block_id": {
                              "title": "BlockID",
                              "type": "object",
                              "properties": {
                                "hash": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "part_set_header": {
                                  "title": "PartsetHeader",
                                  "type": "object",
                                  "properties": {
                                    "total": {
                                      "type": "integer",
                                      "format": "int64"
                                    },
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  }
                                }
                              }
                            },
                            "timestamp": {
                              "type": "string",
                              "format": "date-time"
                            },
                            "validator_address": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "format": "byte"
                            },
                            "validator_index": {
                              "type": "integer",
                              "format": "int32"
                            },
                            "signature": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                              "format": "byte"
                            },
                            "extension": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                              "format": "byte"
                            },
                            "extension_signature": {
                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                              "type": "string",
                              "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                              "format": "byte"
                            }
                          },
                          "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                        },
                        "total_voting_power": {
                          "type": "string",
                          "format": "int64"
                        },
                        "validator_power": {
                          "type": "string",
                          "format": "int64"
                        },
                        "timestamp": {
                          "type": "string",
                          "format": "date-time"
                        }
                      },
                      "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                    },
                    "light_client_attack_evidence": {
                      "type": "object",
                      "properties": {
                        "conflicting_block": {
                          "type": "object",
                          "properties": {
                            "signed_header": {
                              "type": "object",
                              "properties": {
                                "header": {
                                  "type": "object",
                                  "properties": {
                                    "version": {
                                      "title": "basic block info",
                                      "type": "object",
                                      "properties": {
                                        "block": {
                                          "type": "string",
                                          "format": "uint64"
                                        },
                                        "app": {
                                          "type": "string",
                                          "format": "uint64"
                                        }
                                      },
                                      "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                    },
                                    "chain_id": {
                                      "type": "string"
                                    },
                                    "height": {
                                      "type": "string",
                                      "format": "int64"
                                    },
                                    "time": {
                                      "type": "string",
                                      "format": "date-time"
                                    },
                                    "last_block_id": {
                                      "title": "BlockID",
                                      "type": "object",
                                      "properties": {
                                        "hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "part_set_header": {
                                          "title": "PartsetHeader",
                                          "type": "object",
                                          "properties": {
                                            "total": {
                                              "type": "integer",
                                              "format": "int64"
                                            },
                                            "hash": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "last_commit_hash": {
                                      "title": "hashes of block data",
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "data_hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "validators_hash": {
                                      "title": "hashes from the app output from the prev block",
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "next_validators_hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "consensus_hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "app_hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "last_results_hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "evidence_hash": {
                                      "title": "consensus info",
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "proposer_address": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    }
                                  },
                                  "description": "Header defines the structure of a block header."
                                },
                                "commit": {
                                  "type": "object",
                                  "properties": {
                                    "height": {
                                      "type": "string",
                                      "format": "int64"
                                    },
                                    "round": {
                                      "type": "integer",
                                      "format": "int32"
                                    },
                                    "block_id": {
                                      "title": "BlockID",
                                      "type": "object",
                                      "properties": {
                                        "hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "part_set_header": {
                                          "title": "PartsetHeader",
                                          "type": "object",
                                          "properties": {
                                            "total": {
                                              "type": "integer",
                                              "format": "int64"
                                            },
                                            "hash": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          }
                                        }
                                      }
                                    },
                                    "signatures": {
                                      "type": "array",
                                      "items": {
                                        "type": "object",
                                        "properties": {
                                          "block_id_flag": {
                                            "title": "BlockIdFlag indicates which BlockID the signature is for",
                                            "type": "string",
                                            "default": "BLOCK_ID_FLAG_UNKNOWN",
                                            "enum": [
                                              "BLOCK_ID_FLAG_UNKNOWN",
                                              "BLOCK_ID_FLAG_ABSENT",
                                              "BLOCK_ID_FLAG_COMMIT",
                                              "BLOCK_ID_FLAG_NIL"
                                            ]
                                          },
                                          "validator_address": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "timestamp": {
                                            "type": "string",
                                            "format": "date-time"
                                          },
                                          "signature": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          }
                                        },
                                        "description": "CommitSig is a part of the Vote included in a Commit."
                                      }
                                    }
                                  },
                                  "description": "Commit contains the evidence that a block was committed by a set of validators."
                                }
                              }
                            },
                            "validator_set": {
                              "type": "object",
                              "properties": {
                                "validators": {
                                  "type": "array",
                                  "items": {
                                    "type": "object",
                                    "properties": {
                                      "address": {
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "pub_key": {
                                        "title": "PublicKey defines the keys available for use with Validators",
                                        "type": "object",
                                        "properties": {
                                          "ed25519": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "secp256k1": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          }
                                        }
                                      },
                                      "voting_power": {
                                        "type": "string",
                                        "format": "int64"
                                      },
                                      "proposer_priority": {
                                        "type": "string",
                                        "format": "int64"
                                      }
                                    }
                                  }
                                },
                                "proposer": {
                                  "type": "object",
                                  "properties": {
                                    "address": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "pub_key": {
                                      "title": "PublicKey defines the keys available for use with Validators",
                                      "type": "object",
                                      "properties": {
                                        "ed25519": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "secp256k1": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      }
                                    },
                                    "voting_power": {
                                      "type": "string",
                                      "format": "int64"
                                    },
                                    "proposer_priority": {
                                      "type": "string",
                                      "format": "int64"
                                    }
                                  }
                                },
                                "total_voting_power": {
                                  "type": "string",
                                  "format": "int64"
                                }
                              }
                            }
                          }
                        },
                        "common_height": {
                          "type": "string",
                          "format": "int64"
                        },
                        "byzantine_validators": {
                          "type": "array",
                          "items": {
                            "type": "object",
                            "properties": {
                              "address": {
                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                "type": "string",
                                "format": "byte"
                              },
                              "pub_key": {
                                "title": "PublicKey defines the keys available for use with Validators",
                                "type": "object",
                                "properties": {
                                  "ed25519": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "secp256k1": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  }
                                }
                              },
                              "voting_power": {
                                "type": "string",
                                "format": "int64"
                              },
                              "proposer_priority": {
                                "type": "string",
                                "format": "int64"
                              }
                            }
                          }
                        },
                        "total_voting_power": {
                          "type": "string",
                          "format": "int64"
                        },
                        "timestamp": {
                          "type": "string",
                          "format": "date-time"
                        }
                      },
                      "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                    }
                  }
                }
              }
            }
          },
          "last_commit": {
            "type": "object",
            "properties": {
              "height": {
                "type": "string",
                "format": "int64"
              },
              "round": {
                "type": "integer",
                "format": "int32"
              },
              "block_id": {
                "title": "BlockID",
                "type": "object",
                "properties": {
                  "hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "part_set_header": {
                    "title": "PartsetHeader",
                    "type": "object",
                    "properties": {
                      "total": {
                        "type": "integer",
                        "format": "int64"
                      },
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      }
                    }
                  }
                }
              },
              "signatures": {
                "type": "array",
                "items": {
                  "type": "object",
                  "properties": {
                    "block_id_flag": {
                      "title": "BlockIdFlag indicates which BlockID the signature is for",
                      "type": "string",
                      "default": "BLOCK_ID_FLAG_UNKNOWN",
                      "enum": [
                        "BLOCK_ID_FLAG_UNKNOWN",
                        "BLOCK_ID_FLAG_ABSENT",
                        "BLOCK_ID_FLAG_COMMIT",
                        "BLOCK_ID_FLAG_NIL"
                      ]
                    },
                    "validator_address": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    },
                    "timestamp": {
                      "type": "string",
                      "format": "date-time"
                    },
                    "signature": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    }
                  },
                  "description": "CommitSig is a part of the Vote included in a Commit."
                }
              }
            },
            "description": "Commit contains the evidence that a block was committed by a set of validators."
          }
        },
        "description": "Block is tendermint type Block, with the Header proposer address\nfield converted to bech32 string."
      },
      "cosmos.base.tendermint.v1beta1.GetBlockByHeightResponse": {
        "type": "object",
        "properties": {
          "block_id": {
            "title": "BlockID",
            "type": "object",
            "properties": {
              "hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "part_set_header": {
                "title": "PartsetHeader",
                "type": "object",
                "properties": {
                  "total": {
                    "type": "integer",
                    "format": "int64"
                  },
                  "hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  }
                }
              }
            }
          },
          "block": {
            "title": "Deprecated: please use `sdk_block` instead",
            "type": "object",
            "properties": {
              "header": {
                "type": "object",
                "properties": {
                  "version": {
                    "title": "basic block info",
                    "type": "object",
                    "properties": {
                      "block": {
                        "type": "string",
                        "format": "uint64"
                      },
                      "app": {
                        "type": "string",
                        "format": "uint64"
                      }
                    },
                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                  },
                  "chain_id": {
                    "type": "string"
                  },
                  "height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "time": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "last_block_id": {
                    "title": "BlockID",
                    "type": "object",
                    "properties": {
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "part_set_header": {
                        "title": "PartsetHeader",
                        "type": "object",
                        "properties": {
                          "total": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  },
                  "last_commit_hash": {
                    "title": "hashes of block data",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "data_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "validators_hash": {
                    "title": "hashes from the app output from the prev block",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "next_validators_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "consensus_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "app_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "last_results_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "evidence_hash": {
                    "title": "consensus info",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "proposer_address": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  }
                },
                "description": "Header defines the structure of a block header."
              },
              "data": {
                "title": "Data contains the set of transactions included in the block",
                "type": "object",
                "properties": {
                  "txs": {
                    "type": "array",
                    "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs.",
                    "items": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    }
                  }
                }
              },
              "evidence": {
                "type": "object",
                "properties": {
                  "evidence": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "duplicate_vote_evidence": {
                          "type": "object",
                          "properties": {
                            "vote_a": {
                              "type": "object",
                              "properties": {
                                "type": {
                                  "type": "string",
                                  "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                  "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                  "enum": [
                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                    "SIGNED_MSG_TYPE_PREVOTE",
                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                  ]
                                },
                                "height": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "round": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "block_id": {
                                  "title": "BlockID",
                                  "type": "object",
                                  "properties": {
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "part_set_header": {
                                      "title": "PartsetHeader",
                                      "type": "object",
                                      "properties": {
                                        "total": {
                                          "type": "integer",
                                          "format": "int64"
                                        },
                                        "hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      }
                                    }
                                  }
                                },
                                "timestamp": {
                                  "type": "string",
                                  "format": "date-time"
                                },
                                "validator_address": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "validator_index": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                                  "format": "byte"
                                },
                                "extension": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                                  "format": "byte"
                                },
                                "extension_signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                                  "format": "byte"
                                }
                              },
                              "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                            },
                            "vote_b": {
                              "type": "object",
                              "properties": {
                                "type": {
                                  "type": "string",
                                  "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                  "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                  "enum": [
                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                    "SIGNED_MSG_TYPE_PREVOTE",
                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                  ]
                                },
                                "height": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "round": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "block_id": {
                                  "title": "BlockID",
                                  "type": "object",
                                  "properties": {
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "part_set_header": {
                                      "title": "PartsetHeader",
                                      "type": "object",
                                      "properties": {
                                        "total": {
                                          "type": "integer",
                                          "format": "int64"
                                        },
                                        "hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      }
                                    }
                                  }
                                },
                                "timestamp": {
                                  "type": "string",
                                  "format": "date-time"
                                },
                                "validator_address": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "validator_index": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                                  "format": "byte"
                                },
                                "extension": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                                  "format": "byte"
                                },
                                "extension_signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                                  "format": "byte"
                                }
                              },
                              "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                            },
                            "total_voting_power": {
                              "type": "string",
                              "format": "int64"
                            },
                            "validator_power": {
                              "type": "string",
                              "format": "int64"
                            },
                            "timestamp": {
                              "type": "string",
                              "format": "date-time"
                            }
                          },
                          "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                        },
                        "light_client_attack_evidence": {
                          "type": "object",
                          "properties": {
                            "conflicting_block": {
                              "type": "object",
                              "properties": {
                                "signed_header": {
                                  "type": "object",
                                  "properties": {
                                    "header": {
                                      "type": "object",
                                      "properties": {
                                        "version": {
                                          "title": "basic block info",
                                          "type": "object",
                                          "properties": {
                                            "block": {
                                              "type": "string",
                                              "format": "uint64"
                                            },
                                            "app": {
                                              "type": "string",
                                              "format": "uint64"
                                            }
                                          },
                                          "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                        },
                                        "chain_id": {
                                          "type": "string"
                                        },
                                        "height": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "time": {
                                          "type": "string",
                                          "format": "date-time"
                                        },
                                        "last_block_id": {
                                          "title": "BlockID",
                                          "type": "object",
                                          "properties": {
                                            "hash": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "part_set_header": {
                                              "title": "PartsetHeader",
                                              "type": "object",
                                              "properties": {
                                                "total": {
                                                  "type": "integer",
                                                  "format": "int64"
                                                },
                                                "hash": {
                                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                  "type": "string",
                                                  "format": "byte"
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "last_commit_hash": {
                                          "title": "hashes of block data",
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "data_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "validators_hash": {
                                          "title": "hashes from the app output from the prev block",
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "next_validators_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "consensus_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "app_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "last_results_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "evidence_hash": {
                                          "title": "consensus info",
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "proposer_address": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      },
                                      "description": "Header defines the structure of a block header."
                                    },
                                    "commit": {
                                      "type": "object",
                                      "properties": {
                                        "height": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "round": {
                                          "type": "integer",
                                          "format": "int32"
                                        },
                                        "block_id": {
                                          "title": "BlockID",
                                          "type": "object",
                                          "properties": {
                                            "hash": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "part_set_header": {
                                              "title": "PartsetHeader",
                                              "type": "object",
                                              "properties": {
                                                "total": {
                                                  "type": "integer",
                                                  "format": "int64"
                                                },
                                                "hash": {
                                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                  "type": "string",
                                                  "format": "byte"
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "signatures": {
                                          "type": "array",
                                          "items": {
                                            "type": "object",
                                            "properties": {
                                              "block_id_flag": {
                                                "title": "BlockIdFlag indicates which BlockID the signature is for",
                                                "type": "string",
                                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                "enum": [
                                                  "BLOCK_ID_FLAG_UNKNOWN",
                                                  "BLOCK_ID_FLAG_ABSENT",
                                                  "BLOCK_ID_FLAG_COMMIT",
                                                  "BLOCK_ID_FLAG_NIL"
                                                ]
                                              },
                                              "validator_address": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "timestamp": {
                                                "type": "string",
                                                "format": "date-time"
                                              },
                                              "signature": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "description": "CommitSig is a part of the Vote included in a Commit."
                                          }
                                        }
                                      },
                                      "description": "Commit contains the evidence that a block was committed by a set of validators."
                                    }
                                  }
                                },
                                "validator_set": {
                                  "type": "object",
                                  "properties": {
                                    "validators": {
                                      "type": "array",
                                      "items": {
                                        "type": "object",
                                        "properties": {
                                          "address": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "pub_key": {
                                            "title": "PublicKey defines the keys available for use with Validators",
                                            "type": "object",
                                            "properties": {
                                              "ed25519": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "secp256k1": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            }
                                          },
                                          "voting_power": {
                                            "type": "string",
                                            "format": "int64"
                                          },
                                          "proposer_priority": {
                                            "type": "string",
                                            "format": "int64"
                                          }
                                        }
                                      }
                                    },
                                    "proposer": {
                                      "type": "object",
                                      "properties": {
                                        "address": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "pub_key": {
                                          "title": "PublicKey defines the keys available for use with Validators",
                                          "type": "object",
                                          "properties": {
                                            "ed25519": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "secp256k1": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          }
                                        },
                                        "voting_power": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "proposer_priority": {
                                          "type": "string",
                                          "format": "int64"
                                        }
                                      }
                                    },
                                    "total_voting_power": {
                                      "type": "string",
                                      "format": "int64"
                                    }
                                  }
                                }
                              }
                            },
                            "common_height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "byzantine_validators": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "address": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "pub_key": {
                                    "title": "PublicKey defines the keys available for use with Validators",
                                    "type": "object",
                                    "properties": {
                                      "ed25519": {
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "secp256k1": {
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    }
                                  },
                                  "voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "proposer_priority": {
                                    "type": "string",
                                    "format": "int64"
                                  }
                                }
                              }
                            },
                            "total_voting_power": {
                              "type": "string",
                              "format": "int64"
                            },
                            "timestamp": {
                              "type": "string",
                              "format": "date-time"
                            }
                          },
                          "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                        }
                      }
                    }
                  }
                }
              },
              "last_commit": {
                "type": "object",
                "properties": {
                  "height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "round": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "block_id": {
                    "title": "BlockID",
                    "type": "object",
                    "properties": {
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "part_set_header": {
                        "title": "PartsetHeader",
                        "type": "object",
                        "properties": {
                          "total": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  },
                  "signatures": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "block_id_flag": {
                          "title": "BlockIdFlag indicates which BlockID the signature is for",
                          "type": "string",
                          "default": "BLOCK_ID_FLAG_UNKNOWN",
                          "enum": [
                            "BLOCK_ID_FLAG_UNKNOWN",
                            "BLOCK_ID_FLAG_ABSENT",
                            "BLOCK_ID_FLAG_COMMIT",
                            "BLOCK_ID_FLAG_NIL"
                          ]
                        },
                        "validator_address": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        },
                        "timestamp": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "signature": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "description": "CommitSig is a part of the Vote included in a Commit."
                    }
                  }
                },
                "description": "Commit contains the evidence that a block was committed by a set of validators."
              }
            }
          },
          "sdk_block": {
            "title": "Since: cosmos-sdk 0.47",
            "type": "object",
            "properties": {
              "header": {
                "type": "object",
                "properties": {
                  "version": {
                    "title": "basic block info",
                    "type": "object",
                    "properties": {
                      "block": {
                        "type": "string",
                        "format": "uint64"
                      },
                      "app": {
                        "type": "string",
                        "format": "uint64"
                      }
                    },
                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                  },
                  "chain_id": {
                    "type": "string"
                  },
                  "height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "time": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "last_block_id": {
                    "title": "BlockID",
                    "type": "object",
                    "properties": {
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "part_set_header": {
                        "title": "PartsetHeader",
                        "type": "object",
                        "properties": {
                          "total": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  },
                  "last_commit_hash": {
                    "title": "hashes of block data",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "data_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "validators_hash": {
                    "title": "hashes from the app output from the prev block",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "next_validators_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "consensus_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "app_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "last_results_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "evidence_hash": {
                    "title": "consensus info",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "proposer_address": {
                    "type": "string",
                    "description": "proposer_address is the original block proposer address, formatted as a Bech32 string.\nIn Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string\nfor better UX."
                  }
                },
                "description": "Header defines the structure of a Tendermint block header."
              },
              "data": {
                "title": "Data contains the set of transactions included in the block",
                "type": "object",
                "properties": {
                  "txs": {
                    "type": "array",
                    "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs.",
                    "items": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    }
                  }
                }
              },
              "evidence": {
                "type": "object",
                "properties": {
                  "evidence": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "duplicate_vote_evidence": {
                          "type": "object",
                          "properties": {
                            "vote_a": {
                              "type": "object",
                              "properties": {
                                "type": {
                                  "type": "string",
                                  "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                  "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                  "enum": [
                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                    "SIGNED_MSG_TYPE_PREVOTE",
                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                  ]
                                },
                                "height": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "round": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "block_id": {
                                  "title": "BlockID",
                                  "type": "object",
                                  "properties": {
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "part_set_header": {
                                      "title": "PartsetHeader",
                                      "type": "object",
                                      "properties": {
                                        "total": {
                                          "type": "integer",
                                          "format": "int64"
                                        },
                                        "hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      }
                                    }
                                  }
                                },
                                "timestamp": {
                                  "type": "string",
                                  "format": "date-time"
                                },
                                "validator_address": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "validator_index": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                                  "format": "byte"
                                },
                                "extension": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                                  "format": "byte"
                                },
                                "extension_signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                                  "format": "byte"
                                }
                              },
                              "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                            },
                            "vote_b": {
                              "type": "object",
                              "properties": {
                                "type": {
                                  "type": "string",
                                  "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                  "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                  "enum": [
                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                    "SIGNED_MSG_TYPE_PREVOTE",
                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                  ]
                                },
                                "height": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "round": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "block_id": {
                                  "title": "BlockID",
                                  "type": "object",
                                  "properties": {
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "part_set_header": {
                                      "title": "PartsetHeader",
                                      "type": "object",
                                      "properties": {
                                        "total": {
                                          "type": "integer",
                                          "format": "int64"
                                        },
                                        "hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      }
                                    }
                                  }
                                },
                                "timestamp": {
                                  "type": "string",
                                  "format": "date-time"
                                },
                                "validator_address": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "validator_index": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                                  "format": "byte"
                                },
                                "extension": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                                  "format": "byte"
                                },
                                "extension_signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                                  "format": "byte"
                                }
                              },
                              "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                            },
                            "total_voting_power": {
                              "type": "string",
                              "format": "int64"
                            },
                            "validator_power": {
                              "type": "string",
                              "format": "int64"
                            },
                            "timestamp": {
                              "type": "string",
                              "format": "date-time"
                            }
                          },
                          "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                        },
                        "light_client_attack_evidence": {
                          "type": "object",
                          "properties": {
                            "conflicting_block": {
                              "type": "object",
                              "properties": {
                                "signed_header": {
                                  "type": "object",
                                  "properties": {
                                    "header": {
                                      "type": "object",
                                      "properties": {
                                        "version": {
                                          "title": "basic block info",
                                          "type": "object",
                                          "properties": {
                                            "block": {
                                              "type": "string",
                                              "format": "uint64"
                                            },
                                            "app": {
                                              "type": "string",
                                              "format": "uint64"
                                            }
                                          },
                                          "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                        },
                                        "chain_id": {
                                          "type": "string"
                                        },
                                        "height": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "time": {
                                          "type": "string",
                                          "format": "date-time"
                                        },
                                        "last_block_id": {
                                          "title": "BlockID",
                                          "type": "object",
                                          "properties": {
                                            "hash": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "part_set_header": {
                                              "title": "PartsetHeader",
                                              "type": "object",
                                              "properties": {
                                                "total": {
                                                  "type": "integer",
                                                  "format": "int64"
                                                },
                                                "hash": {
                                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                  "type": "string",
                                                  "format": "byte"
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "last_commit_hash": {
                                          "title": "hashes of block data",
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "data_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "validators_hash": {
                                          "title": "hashes from the app output from the prev block",
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "next_validators_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "consensus_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "app_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "last_results_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "evidence_hash": {
                                          "title": "consensus info",
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "proposer_address": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      },
                                      "description": "Header defines the structure of a block header."
                                    },
                                    "commit": {
                                      "type": "object",
                                      "properties": {
                                        "height": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "round": {
                                          "type": "integer",
                                          "format": "int32"
                                        },
                                        "block_id": {
                                          "title": "BlockID",
                                          "type": "object",
                                          "properties": {
                                            "hash": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "part_set_header": {
                                              "title": "PartsetHeader",
                                              "type": "object",
                                              "properties": {
                                                "total": {
                                                  "type": "integer",
                                                  "format": "int64"
                                                },
                                                "hash": {
                                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                  "type": "string",
                                                  "format": "byte"
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "signatures": {
                                          "type": "array",
                                          "items": {
                                            "type": "object",
                                            "properties": {
                                              "block_id_flag": {
                                                "title": "BlockIdFlag indicates which BlockID the signature is for",
                                                "type": "string",
                                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                "enum": [
                                                  "BLOCK_ID_FLAG_UNKNOWN",
                                                  "BLOCK_ID_FLAG_ABSENT",
                                                  "BLOCK_ID_FLAG_COMMIT",
                                                  "BLOCK_ID_FLAG_NIL"
                                                ]
                                              },
                                              "validator_address": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "timestamp": {
                                                "type": "string",
                                                "format": "date-time"
                                              },
                                              "signature": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "description": "CommitSig is a part of the Vote included in a Commit."
                                          }
                                        }
                                      },
                                      "description": "Commit contains the evidence that a block was committed by a set of validators."
                                    }
                                  }
                                },
                                "validator_set": {
                                  "type": "object",
                                  "properties": {
                                    "validators": {
                                      "type": "array",
                                      "items": {
                                        "type": "object",
                                        "properties": {
                                          "address": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "pub_key": {
                                            "title": "PublicKey defines the keys available for use with Validators",
                                            "type": "object",
                                            "properties": {
                                              "ed25519": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "secp256k1": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            }
                                          },
                                          "voting_power": {
                                            "type": "string",
                                            "format": "int64"
                                          },
                                          "proposer_priority": {
                                            "type": "string",
                                            "format": "int64"
                                          }
                                        }
                                      }
                                    },
                                    "proposer": {
                                      "type": "object",
                                      "properties": {
                                        "address": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "pub_key": {
                                          "title": "PublicKey defines the keys available for use with Validators",
                                          "type": "object",
                                          "properties": {
                                            "ed25519": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "secp256k1": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          }
                                        },
                                        "voting_power": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "proposer_priority": {
                                          "type": "string",
                                          "format": "int64"
                                        }
                                      }
                                    },
                                    "total_voting_power": {
                                      "type": "string",
                                      "format": "int64"
                                    }
                                  }
                                }
                              }
                            },
                            "common_height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "byzantine_validators": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "address": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "pub_key": {
                                    "title": "PublicKey defines the keys available for use with Validators",
                                    "type": "object",
                                    "properties": {
                                      "ed25519": {
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "secp256k1": {
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    }
                                  },
                                  "voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "proposer_priority": {
                                    "type": "string",
                                    "format": "int64"
                                  }
                                }
                              }
                            },
                            "total_voting_power": {
                              "type": "string",
                              "format": "int64"
                            },
                            "timestamp": {
                              "type": "string",
                              "format": "date-time"
                            }
                          },
                          "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                        }
                      }
                    }
                  }
                }
              },
              "last_commit": {
                "type": "object",
                "properties": {
                  "height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "round": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "block_id": {
                    "title": "BlockID",
                    "type": "object",
                    "properties": {
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "part_set_header": {
                        "title": "PartsetHeader",
                        "type": "object",
                        "properties": {
                          "total": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  },
                  "signatures": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "block_id_flag": {
                          "title": "BlockIdFlag indicates which BlockID the signature is for",
                          "type": "string",
                          "default": "BLOCK_ID_FLAG_UNKNOWN",
                          "enum": [
                            "BLOCK_ID_FLAG_UNKNOWN",
                            "BLOCK_ID_FLAG_ABSENT",
                            "BLOCK_ID_FLAG_COMMIT",
                            "BLOCK_ID_FLAG_NIL"
                          ]
                        },
                        "validator_address": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        },
                        "timestamp": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "signature": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "description": "CommitSig is a part of the Vote included in a Commit."
                    }
                  }
                },
                "description": "Commit contains the evidence that a block was committed by a set of validators."
              }
            },
            "description": "Block is tendermint type Block, with the Header proposer address\nfield converted to bech32 string."
          }
        },
        "description": "GetBlockByHeightResponse is the response type for the Query/GetBlockByHeight RPC method."
      },
      "cosmos.base.tendermint.v1beta1.GetLatestBlockResponse": {
        "type": "object",
        "properties": {
          "block_id": {
            "title": "BlockID",
            "type": "object",
            "properties": {
              "hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "part_set_header": {
                "title": "PartsetHeader",
                "type": "object",
                "properties": {
                  "total": {
                    "type": "integer",
                    "format": "int64"
                  },
                  "hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  }
                }
              }
            }
          },
          "block": {
            "title": "Deprecated: please use `sdk_block` instead",
            "type": "object",
            "properties": {
              "header": {
                "type": "object",
                "properties": {
                  "version": {
                    "title": "basic block info",
                    "type": "object",
                    "properties": {
                      "block": {
                        "type": "string",
                        "format": "uint64"
                      },
                      "app": {
                        "type": "string",
                        "format": "uint64"
                      }
                    },
                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                  },
                  "chain_id": {
                    "type": "string"
                  },
                  "height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "time": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "last_block_id": {
                    "title": "BlockID",
                    "type": "object",
                    "properties": {
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "part_set_header": {
                        "title": "PartsetHeader",
                        "type": "object",
                        "properties": {
                          "total": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  },
                  "last_commit_hash": {
                    "title": "hashes of block data",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "data_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "validators_hash": {
                    "title": "hashes from the app output from the prev block",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "next_validators_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "consensus_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "app_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "last_results_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "evidence_hash": {
                    "title": "consensus info",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "proposer_address": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  }
                },
                "description": "Header defines the structure of a block header."
              },
              "data": {
                "title": "Data contains the set of transactions included in the block",
                "type": "object",
                "properties": {
                  "txs": {
                    "type": "array",
                    "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs.",
                    "items": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    }
                  }
                }
              },
              "evidence": {
                "type": "object",
                "properties": {
                  "evidence": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "duplicate_vote_evidence": {
                          "type": "object",
                          "properties": {
                            "vote_a": {
                              "type": "object",
                              "properties": {
                                "type": {
                                  "type": "string",
                                  "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                  "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                  "enum": [
                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                    "SIGNED_MSG_TYPE_PREVOTE",
                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                  ]
                                },
                                "height": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "round": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "block_id": {
                                  "title": "BlockID",
                                  "type": "object",
                                  "properties": {
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "part_set_header": {
                                      "title": "PartsetHeader",
                                      "type": "object",
                                      "properties": {
                                        "total": {
                                          "type": "integer",
                                          "format": "int64"
                                        },
                                        "hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      }
                                    }
                                  }
                                },
                                "timestamp": {
                                  "type": "string",
                                  "format": "date-time"
                                },
                                "validator_address": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "validator_index": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                                  "format": "byte"
                                },
                                "extension": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                                  "format": "byte"
                                },
                                "extension_signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                                  "format": "byte"
                                }
                              },
                              "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                            },
                            "vote_b": {
                              "type": "object",
                              "properties": {
                                "type": {
                                  "type": "string",
                                  "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                  "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                  "enum": [
                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                    "SIGNED_MSG_TYPE_PREVOTE",
                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                  ]
                                },
                                "height": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "round": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "block_id": {
                                  "title": "BlockID",
                                  "type": "object",
                                  "properties": {
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "part_set_header": {
                                      "title": "PartsetHeader",
                                      "type": "object",
                                      "properties": {
                                        "total": {
                                          "type": "integer",
                                          "format": "int64"
                                        },
                                        "hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      }
                                    }
                                  }
                                },
                                "timestamp": {
                                  "type": "string",
                                  "format": "date-time"
                                },
                                "validator_address": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "validator_index": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                                  "format": "byte"
                                },
                                "extension": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                                  "format": "byte"
                                },
                                "extension_signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                                  "format": "byte"
                                }
                              },
                              "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                            },
                            "total_voting_power": {
                              "type": "string",
                              "format": "int64"
                            },
                            "validator_power": {
                              "type": "string",
                              "format": "int64"
                            },
                            "timestamp": {
                              "type": "string",
                              "format": "date-time"
                            }
                          },
                          "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                        },
                        "light_client_attack_evidence": {
                          "type": "object",
                          "properties": {
                            "conflicting_block": {
                              "type": "object",
                              "properties": {
                                "signed_header": {
                                  "type": "object",
                                  "properties": {
                                    "header": {
                                      "type": "object",
                                      "properties": {
                                        "version": {
                                          "title": "basic block info",
                                          "type": "object",
                                          "properties": {
                                            "block": {
                                              "type": "string",
                                              "format": "uint64"
                                            },
                                            "app": {
                                              "type": "string",
                                              "format": "uint64"
                                            }
                                          },
                                          "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                        },
                                        "chain_id": {
                                          "type": "string"
                                        },
                                        "height": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "time": {
                                          "type": "string",
                                          "format": "date-time"
                                        },
                                        "last_block_id": {
                                          "title": "BlockID",
                                          "type": "object",
                                          "properties": {
                                            "hash": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "part_set_header": {
                                              "title": "PartsetHeader",
                                              "type": "object",
                                              "properties": {
                                                "total": {
                                                  "type": "integer",
                                                  "format": "int64"
                                                },
                                                "hash": {
                                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                  "type": "string",
                                                  "format": "byte"
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "last_commit_hash": {
                                          "title": "hashes of block data",
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "data_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "validators_hash": {
                                          "title": "hashes from the app output from the prev block",
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "next_validators_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "consensus_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "app_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "last_results_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "evidence_hash": {
                                          "title": "consensus info",
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "proposer_address": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      },
                                      "description": "Header defines the structure of a block header."
                                    },
                                    "commit": {
                                      "type": "object",
                                      "properties": {
                                        "height": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "round": {
                                          "type": "integer",
                                          "format": "int32"
                                        },
                                        "block_id": {
                                          "title": "BlockID",
                                          "type": "object",
                                          "properties": {
                                            "hash": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "part_set_header": {
                                              "title": "PartsetHeader",
                                              "type": "object",
                                              "properties": {
                                                "total": {
                                                  "type": "integer",
                                                  "format": "int64"
                                                },
                                                "hash": {
                                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                  "type": "string",
                                                  "format": "byte"
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "signatures": {
                                          "type": "array",
                                          "items": {
                                            "type": "object",
                                            "properties": {
                                              "block_id_flag": {
                                                "title": "BlockIdFlag indicates which BlockID the signature is for",
                                                "type": "string",
                                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                "enum": [
                                                  "BLOCK_ID_FLAG_UNKNOWN",
                                                  "BLOCK_ID_FLAG_ABSENT",
                                                  "BLOCK_ID_FLAG_COMMIT",
                                                  "BLOCK_ID_FLAG_NIL"
                                                ]
                                              },
                                              "validator_address": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "timestamp": {
                                                "type": "string",
                                                "format": "date-time"
                                              },
                                              "signature": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "description": "CommitSig is a part of the Vote included in a Commit."
                                          }
                                        }
                                      },
                                      "description": "Commit contains the evidence that a block was committed by a set of validators."
                                    }
                                  }
                                },
                                "validator_set": {
                                  "type": "object",
                                  "properties": {
                                    "validators": {
                                      "type": "array",
                                      "items": {
                                        "type": "object",
                                        "properties": {
                                          "address": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "pub_key": {
                                            "title": "PublicKey defines the keys available for use with Validators",
                                            "type": "object",
                                            "properties": {
                                              "ed25519": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "secp256k1": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            }
                                          },
                                          "voting_power": {
                                            "type": "string",
                                            "format": "int64"
                                          },
                                          "proposer_priority": {
                                            "type": "string",
                                            "format": "int64"
                                          }
                                        }
                                      }
                                    },
                                    "proposer": {
                                      "type": "object",
                                      "properties": {
                                        "address": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "pub_key": {
                                          "title": "PublicKey defines the keys available for use with Validators",
                                          "type": "object",
                                          "properties": {
                                            "ed25519": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "secp256k1": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          }
                                        },
                                        "voting_power": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "proposer_priority": {
                                          "type": "string",
                                          "format": "int64"
                                        }
                                      }
                                    },
                                    "total_voting_power": {
                                      "type": "string",
                                      "format": "int64"
                                    }
                                  }
                                }
                              }
                            },
                            "common_height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "byzantine_validators": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "address": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "pub_key": {
                                    "title": "PublicKey defines the keys available for use with Validators",
                                    "type": "object",
                                    "properties": {
                                      "ed25519": {
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "secp256k1": {
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    }
                                  },
                                  "voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "proposer_priority": {
                                    "type": "string",
                                    "format": "int64"
                                  }
                                }
                              }
                            },
                            "total_voting_power": {
                              "type": "string",
                              "format": "int64"
                            },
                            "timestamp": {
                              "type": "string",
                              "format": "date-time"
                            }
                          },
                          "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                        }
                      }
                    }
                  }
                }
              },
              "last_commit": {
                "type": "object",
                "properties": {
                  "height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "round": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "block_id": {
                    "title": "BlockID",
                    "type": "object",
                    "properties": {
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "part_set_header": {
                        "title": "PartsetHeader",
                        "type": "object",
                        "properties": {
                          "total": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  },
                  "signatures": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "block_id_flag": {
                          "title": "BlockIdFlag indicates which BlockID the signature is for",
                          "type": "string",
                          "default": "BLOCK_ID_FLAG_UNKNOWN",
                          "enum": [
                            "BLOCK_ID_FLAG_UNKNOWN",
                            "BLOCK_ID_FLAG_ABSENT",
                            "BLOCK_ID_FLAG_COMMIT",
                            "BLOCK_ID_FLAG_NIL"
                          ]
                        },
                        "validator_address": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        },
                        "timestamp": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "signature": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "description": "CommitSig is a part of the Vote included in a Commit."
                    }
                  }
                },
                "description": "Commit contains the evidence that a block was committed by a set of validators."
              }
            }
          },
          "sdk_block": {
            "title": "Since: cosmos-sdk 0.47",
            "type": "object",
            "properties": {
              "header": {
                "type": "object",
                "properties": {
                  "version": {
                    "title": "basic block info",
                    "type": "object",
                    "properties": {
                      "block": {
                        "type": "string",
                        "format": "uint64"
                      },
                      "app": {
                        "type": "string",
                        "format": "uint64"
                      }
                    },
                    "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                  },
                  "chain_id": {
                    "type": "string"
                  },
                  "height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "time": {
                    "type": "string",
                    "format": "date-time"
                  },
                  "last_block_id": {
                    "title": "BlockID",
                    "type": "object",
                    "properties": {
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "part_set_header": {
                        "title": "PartsetHeader",
                        "type": "object",
                        "properties": {
                          "total": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  },
                  "last_commit_hash": {
                    "title": "hashes of block data",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "data_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "validators_hash": {
                    "title": "hashes from the app output from the prev block",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "next_validators_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "consensus_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "app_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "last_results_hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "evidence_hash": {
                    "title": "consensus info",
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  },
                  "proposer_address": {
                    "type": "string",
                    "description": "proposer_address is the original block proposer address, formatted as a Bech32 string.\nIn Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string\nfor better UX."
                  }
                },
                "description": "Header defines the structure of a Tendermint block header."
              },
              "data": {
                "title": "Data contains the set of transactions included in the block",
                "type": "object",
                "properties": {
                  "txs": {
                    "type": "array",
                    "description": "Txs that will be applied by state @ block.Height+1.\nNOTE: not all txs here are valid.  We're just agreeing on the order first.\nThis means that block.AppHash does not include these txs.",
                    "items": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "format": "byte"
                    }
                  }
                }
              },
              "evidence": {
                "type": "object",
                "properties": {
                  "evidence": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "duplicate_vote_evidence": {
                          "type": "object",
                          "properties": {
                            "vote_a": {
                              "type": "object",
                              "properties": {
                                "type": {
                                  "type": "string",
                                  "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                  "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                  "enum": [
                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                    "SIGNED_MSG_TYPE_PREVOTE",
                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                  ]
                                },
                                "height": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "round": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "block_id": {
                                  "title": "BlockID",
                                  "type": "object",
                                  "properties": {
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "part_set_header": {
                                      "title": "PartsetHeader",
                                      "type": "object",
                                      "properties": {
                                        "total": {
                                          "type": "integer",
                                          "format": "int64"
                                        },
                                        "hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      }
                                    }
                                  }
                                },
                                "timestamp": {
                                  "type": "string",
                                  "format": "date-time"
                                },
                                "validator_address": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "validator_index": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                                  "format": "byte"
                                },
                                "extension": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                                  "format": "byte"
                                },
                                "extension_signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                                  "format": "byte"
                                }
                              },
                              "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                            },
                            "vote_b": {
                              "type": "object",
                              "properties": {
                                "type": {
                                  "type": "string",
                                  "description": "SignedMsgType is a type of signed message in the consensus.\n\n - SIGNED_MSG_TYPE_PREVOTE: Votes\n - SIGNED_MSG_TYPE_PROPOSAL: Proposals",
                                  "default": "SIGNED_MSG_TYPE_UNKNOWN",
                                  "enum": [
                                    "SIGNED_MSG_TYPE_UNKNOWN",
                                    "SIGNED_MSG_TYPE_PREVOTE",
                                    "SIGNED_MSG_TYPE_PRECOMMIT",
                                    "SIGNED_MSG_TYPE_PROPOSAL"
                                  ]
                                },
                                "height": {
                                  "type": "string",
                                  "format": "int64"
                                },
                                "round": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "block_id": {
                                  "title": "BlockID",
                                  "type": "object",
                                  "properties": {
                                    "hash": {
                                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                      "type": "string",
                                      "format": "byte"
                                    },
                                    "part_set_header": {
                                      "title": "PartsetHeader",
                                      "type": "object",
                                      "properties": {
                                        "total": {
                                          "type": "integer",
                                          "format": "int64"
                                        },
                                        "hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      }
                                    }
                                  }
                                },
                                "timestamp": {
                                  "type": "string",
                                  "format": "date-time"
                                },
                                "validator_address": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "format": "byte"
                                },
                                "validator_index": {
                                  "type": "integer",
                                  "format": "int32"
                                },
                                "signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote signature by the validator if they participated in consensus for the\nassociated block.",
                                  "format": "byte"
                                },
                                "extension": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension provided by the application. Only valid for precommit\nmessages.",
                                  "format": "byte"
                                },
                                "extension_signature": {
                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                  "type": "string",
                                  "description": "Vote extension signature by the validator if they participated in\nconsensus for the associated block.\nOnly valid for precommit messages.",
                                  "format": "byte"
                                }
                              },
                              "description": "Vote represents a prevote or precommit vote from validators for\nconsensus."
                            },
                            "total_voting_power": {
                              "type": "string",
                              "format": "int64"
                            },
                            "validator_power": {
                              "type": "string",
                              "format": "int64"
                            },
                            "timestamp": {
                              "type": "string",
                              "format": "date-time"
                            }
                          },
                          "description": "DuplicateVoteEvidence contains evidence of a validator signed two conflicting votes."
                        },
                        "light_client_attack_evidence": {
                          "type": "object",
                          "properties": {
                            "conflicting_block": {
                              "type": "object",
                              "properties": {
                                "signed_header": {
                                  "type": "object",
                                  "properties": {
                                    "header": {
                                      "type": "object",
                                      "properties": {
                                        "version": {
                                          "title": "basic block info",
                                          "type": "object",
                                          "properties": {
                                            "block": {
                                              "type": "string",
                                              "format": "uint64"
                                            },
                                            "app": {
                                              "type": "string",
                                              "format": "uint64"
                                            }
                                          },
                                          "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
                                        },
                                        "chain_id": {
                                          "type": "string"
                                        },
                                        "height": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "time": {
                                          "type": "string",
                                          "format": "date-time"
                                        },
                                        "last_block_id": {
                                          "title": "BlockID",
                                          "type": "object",
                                          "properties": {
                                            "hash": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "part_set_header": {
                                              "title": "PartsetHeader",
                                              "type": "object",
                                              "properties": {
                                                "total": {
                                                  "type": "integer",
                                                  "format": "int64"
                                                },
                                                "hash": {
                                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                  "type": "string",
                                                  "format": "byte"
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "last_commit_hash": {
                                          "title": "hashes of block data",
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "data_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "validators_hash": {
                                          "title": "hashes from the app output from the prev block",
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "next_validators_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "consensus_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "app_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "last_results_hash": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "evidence_hash": {
                                          "title": "consensus info",
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "proposer_address": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        }
                                      },
                                      "description": "Header defines the structure of a block header."
                                    },
                                    "commit": {
                                      "type": "object",
                                      "properties": {
                                        "height": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "round": {
                                          "type": "integer",
                                          "format": "int32"
                                        },
                                        "block_id": {
                                          "title": "BlockID",
                                          "type": "object",
                                          "properties": {
                                            "hash": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "part_set_header": {
                                              "title": "PartsetHeader",
                                              "type": "object",
                                              "properties": {
                                                "total": {
                                                  "type": "integer",
                                                  "format": "int64"
                                                },
                                                "hash": {
                                                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                  "type": "string",
                                                  "format": "byte"
                                                }
                                              }
                                            }
                                          }
                                        },
                                        "signatures": {
                                          "type": "array",
                                          "items": {
                                            "type": "object",
                                            "properties": {
                                              "block_id_flag": {
                                                "title": "BlockIdFlag indicates which BlockID the signature is for",
                                                "type": "string",
                                                "default": "BLOCK_ID_FLAG_UNKNOWN",
                                                "enum": [
                                                  "BLOCK_ID_FLAG_UNKNOWN",
                                                  "BLOCK_ID_FLAG_ABSENT",
                                                  "BLOCK_ID_FLAG_COMMIT",
                                                  "BLOCK_ID_FLAG_NIL"
                                                ]
                                              },
                                              "validator_address": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "timestamp": {
                                                "type": "string",
                                                "format": "date-time"
                                              },
                                              "signature": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            },
                                            "description": "CommitSig is a part of the Vote included in a Commit."
                                          }
                                        }
                                      },
                                      "description": "Commit contains the evidence that a block was committed by a set of validators."
                                    }
                                  }
                                },
                                "validator_set": {
                                  "type": "object",
                                  "properties": {
                                    "validators": {
                                      "type": "array",
                                      "items": {
                                        "type": "object",
                                        "properties": {
                                          "address": {
                                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                            "type": "string",
                                            "format": "byte"
                                          },
                                          "pub_key": {
                                            "title": "PublicKey defines the keys available for use with Validators",
                                            "type": "object",
                                            "properties": {
                                              "ed25519": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              },
                                              "secp256k1": {
                                                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                                "type": "string",
                                                "format": "byte"
                                              }
                                            }
                                          },
                                          "voting_power": {
                                            "type": "string",
                                            "format": "int64"
                                          },
                                          "proposer_priority": {
                                            "type": "string",
                                            "format": "int64"
                                          }
                                        }
                                      }
                                    },
                                    "proposer": {
                                      "type": "object",
                                      "properties": {
                                        "address": {
                                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                          "type": "string",
                                          "format": "byte"
                                        },
                                        "pub_key": {
                                          "title": "PublicKey defines the keys available for use with Validators",
                                          "type": "object",
                                          "properties": {
                                            "ed25519": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            },
                                            "secp256k1": {
                                              "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                              "type": "string",
                                              "format": "byte"
                                            }
                                          }
                                        },
                                        "voting_power": {
                                          "type": "string",
                                          "format": "int64"
                                        },
                                        "proposer_priority": {
                                          "type": "string",
                                          "format": "int64"
                                        }
                                      }
                                    },
                                    "total_voting_power": {
                                      "type": "string",
                                      "format": "int64"
                                    }
                                  }
                                }
                              }
                            },
                            "common_height": {
                              "type": "string",
                              "format": "int64"
                            },
                            "byzantine_validators": {
                              "type": "array",
                              "items": {
                                "type": "object",
                                "properties": {
                                  "address": {
                                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                    "type": "string",
                                    "format": "byte"
                                  },
                                  "pub_key": {
                                    "title": "PublicKey defines the keys available for use with Validators",
                                    "type": "object",
                                    "properties": {
                                      "ed25519": {
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string",
                                        "format": "byte"
                                      },
                                      "secp256k1": {
                                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                                        "type": "string",
                                        "format": "byte"
                                      }
                                    }
                                  },
                                  "voting_power": {
                                    "type": "string",
                                    "format": "int64"
                                  },
                                  "proposer_priority": {
                                    "type": "string",
                                    "format": "int64"
                                  }
                                }
                              }
                            },
                            "total_voting_power": {
                              "type": "string",
                              "format": "int64"
                            },
                            "timestamp": {
                              "type": "string",
                              "format": "date-time"
                            }
                          },
                          "description": "LightClientAttackEvidence contains evidence of a set of validators attempting to mislead a light client."
                        }
                      }
                    }
                  }
                }
              },
              "last_commit": {
                "type": "object",
                "properties": {
                  "height": {
                    "type": "string",
                    "format": "int64"
                  },
                  "round": {
                    "type": "integer",
                    "format": "int32"
                  },
                  "block_id": {
                    "title": "BlockID",
                    "type": "object",
                    "properties": {
                      "hash": {
                        "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                        "type": "string",
                        "format": "byte"
                      },
                      "part_set_header": {
                        "title": "PartsetHeader",
                        "type": "object",
                        "properties": {
                          "total": {
                            "type": "integer",
                            "format": "int64"
                          },
                          "hash": {
                            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                            "type": "string",
                            "format": "byte"
                          }
                        }
                      }
                    }
                  },
                  "signatures": {
                    "type": "array",
                    "items": {
                      "type": "object",
                      "properties": {
                        "block_id_flag": {
                          "title": "BlockIdFlag indicates which BlockID the signature is for",
                          "type": "string",
                          "default": "BLOCK_ID_FLAG_UNKNOWN",
                          "enum": [
                            "BLOCK_ID_FLAG_UNKNOWN",
                            "BLOCK_ID_FLAG_ABSENT",
                            "BLOCK_ID_FLAG_COMMIT",
                            "BLOCK_ID_FLAG_NIL"
                          ]
                        },
                        "validator_address": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        },
                        "timestamp": {
                          "type": "string",
                          "format": "date-time"
                        },
                        "signature": {
                          "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                          "type": "string",
                          "format": "byte"
                        }
                      },
                      "description": "CommitSig is a part of the Vote included in a Commit."
                    }
                  }
                },
                "description": "Commit contains the evidence that a block was committed by a set of validators."
              }
            },
            "description": "Block is tendermint type Block, with the Header proposer address\nfield converted to bech32 string."
          }
        },
        "description": "GetLatestBlockResponse is the response type for the Query/GetLatestBlock RPC method."
      },
      "cosmos.base.tendermint.v1beta1.GetLatestValidatorSetResponse": {
        "type": "object",
        "properties": {
          "block_height": {
            "type": "string",
            "format": "int64"
          },
          "validators": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string"
                },
                "pub_key": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "byte"
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                },
                "voting_power": {
                  "type": "string",
                  "format": "int64"
                },
                "proposer_priority": {
                  "type": "string",
                  "format": "int64"
                }
              },
              "description": "Validator is the type for the validator-set."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines an pagination for the response."
          }
        },
        "description": "GetLatestValidatorSetResponse is the response type for the Query/GetValidatorSetByHeight RPC method."
      },
      "cosmos.base.tendermint.v1beta1.GetNodeInfoResponse": {
        "type": "object",
        "properties": {
          "default_node_info": {
            "type": "object",
            "properties": {
              "protocol_version": {
                "type": "object",
                "properties": {
                  "p2p": {
                    "type": "string",
                    "format": "uint64"
                  },
                  "block": {
                    "type": "string",
                    "format": "uint64"
                  },
                  "app": {
                    "type": "string",
                    "format": "uint64"
                  }
                }
              },
              "default_node_id": {
                "type": "string"
              },
              "listen_addr": {
                "type": "string"
              },
              "network": {
                "type": "string"
              },
              "version": {
                "type": "string"
              },
              "channels": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "moniker": {
                "type": "string"
              },
              "other": {
                "type": "object",
                "properties": {
                  "tx_index": {
                    "type": "string"
                  },
                  "rpc_address": {
                    "type": "string"
                  }
                }
              }
            }
          },
          "application_version": {
            "type": "object",
            "properties": {
              "name": {
                "type": "string"
              },
              "app_name": {
                "type": "string"
              },
              "version": {
                "type": "string"
              },
              "git_commit": {
                "type": "string"
              },
              "build_tags": {
                "type": "string"
              },
              "go_version": {
                "type": "string"
              },
              "build_deps": {
                "type": "array",
                "items": {
                  "title": "Module is the type for VersionInfo",
                  "type": "object",
                  "properties": {
                    "path": {
                      "title": "module path",
                      "type": "string"
                    },
                    "version": {
                      "title": "module version",
                      "type": "string"
                    },
                    "sum": {
                      "title": "checksum",
                      "type": "string"
                    }
                  }
                }
              },
              "cosmos_sdk_version": {
                "title": "Since: cosmos-sdk 0.43",
                "type": "string"
              }
            },
            "description": "VersionInfo is the type for the GetNodeInfoResponse message."
          }
        },
        "description": "GetNodeInfoResponse is the response type for the Query/GetNodeInfo RPC method."
      },
      "cosmos.base.tendermint.v1beta1.GetSyncingResponse": {
        "type": "object",
        "properties": {
          "syncing": {
            "type": "boolean"
          }
        },
        "description": "GetSyncingResponse is the response type for the Query/GetSyncing RPC method."
      },
      "cosmos.base.tendermint.v1beta1.GetValidatorSetByHeightResponse": {
        "type": "object",
        "properties": {
          "block_height": {
            "type": "string",
            "format": "int64"
          },
          "validators": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "address": {
                  "type": "string"
                },
                "pub_key": {
                  "type": "object",
                  "properties": {
                    "type_url": {
                      "type": "string",
                      "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
                    },
                    "value": {
                      "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                      "type": "string",
                      "description": "Must be a valid serialized protocol buffer of the above specified type.",
                      "format": "byte"
                    }
                  },
                  "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
                },
                "voting_power": {
                  "type": "string",
                  "format": "int64"
                },
                "proposer_priority": {
                  "type": "string",
                  "format": "int64"
                }
              },
              "description": "Validator is the type for the validator-set."
            }
          },
          "pagination": {
            "type": "object",
            "properties": {
              "next_key": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "next_key is the key to be passed to PageRequest.key to\nquery the next page most efficiently. It will be empty if\nthere are no more results.",
                "format": "byte"
              },
              "total": {
                "title": "total is total number of results available if PageRequest.count_total\nwas set, its value is undefined otherwise",
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "pagination defines an pagination for the response."
          }
        },
        "description": "GetValidatorSetByHeightResponse is the response type for the Query/GetValidatorSetByHeight RPC method."
      },
      "cosmos.base.tendermint.v1beta1.Header": {
        "type": "object",
        "properties": {
          "version": {
            "title": "basic block info",
            "type": "object",
            "properties": {
              "block": {
                "type": "string",
                "format": "uint64"
              },
              "app": {
                "type": "string",
                "format": "uint64"
              }
            },
            "description": "Consensus captures the consensus rules for processing a block in the blockchain,\nincluding all blockchain data structures and the rules of the application's\nstate transition machine."
          },
          "chain_id": {
            "type": "string"
          },
          "height": {
            "type": "string",
            "format": "int64"
          },
          "time": {
            "type": "string",
            "format": "date-time"
          },
          "last_block_id": {
            "title": "BlockID",
            "type": "object",
            "properties": {
              "hash": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "format": "byte"
              },
              "part_set_header": {
                "title": "PartsetHeader",
                "type": "object",
                "properties": {
                  "total": {
                    "type": "integer",
                    "format": "int64"
                  },
                  "hash": {
                    "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                    "type": "string",
                    "format": "byte"
                  }
                }
              }
            }
          },
          "last_commit_hash": {
            "title": "hashes of block data",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "data_hash": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "validators_hash": {
            "title": "hashes from the app output from the prev block",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "next_validators_hash": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "consensus_hash": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "app_hash": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "last_results_hash": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "evidence_hash": {
            "title": "consensus info",
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "proposer_address": {
            "type": "string",
            "description": "proposer_address is the original block proposer address, formatted as a Bech32 string.\nIn Tendermint, this type is `bytes`, but in the SDK, we convert it to a Bech32 string\nfor better UX."
          }
        },
        "description": "Header defines the structure of a Tendermint block header."
      },
      "cosmos.base.tendermint.v1beta1.Module": {
        "title": "Module is the type for VersionInfo",
        "type": "object",
        "properties": {
          "path": {
            "title": "module path",
            "type": "string"
          },
          "version": {
            "title": "module version",
            "type": "string"
          },
          "sum": {
            "title": "checksum",
            "type": "string"
          }
        }
      },
      "cosmos.base.tendermint.v1beta1.ProofOp": {
        "type": "object",
        "properties": {
          "type": {
            "type": "string"
          },
          "key": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "data": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          }
        },
        "description": "ProofOp defines an operation used for calculating Merkle root. The data could\nbe arbitrary format, providing necessary data for example neighbouring node\nhash.\n\nNote: This type is a duplicate of the ProofOp proto type defined in Tendermint."
      },
      "cosmos.base.tendermint.v1beta1.ProofOps": {
        "type": "object",
        "properties": {
          "ops": {
            "type": "array",
            "items": {
              "type": "object",
              "properties": {
                "type": {
                  "type": "string"
                },
                "key": {
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "format": "byte"
                },
                "data": {
                  "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                  "type": "string",
                  "format": "byte"
                }
              },
              "description": "ProofOp defines an operation used for calculating Merkle root. The data could\nbe arbitrary format, providing necessary data for example neighbouring node\nhash.\n\nNote: This type is a duplicate of the ProofOp proto type defined in Tendermint."
            }
          }
        },
        "description": "ProofOps is Merkle proof defined by the list of ProofOps.\n\nNote: This type is a duplicate of the ProofOps proto type defined in Tendermint."
      },
      "cosmos.base.tendermint.v1beta1.Validator": {
        "type": "object",
        "properties": {
          "address": {
            "type": "string"
          },
          "pub_key": {
            "type": "object",
            "properties": {
              "type_url": {
                "type": "string",
                "description": "A URL/resource name that uniquely identifies the type of the serialized\nprotocol buffer message. This string must contain at least\none \"/\" character. The last segment of the URL's path must represent\nthe fully qualified name of the type (as in\n`path/google.protobuf.Duration`). The name should be in a canonical form\n(e.g., leading \".\" is not accepted).\n\nIn practice, teams usually precompile into the binary all types that they\nexpect it to use in the context of Any. However, for URLs which use the\nscheme `http`, `https`, or no scheme, one can optionally set up a type\nserver that maps type URLs to message definitions as follows:\n\n* If no scheme is provided, `https` is assumed.\n* An HTTP GET on the URL must yield a [google.protobuf.Type][]\n  value in binary format, or produce an error.\n* Applications are allowed to cache lookup results based on the\n  URL, or have them precompiled into a binary to avoid any\n  lookup. Therefore, binary compatibility needs to be preserved\n  on changes to types. (Use versioned type names to manage\n  breaking changes.)\n\nNote: this functionality is not currently available in the official\nprotobuf release, and it is not used for type URLs beginning with\ntype.googleapis.com.\n\nSchemes other than `http`, `https` (or the empty scheme) might be\nused with implementation specific semantics."
              },
              "value": {
                "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
                "type": "string",
                "description": "Must be a valid serialized protocol buffer of the above specified type.",
                "format": "byte"
              }
            },
            "description": "`Any` contains an arbitrary serialized protocol buffer message along with a\nURL that describes the type of the serialized message.\n\nProtobuf library provides support to pack/unpack Any values in the form\nof utility functions or additional generated methods of the Any type.\n\nExample 1: Pack and unpack a message in C++.\n\n    Foo foo = ...;\n    Any any;\n    any.PackFrom(foo);\n    ...\n    if (any.UnpackTo(&foo)) {\n      ...\n    }\n\nExample 2: Pack and unpack a message in Java.\n\n    Foo foo = ...;\n    Any any = Any.pack(foo);\n    ...\n    if (any.is(Foo.class)) {\n      foo = any.unpack(Foo.class);\n    }\n\nExample 3: Pack and unpack a message in Python.\n\n    foo = Foo(...)\n    any = Any()\n    any.Pack(foo)\n    ...\n    if any.Is(Foo.DESCRIPTOR):\n      any.Unpack(foo)\n      ...\n\nExample 4: Pack and unpack a message in Go\n\n     foo := &pb.Foo{...}\n     any, err := anypb.New(foo)\n     if err != nil {\n       ...\n     }\n     ...\n     foo := &pb.Foo{}\n     if err := any.UnmarshalTo(foo); err != nil {\n       ...\n     }\n\nThe pack methods provided by protobuf library will by default use\n'type.googleapis.com/full.type.name' as the type URL and the unpack\nmethods only use the fully qualified type name after the last '/'\nin the type URL, for example \"foo.bar.com/x/y.z\" will yield type\nname \"y.z\".\n\n\nJSON\n\nThe JSON representation of an `Any` value uses the regular\nrepresentation of the deserialized, embedded message, with an\nadditional field `@type` which contains the type URL. Example:\n\n    package google.profile;\n    message Person {\n      string first_name = 1;\n      string last_name = 2;\n    }\n\n    {\n      \"@type\": \"type.googleapis.com/google.profile.Person\",\n      \"firstName\": <string>,\n      \"lastName\": <string>\n    }\n\nIf the embedded message type is well-known and has a custom JSON\nrepresentation, that representation will be embedded adding a field\n`value` which holds the custom JSON in addition to the `@type`\nfield. Example (for message [google.protobuf.Duration][]):\n\n    {\n      \"@type\": \"type.googleapis.com/google.protobuf.Duration\",\n      \"value\": \"1.212s\"\n    }"
          },
          "voting_power": {
            "type": "string",
            "format": "int64"
          },
          "proposer_priority": {
            "type": "string",
            "format": "int64"
          }
        },
        "description": "Validator is the type for the validator-set."
      },
      "cosmos.base.tendermint.v1beta1.VersionInfo": {
        "type": "object",
        "properties": {
          "name": {
            "type": "string"
          },
          "app_name": {
            "type": "string"
          },
          "version": {
            "type": "string"
          },
          "git_commit": {
            "type": "string"
          },
          "build_tags": {
            "type": "string"
          },
          "go_version": {
            "type": "string"
          },
          "build_deps": {
            "type": "array",
            "items": {
              "title": "Module is the type for VersionInfo",
              "type": "object",
              "properties": {
                "path": {
                  "title": "module path",
                  "type": "string"
                },
                "version": {
                  "title": "module version",
                  "type": "string"
                },
                "sum": {
                  "title": "checksum",
                  "type": "string"
                }
              }
            }
          },
          "cosmos_sdk_version": {
            "title": "Since: cosmos-sdk 0.43",
            "type": "string"
          }
        },
        "description": "VersionInfo is the type for the GetNodeInfoResponse message."
      },
      "tendermint.p2p.DefaultNodeInfo": {
        "type": "object",
        "properties": {
          "protocol_version": {
            "type": "object",
            "properties": {
              "p2p": {
                "type": "string",
                "format": "uint64"
              },
              "block": {
                "type": "string",
                "format": "uint64"
              },
              "app": {
                "type": "string",
                "format": "uint64"
              }
            }
          },
          "default_node_id": {
            "type": "string"
          },
          "listen_addr": {
            "type": "string"
          },
          "network": {
            "type": "string"
          },
          "version": {
            "type": "string"
          },
          "channels": {
            "pattern": "^(?:[A-Za-z0-9+/]{4})*(?:[A-Za-z0-9+/]{2}==|[A-Za-z0-9+/]{3}=)?$",
            "type": "string",
            "format": "byte"
          },
          "moniker": {
            "type": "string"
          },
          "other": {
            "type": "object",
            "properties": {
              "tx_index": {
                "type": "string"
              },
              "rpc_address": {
                "type": "string"
              }
            }
          }
        }
      },
      "tendermint.p2p.DefaultNodeInfoOther": {
        "type": "object",
        "properties": {
          "tx_index": {
            "type": "string"
          },
          "rpc_address": {
            "type": "string"
          }
        }
      },
      "tendermint.p2p.ProtocolVersion": {
        "type": "object",
        "properties": {
          "p2p": {
            "type": "string",
            "format": "uint64"
          },
          "block": {
            "type": "string",
            "format": "uint64"
          },
          "app": {
            "type": "string",
            "format": "uint64"
          }
        }
      }
    }
  }
}
